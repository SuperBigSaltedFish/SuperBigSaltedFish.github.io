<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夹缝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jasonzou.me/"/>
  <updated>2017-04-24T15:29:28.000Z</updated>
  <id>http://jasonzou.me/</id>
  
  <author>
    <name>Jason Zou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&lt;b&gt;【置顶】&lt;/b&gt;&lt;br&gt;那些能完成的和不能完成的目标</title>
    <link href="http://jasonzou.me/2099/12/31/%E7%9B%AE%E6%A0%87/"/>
    <id>http://jasonzou.me/2099/12/31/目标/</id>
    <published>2099-12-31T03:53:49.000Z</published>
    <updated>2017-04-24T15:29:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>欲取其中，必求其上；欲取其上，必求上上。 <br> <strong>《孙子兵法》</strong> </p>
</blockquote>
<p>　　我敬佩的人们都具备一个相同的特质，他们是我最喜欢的一位作家口中的“征服者”。他们言出必行，每当决定要去的某个地方，那就一定会去到那里，不管其间有多少艰难险阻，都不曾见他们的斗志消磨殆尽。他们是这个社会中的“优胜者”，是更适应当前社会的“优等人类”。我敬佩的人，也同时是我羡慕的人，我羡慕那种<strong>“脚步一旦迈出，全世界都会为其让路”</strong>的感觉。<a id="more"></a><br>　　尽管我不是“征服者”，但我却不曾间断过“如果我是征服者，那么……”这样的幻想。和幻想成为征服者一样，订立目标对我而言，是一种精神上的<strong>自慰</strong>。目标越详细，越是会产生一种它已经被完成了的快感。代价是，到最后，目标往往都是被我废弃遗忘了的，我必须要承受这份痛苦。就像自慰后的少年，发现自己并不能靠近脑海中的姑娘一点半点一样，痛苦和羞耻感油然而生。<br>　　深知自己难以完成预设目标，但还是必须用目标驱动自己，如果说设下目标的我会因为屡次无法走到目标而痛苦，那么不定目标的我是寸步难行的。因此，我仍将在这夹缝中记下目标，倒不如说，是记下我对我自己的恳求。其中第一个恳求是：<strong>希望自己能每三天总结一次，之前三天做完的事，和之后三天要做的事</strong>（唯独这一个恳求，是希望自己无论如何也不要弃之不顾的）。<br>　　<strong><em>我依然渴望当一个征服者，哪怕是只存在于这夹缝之中的征服者</em></strong> 。</p>
<h3 id="TODO总表–记录能想到的需要做的事（琐事另外记录）"><a href="#TODO总表–记录能想到的需要做的事（琐事另外记录）" class="headerlink" title="TODO总表–记录能想到的需要做的事（琐事另外记录）"></a>TODO总表–记录能想到的需要做的事（琐事另外记录）</h3><ul>
<li>补考学习计划<ul>
<li>思考怎么抽时间做补考准备。</li>
<li>C语言<ul>
<li><del>看考题，订立学习计划。</del></li>
<li><del>复习基础知识，第二周前。</del></li>
<li>每周试做一期试卷，第二周后。</li>
</ul>
</li>
<li>数据结构与算法<ul>
<li><del>看考题，订立学习计划。</del></li>
<li>初期计划<ul>
<li>每周看一章《数据结构与算法（C语言版）》（绪论除外）。</li>
<li>每周完成一章的自测题。</li>
</ul>
</li>
</ul>
</li>
<li>微积分2<ul>
<li><del>看考题，订立学习计划。</del></li>
<li>初期计划<ul>
<li>每周学习一章教材。</li>
<li>做十道本章小题（红皮书）。</li>
</ul>
</li>
</ul>
</li>
<li>计算机组成原理<ul>
<li><del>看考题，订立学习计划。</del></li>
<li>初期计划<ul>
<li>一周看一章教材</li>
<li>形成重点记录文字版</li>
</ul>
</li>
</ul>
</li>
<li>大学物理下<ul>
<li><del>看考题，订立学习计划。</del></li>
<li>第一周通览全书</li>
</ul>
</li>
</ul>
</li>
<li>前端工程化<ul>
<li>学习CSS预编译工具。</li>
<li>了解gulp、grunt。</li>
<li>学习前端测试工具。</li>
<li>学习ESLint使用。</li>
</ul>
</li>
<li>JavaScript语言学习<ul>
<li>设计模式<ul>
<li><del>学习MVC MVP MVVM之间的异同。</del></li>
<li><del>阅读完《JavaScript模式》。</del></li>
</ul>
</li>
<li>阅读完《你不知道的JavaScript·上卷》。</li>
<li><del>学习马原挂科脚本。</del></li>
<li><del>学习“new”的执行过程。</del></li>
<li><del>学习map, reduce, filter。</del></li>
</ul>
</li>
<li>NodeJS<ul>
<li>学习koa。</li>
</ul>
</li>
<li>算法<ul>
<li>阅读《算法导论》。</li>
</ul>
</li>
<li><del>下厨做饭。</del></li>
<li>闲书<ul>
<li><del>阅读《一个叫欧维的男人决定去死》。</del></li>
<li><del>阅读朱光潜先生的《谈美》。</del></li>
<li>阅读《乌合之众》。</li>
</ul>
</li>
<li>影视<ul>
<li>看《一个叫欧维的男人决定去死》电影。</li>
<li>补完昭和元禄落语心中第一季。</li>
</ul>
</li>
<li>Python<ul>
<li><del>学习Python基础语法。</del></li>
</ul>
</li>
<li>blog<ul>
<li>将blog目录部署到gh-pages分支。</li>
<li><del>写完 <em>JavaScript如何面向对象</em>。</del></li>
<li><del>写减肥论文。</del></li>
<li><del>写《记自己第一次下厨》。</del></li>
<li><del>转载《Javascript 中的上下文，我的认识的三个阶段》邹业盛。</del></li>
<li>写昭和元禄落语心中观后感——口口相传。</li>
<li>写《谈美》读后感：风行水上，自然成纹。</li>
<li><del>转载《浅析 NodeJs 的几种文件路径》。</del></li>
<li><del>总结 Safari localhost 跨域问题。</del></li>
<li><del>总结魅族 localhost 上文件无法加载问题。</del></li>
<li>写《一个叫欧维的男人决定去死》读后感：虽然这是假人们的舞蹈。</li>
<li>写“关于如何抽时间做自己不想做的事”总结。</li>
<li><del>翻译《How I Became a Better Programmer》<a href="http://jlongster.com/How-I-Became-Better-Programmer" target="_blank" rel="external">How I Became a Better Programmer</a>。</del></li>
<li><del>转载《MVC , MVP ,MVVM的区别和联系》。</del></li>
<li><del>总结 map, reduce, filter的用法和应用场景。</del></li>
</ul>
</li>
<li>LOL（这是我今年最重要的事）<ul>
<li>打上钻石。</li>
</ul>
</li>
<li>给鸵鸟写生日祝福。</li>
</ul>
<h3 id="琐事（特别有重复性的事如洗澡吃饭换衣服等仅记录第一次）"><a href="#琐事（特别有重复性的事如洗澡吃饭换衣服等仅记录第一次）" class="headerlink" title="琐事（特别有重复性的事如洗澡吃饭换衣服等仅记录第一次）"></a>琐事（特别有重复性的事如洗澡吃饭换衣服等仅记录第一次）</h3><ul>
<li><del>打印<strong><em>跟读协议</em></strong> 。</del></li>
<li><del>买洗发露沐浴露。</del></li>
<li><del>制定5.1计划。</del></li>
<li><del>写实习初期报告。</del></li>
<li><del>订五一的酒店。</del></li>
<li><del>提交实习初期报告。</del></li>
<li><del>邮寄<strong><em>跟读协议</em></strong> 回学院。</del></li>
<li><del>实现博客快捷部署。</del></li>
<li>马原<ul>
<li><del>上马原网课。</del></li>
<li>做马原作业1。</li>
<li>做马原作业2。</li>
<li>做马原作业3。</li>
</ul>
</li>
</ul>
<h3 id="三天计划"><a href="#三天计划" class="headerlink" title="三天计划"></a>三天计划</h3><h5 id="壹（17-03-25-17-03-27）"><a href="#壹（17-03-25-17-03-27）" class="headerlink" title="壹（17.03.25-17.03.27）"></a>壹（17.03.25-17.03.27）</h5><ul>
<li>处理杂事<ul>
<li><del>挂马原网课。</del></li>
<li><del>研究马原网课挂课脚本原理。</del></li>
<li><del>打印<strong><em>跟读协议</em></strong> 。</del></li>
<li>邮寄<strong><em>跟读协议</em></strong> 回学院。</li>
<li><del>写多贝云周报。</del></li>
</ul>
</li>
<li><del>转载《浅析 NodeJs 的几种文件路径》</del></li>
<li><del>阅读《一个叫欧维的男人决定去死》。</del></li>
<li><del>写完 <em>JavaScript如何面向对象</em>。</del></li>
<li><del>学习new的执行过程。</del></li>
<li><del>看C语言考题，订立学习计划。</del></li>
<li><del>看微积分2考题，订立学习计划。</del></li>
<li><del>看数据结构预算法考题，订立学习计划。</del></li>
<li><del>看大学物理下考题，订立学习计划。</del></li>
<li><del>看计算机组成原理考题，订立学习计划。</del><h5 id="贰（17-03-28-17-03-30）"><a href="#贰（17-03-28-17-03-30）" class="headerlink" title="贰（17.03.28-17.03.30）"></a>贰（17.03.28-17.03.30）</h5></li>
<li>处理杂事<ul>
<li>邮寄<strong><em>跟读协议</em></strong> 回学院。</li>
<li><del>买洗发露沐浴露。</del></li>
<li><del>背书包回家。</del></li>
</ul>
</li>
<li><del>C语言：复习基础知识。</del></li>
<li><del>学习学习前端测试工具。</del></li>
<li>微积分2：学习红皮书上的第一章。</li>
<li><del>阅读《JavaScript模式》。</del></li>
<li><del>阅读朱光潜先生的《谈美》。</del></li>
<li><del>阅读《一个叫欧维的男人决定去死》。</del></li>
<li><del>学习MVC MVP MVVM之间的异同。</del></li>
<li><del>转载《MVC , MVP ,MVVM的区别和联系》。</del><h5 id="叁（17-03-31-17-04-02）"><a href="#叁（17-03-31-17-04-02）" class="headerlink" title="叁（17.03.31-17.04.02）"></a>叁（17.03.31-17.04.02）</h5></li>
<li>处理杂事<ul>
<li>订五一的酒店。</li>
<li><del>写实习初期报告。</del></li>
</ul>
</li>
<li><del>阅读朱光潜先生的《谈美》。</del></li>
<li><del>阅读《乌合之众》。</del></li>
<li>阅读《你不知道的JavaScript》。</li>
<li><del>总结魅族 localhost 上文件无法加载问题。</del></li>
<li><del>总结Safari localhost 跨域问题。</del></li>
<li><del>学习map, reduce, filter。</del></li>
<li><del>总结 map, reduce, filter的用法和应用场景。</del></li>
<li>微积分2：学习红皮书上的第一章。</li>
<li><del>看一章《数据结构与算法（C语言版）》（绪论除外）。</del></li>
<li>看一章《计算机组成原理》。</li>
<li><del>翻译《How I Became a Better Programmer》<a href="http://jlongster.com/How-I-Became-Better-Programmer" target="_blank" rel="external">How I Became a Better Programmer</a>。</del><h4 id="肆（17-04-03-17-04-05）"><a href="#肆（17-04-03-17-04-05）" class="headerlink" title="肆（17.04.03-17.04.05）"></a>肆（17.04.03-17.04.05）</h4></li>
<li>处理杂事<ul>
<li><del>好好睡觉。</del></li>
<li><del>订五一的酒店。</del></li>
<li><del>提交实习初期报告。</del></li>
</ul>
</li>
<li><del>阅读《乌合之众》。</del></li>
<li><del>阅读《你不知道的JavaScript》。</del></li>
<li>写《谈美》读后感：风行水上，自然成纹。<h4 id="伍（17-04-06-17-04-08）"><a href="#伍（17-04-06-17-04-08）" class="headerlink" title="伍（17.04.06-17.04-08）"></a>伍（17.04.06-17.04-08）</h4></li>
<li>处理杂事<ul>
<li><del>提醒舅舅修壁挂炉。</del></li>
</ul>
</li>
<li><del>写减肥论文。</del></li>
<li><del>lol班德尔城打上白银二。</del><h4 id="陆（17-04-09-17-04-11）"><a href="#陆（17-04-09-17-04-11）" class="headerlink" title="陆（17.04.09-17.04.11）"></a>陆（17.04.09-17.04.11）</h4></li>
<li>处理杂事<ul>
<li><del>制定五一计划。</del></li>
<li><del>考虑买哪个型号的surface pro。</del></li>
</ul>
</li>
<li><del>学习Python基础语法。</del></li>
<li><del>阅读《你不知道的JavaScript》。</del></li>
<li><del>下厨做饭。</del><h4 id="柒（17-04-12-17-04-14）"><a href="#柒（17-04-12-17-04-14）" class="headerlink" title="柒（17.04.12-17.04.14）"></a>柒（17.04.12-17.04.14）</h4><h4 id="捌（17-04-15-17-04-17）"><a href="#捌（17-04-15-17-04-17）" class="headerlink" title="捌（17.04.15-17.04.17）"></a>捌（17.04.15-17.04.17）</h4><h4 id="玖（17-04-18-17-04-20）"><a href="#玖（17-04-18-17-04-20）" class="headerlink" title="玖（17.04.18-17.04.20）"></a>玖（17.04.18-17.04.20）</h4></li>
<li>处理杂事<ul>
<li><del>买彩票。</del></li>
<li><del>买菜。</del></li>
<li><del>找《昭和元禄落语心中》第一季资源。</del></li>
</ul>
</li>
<li><del>阅读《你不知道的JavaScript》。</del></li>
<li><del>写《记自己第一次下厨》。</del></li>
<li>补完《昭和元禄落语心中》第一季。</li>
<li>看一章C语言。</li>
<li><del>实现博客的快捷部署。</del></li>
<li>看一章计网。<h4 id="拾（17-04-21-17-04-23）"><a href="#拾（17-04-21-17-04-23）" class="headerlink" title="拾（17.04.21-17.04.23）"></a>拾（17.04.21-17.04.23）</h4></li>
<li>处理杂事<ul>
<li><del>买衣服。</del></li>
</ul>
</li>
<li><del>转载《Javascript 中的上下文，我的认识的三个阶段》邹业盛。</del></li>
<li><del>给鸵鸟写生日祝福。</del></li>
<li><del>做马原作业1。</del></li>
<li><del>思考怎么抽时间做补考准备。</del></li>
<li><del>写“关于如何抽时间做自己不想做的事”总结。</del><h4 id="拾壹（17-04-24-17-04-26）"><a href="#拾壹（17-04-24-17-04-26）" class="headerlink" title="拾壹（17.04.24-17.04.26）"></a>拾壹（17.04.24-17.04.26）</h4></li>
<li>处理杂事<ul>
<li>邮书给李丰林。</li>
</ul>
</li>
<li>看完《你不知道的JavaScript》。</li>
<li>看一章《微积分2》。</li>
<li><del>写《谈美》读后感：风行水上，自然成纹。</del></li>
</ul>
<!-- 来必力City版安装代码 -->
<p><div id="lv-container" data-id="city" data-uid="MTAyMC8yODMxOC80ODkw"><br>  <script type="text/javascript"><br>   (function(d, s) {<br>       var j, e = d.getElementsByTagName(s)[0];</p>
<pre><code>if (typeof LivereTower === &apos;function&apos;) { return; }

j = d.createElement(s);
j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;;
j.async = true;

e.parentNode.insertBefore(j, e);
</code></pre><p>   })(document, ‘script’);<br>  </script></div></p>
<p><noscript> 为正常使用来必力评论功能请激活JavaScript</noscript><br><br><!-- City版安装代码已完成 --></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;欲取其中，必求其上；欲取其上，必求上上。 &lt;br&gt; &lt;strong&gt;《孙子兵法》&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　我敬佩的人们都具备一个相同的特质，他们是我最喜欢的一位作家口中的“征服者”。他们言出必行，每当决定要去的某个地方，那就一定会去到那里，不管其间有多少艰难险阻，都不曾见他们的斗志消磨殆尽。他们是这个社会中的“优胜者”，是更适应当前社会的“优等人类”。我敬佩的人，也同时是我羡慕的人，我羡慕那种&lt;strong&gt;“脚步一旦迈出，全世界都会为其让路”&lt;/strong&gt;的感觉。
    
    </summary>
    
      <category term="最无用的东西" scheme="http://jasonzou.me/categories/%E6%9C%80%E6%97%A0%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>风行水上，自然成纹</title>
    <link href="http://jasonzou.me/2017/04/24/%E9%A3%8E%E8%A1%8C%E6%B0%B4%E4%B8%8A%EF%BC%8C%E8%87%AA%E7%84%B6%E6%88%90%E7%BA%B9/"/>
    <id>http://jasonzou.me/2017/04/24/风行水上，自然成纹/</id>
    <published>2017-04-24T13:46:39.000Z</published>
    <updated>2017-04-24T15:29:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>风行水上，自然成纹。 <br> <strong>朱光潜</strong> </p>
</blockquote>
<p>　　美是什么？<br>　　美是擦身而过后仍然如挂在眼角上的水珠般水灵的姑娘；美是入耳后让人驻足顾盼心生向往的笛鸣；美是求婚时含在嘴里的玫瑰和玫瑰一样兴奋脸红的准新娘；美是苦苦等待后终于从地平线下渗出的朝阳；美也是晚霞映衬下一支微<a id="more"></a>微颤烁的发簪；美可以是“烟笼寒水月笼沙”；美也可以是“大漠孤烟直，长河落日圆。”；有人说美是斑驳如老人皱纹般的古树之经络；也有人说美是如古树般沧桑的老人的皱纹。<br>　　美是难以用例子穷尽的。不论是文字，乐曲，图画这种人为之物还是某一个人，某一棵树，某一座山，某一颗星球这种自然之物，都可能蕴藏着所谓的美。<br>　　“美”这个字本身是人类语言匮乏的证明，但难以表达传播本身也是美的一大特征。<br>　　如此抽象之物就不多去给它下些苍白乏味的定义了。<br>　　朱光潜先生说：美的本质不是孤立的。<br>　　试图去定义它，必须要考虑所处时期的各种背景。此等繁杂且专业之事并非我想说的。<br>　　如何创造美更让我好奇。<br>　　美不是自然，如果说自然的就是美的，那么“创造美”也就无从谈起了。自然不是美，但自然却可被称为美的土壤。人的意愿是种子，人的抽象是培植。<br>　　创造美应是一种邂逅。<br>　　心境和所处之处能交织共鸣时，美就播下了种子。而之后是匠人的雕刻，诗人的吟诵，钢琴家的哆啦咪发，书法家的纵情挥毫，让美绽放并刻录进每一份作品之中。<br>　　并不是说只有作家才有能力创造美，有时美也可以是印在瞳孔上的影子，可以是环绕耳畔的鸟鸣。只是说，作家更擅长记录和传播美。<br>　　我想学会如何创造和传播美。<br>　　这便是我的读后感。<br>　　“创造美”突然间就成了我非常想做的事。<br>　　这源于我对自己和身边人的愧疚。<br>　　我实在不是什么美的东西，但我能看见我身边的人包括我自己对于各种“美”的期待。而和我的相处难免会误了不少本属于她们的与美相遇的机会，那我理应用上自己的浑身解数去记录下并分享一些美的东西给她们和我自己。<br>　　这算是一种严肃而要紧的救赎。<br>　　再回到“如何创造美”上。<br>　　朱光潜先生在书中给出了他的见解。<br>　　我总结大致为：美是不可强求的。灵感所至之时，用恰当的匠人技法，将其发挥和记录即可。<br>　　技法是重要的，不论是书法，写作，创作乐曲，作画还是别的所有创造，都需要一定的技法支持。这一点只能多做学习，勤加磨练了。<br>　　而我认为最值得我记住的是：美不可强求。<br>　　“乘兴而来，兴尽而返”<br>　　如前文所说的，美是邂逅。随灵感而来，你若不握紧并雕琢之，她很快就会随时间的流沙而返。<br>　　因此，好美之人理应把握和珍惜灵感。<br>　　与此同时，光是匠人之工巧，是不足以创造美的，没有灵感的卖弄，只会让人尴尬作呕，避退不及。<br>　　因此，好美之人理应适时放手。决不可为作文而作文。<br>　　所谓：风行水上，自然成纹。<br>　　我希望我至少在这片小小的夹缝中，我所有的文字都能是行云和流水，都是风划过我心中时，自然留下的波纹。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;风行水上，自然成纹。 &lt;br&gt; &lt;strong&gt;朱光潜&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　美是什么？&lt;br&gt;　　美是擦身而过后仍然如挂在眼角上的水珠般水灵的姑娘；美是入耳后让人驻足顾盼心生向往的笛鸣；美是求婚时含在嘴里的玫瑰和玫瑰一样兴奋脸红的准新娘；美是苦苦等待后终于从地平线下渗出的朝阳；美也是晚霞映衬下一支微
    
    </summary>
    
      <category term="感" scheme="http://jasonzou.me/categories/%E6%84%9F/"/>
    
    
      <category term="灵感" scheme="http://jasonzou.me/tags/%E7%81%B5%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于如何抽时间做自己不想做的事</title>
    <link href="http://jasonzou.me/2017/04/23/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%8A%BD%E6%97%B6%E9%97%B4%E5%81%9A%E8%87%AA%E5%B7%B1%E4%B8%8D%E6%83%B3%E5%81%9A%E7%9A%84%E4%BA%8B/"/>
    <id>http://jasonzou.me/2017/04/23/关于如何抽时间做自己不想做的事/</id>
    <published>2017-04-23T07:04:36.000Z</published>
    <updated>2017-04-23T08:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　写这篇文章是基于我现在十分困扰的现状。现状指：最近的一周中，我尝试在下班之后抽时间复习学校里的功课准备补考，发现并没有办法找到时间和状态。没有办法找到时间和状态的原因主要有：我计划要自己做饭填饱自己占用了下班到九点过的时间，人比较困乏，没有足够的动力。<br>　　简单思考一下后，我认为：时间的问题还是可以解决的，以后回家路上买好吃的面包就行了。人比较困乏，这个只能尽量早上床了。没有足够的动力这才是核心的问题所在。<br><a id="more"></a><br>　　事实上，没有足够的动力，也意味着只要稍微有点困乏我就不会去看书学习。这是我从小到大都一直头疼的问题：如何抽时间做自己不想做的事？<br>　　倘若是我主观上想去做的事，那没有条件我会想办法去创造条件，或者条件不好我也能忍受。但面对不想做的事，这实在是难以骗自己去好好做。我有时候甚至会问自己，我到底值不值得为了个毕业证逼自己去学这些没用的课程。毕业证是不是真的有那么重要的以至于我要花费我我宝贵的下班时间和宝贵的玩游戏的时间去学习课本知识以获取。<br>　　可是人这一辈子，总是会遇到必须要做自己不想做的事的情况。因而我有理由而且有必要思考一下，遇到这种情况时，该怎么办。<br>　　我在我的计划列表的开头引用了：欲取其中必求其上…但是，在这次的实习中，我发现了一个让我很无奈的规律，以最近的一个任务为例：组长说，给你一个任务，下周二前做完，于是我给自己定了个目标——周二前尽量做完，而后我在周二完成了七成，之后一直修补，直到第二周周四才完全做完。这哪里是欲取其中必求其上啊？这分明是欲取其中必求上上，而后可得其下啊。真心而言：我并不为这件事感到沮丧。倒不如说，我找到了一个做不愿做的事时的一个时间轴。先给自己找个距离deadline比较远的时间点为目标开始工作，到了deadline求别人宽限点时间大概就能做完那件事了。<br>　　所以我在想，倘若再让我订一次学习目标，那么我要要求自己以八十分为基准，提前一个月全部复习完，那我可能最后考试可以及格。<br>　　区别还是有的：我认为自己对公司给的活是尽心尽力的，公司的活在主观上根本不算是不想做的事。<br>　　拿公司的经历做比是因为公司的活要比重修难不少，算上我自己的怠惰之后，其实两者的难度是差不多的。<br>　　因此不妨，以后就这么去订目标，指不定，我真的可以在有生之年拿到这个我还没想清楚拿来做什么的毕业证。暂且试一试吧。<br>　　还是没办法想到一个合适的解决方案。只靠我自己的话，暂时还没有办法让自己坚持做自己不想做的事。<br>　　太难了。</p>
<p style="text-align: center;"><b>… 待续 …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　写这篇文章是基于我现在十分困扰的现状。现状指：最近的一周中，我尝试在下班之后抽时间复习学校里的功课准备补考，发现并没有办法找到时间和状态。没有办法找到时间和状态的原因主要有：我计划要自己做饭填饱自己占用了下班到九点过的时间，人比较困乏，没有足够的动力。&lt;br&gt;　　简单思考一下后，我认为：时间的问题还是可以解决的，以后回家路上买好吃的面包就行了。人比较困乏，这个只能尽量早上床了。没有足够的动力这才是核心的问题所在。&lt;br&gt;
    
    </summary>
    
      <category term="最无用的东西" scheme="http://jasonzou.me/categories/%E6%9C%80%E6%97%A0%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>【转载】JavaScript中的上下文，我的认识的三个阶段</title>
    <link href="http://jasonzou.me/2017/04/21/%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%8C%E6%88%91%E7%9A%84%E8%AE%A4%E8%AF%86%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
    <id>http://jasonzou.me/2017/04/21/中的上下文，我的认识的三个阶段/</id>
    <published>2017-04-21T01:54:38.000Z</published>
    <updated>2017-04-21T05:09:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p>　　本文转自<a href="https://www.zouyesheng.com/" target="_blank" rel="external">邹业盛的博客</a>：<a href="https://www.zouyesheng.com/js-context.html" target="_blank" rel="external">Javascript 中的上下文，我的认识的三个阶段</a>。<br><a id="more"></a></p>
<p>　　js 中的 上下文 Context，可以说是一个，你即使不知道，没听过，也不影响你继续写 js 代码的一个概念。但是，它又确确实实是无所不在的一个东西，是的，无所不在。<br>从我自己的经验来看，对上下文的认识，算是分成了三个阶段，每一个阶段，都让我从外在的表现中，理解了一些更本质上的东西。</p>
<h3 id="第一阶段，不知"><a href="#第一阶段，不知" class="headerlink" title="第一阶段，不知"></a>第一阶段，不知</h3><p>　　我最开始接触 js 的时候，看到了它的 new ，看到了它的 this ，很自然地会把 js 和其它的一些 OOP 语言等同起来看待，并且，好像，也是这么回事。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Class = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ins = <span class="keyword">new</span> Class(<span class="number">1</span>);</div><div class="line">ins.add();</div><div class="line"><span class="built_in">console</span>.log(ins.a); <span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>　　上面的代码，可以按预期的那样，最后得到 2 的输出。<br>　　但是，如果仅仅是 类，实例 这种层面的认识，我无法解释下面的问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ins = <span class="keyword">new</span> Class(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> func = ins.add;</div><div class="line">func();</div><div class="line"><span class="built_in">console</span>.log(ins.a); <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>　　甚至解释不清楚下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj.add();</div><div class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>　　这里可没有<strong>类</strong>，也没有<strong>实例</strong>。<br>　　我上面的最开始对 js 的认识当中，局限就在于，把 this 理解成了 实例 。也许在其它语言中（比如 Python 常用的实例方法第一个参数 self），是这样。但是在 js 中， this 跟 实例 完全没有关系。</p>
<h3 id="第二阶段，this"><a href="#第二阶段，this" class="headerlink" title="第二阶段，this"></a>第二阶段，this</h3><p>　　当我明白问题出在 this 上，或者说，当我终于理解了 this 这个东西之后，上面的代码，再也不会困扰我了。<br>　　我知道了， js 中有一个东西叫 上下文 ，可惜的是，这时，我对上下文的概念，仅仅停留在 this 上。<br>　　这时我的理解是： this 表示的是，函数调用时的 上下文 。<br>　　说得详细一点，就是 this 不是表示的 实例 ，而是函数调用时的 上下文 。 上下文 这个东西，默认是 window ，即 全局 。但是，你可以明确地为函数指定一个 上下文 。回到 this 上，就是在定义时你根本不知道 this 是什么，因为在调用时，它可以是任何东西（因为 上下文 是可以人为指定的）。</p>
<p>　　回到刚开始的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Class = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ins = <span class="keyword">new</span> Class(<span class="number">1</span>);</div><div class="line">ins.add();</div><div class="line"><span class="built_in">console</span>.log(ins.a); <span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>　　这段代码的结构之所以是 2 ，不是因为 实例 ，而是因为 上下文 。<br>　　首先说一下 new 。 new 在 js 中，不考虑原型链，它的作用相当于是先创建了一个空的对象，然后把这个空的对象，作为 构造函数 的 上下文 ，再去执行 构造函数 ，最后再返回这个当初的空对象。即：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> what_new = <span class="function"><span class="keyword">function</span>(<span class="params">func, a</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> context = &#123;&#125;;</div><div class="line">  func.apply(context, [a]);</div><div class="line">  <span class="keyword">return</span> context;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Class = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ins = what_new(Class, <span class="number">1</span>);</div><div class="line">ins.add();</div><div class="line"><span class="built_in">console</span>.log(ins.a);</div></pre></td></tr></table></figure></p>
<p>　　当然， new 除了上面的 func.apply 的作用之外， 它还会处理原型链 ，这里就不介绍了。上面的代码仅是为了说明 new 对于所谓的构造函数做了什么事。<br>　　有了上下文，就不难解释 ins 这个东西了。所谓的构造函数，只是在指定了 this 到底是哪一个对象之后，作了相应的赋值操作而已，最后得到这个对象的返回，经过了一些赋值操作，对象中就有了新的东西了。<br>　　同样，对于一个在定义时包含了 this 的函数，比如前面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　如果来一句：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = obj.add;</div><div class="line">func(); <span class="comment">//undefined</span></div><div class="line">func.apply(&#123;<span class="attr">a</span>: <span class="number">0</span>&#125;) <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>　　这些都很容易明白了。 js 中的函数，都是一些很单纯的函数，所有的函数跟它在哪里定义完全没有关系（考虑闭包的情况除外）。所以上面的代码，虽然 add 函数是写在 obj 中的，但是，它跟你在 window 中写一个函数是 完全一样 的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.a++&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">add</span>: add</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　既然 add 函数中有 this ，那么这个函数执行时的行为，就要小心一点了。所以上面明确地指定了一个上下文给它 func.apply({a: 0}) 。<br>　　还是回到开始的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　对于上面的代码，我知道了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.add();</div></pre></td></tr></table></figure></p>
<p>　　和：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = obj.add();</div><div class="line">func();</div></pre></td></tr></table></figure></p>
<p>　　会得到不一样的结果。并且知道，这个不一样的结果是上下文引起的，还知道，后者 func() 执行时，上下文是全局的 window 了。<br>　　我虽然知道是这样的一个情况，但是，为什么？执行同一个函数结果怎么就不一样了呢？<br>　　我在很长时间里，都没有去细细考虑过这个问题。不过，因为知道了“上下文是一个在定义时无意义，其具体值完全由执行时决定”这点之后，我都尽量避免去使用 this ，实在要用，在调用时，我都会通过 apply 或 call 明确指定上下文，这样，至少不会踩坑里。</p>
<h3 id="第三阶段，一切都是上下文"><a href="#第三阶段，一切都是上下文" class="headerlink" title="第三阶段，一切都是上下文"></a>第三阶段，一切都是上下文</h3><p>　　某天，我在网上看到了这样一段代码（原始出处不知道）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bind = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Function</span>.prototype.bind)</div></pre></td></tr></table></figure></p>
<p>　　这个新定义的 bind 函数具体做什么事先不管它，我好奇的是 call.bind() 这个调用。因为 call 这个函数，之前一直以为它是 Function 对象的一个方法（它本身也是一个函数），但是，如果按“对象的方法”这个角度去想的话，那对它绑定一个上下文（ bind() 的调用 ）不就完全没有意义了么？（因为对象的方法应该是跟上下文无关的）<br>　　后来看到了这篇文章，<a href="http://www.html-js.com/article/JavaScript-functional-programming-in-Javascript-Bind-Call-and-Apply" target="_blank" rel="external">http://www.html-js.com/article/JavaScript-functional-programming-in-Javascript-Bind-Call-and-Apply</a><br>　　其中以 slice 函数举的例子让我恍然大悟：</p>
<ul>
<li>上下文控制不仅仅是 apply / call，所有的点 . ，都是在指定上下文。</li>
<li>js 中的函数比我想像的还要纯，根本没有“对象中的方法”这个东西，即使是“原生对象”中。（它仅仅起一个名字空间的作用）</li>
</ul>
<p>　　所有的函数调用，都有两层意义，比如 c.f()：</p>
<ul>
<li>f 这个函数，它在 c 中。（名字空间的问题）</li>
<li>把 c 作为 f 的上下文，去调用 f 。（前提是 f 没有绑定过上下文）如果 c 没有，则默认是 window 。</li>
</ul>
<p>　　所有的，js 中所有的函数调用，都是如此。即使是 f.call(context, x) ，我之前只看到了第一层意义（ f 中有一个 call 方法可以使用），则忽略了第二层意义 —— 把 f 作为 call 的上下文。<br>　　简单来说，我们可以相像 call 这个函数，它的代码大概是这样的（可变参数的问题先不管）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> call = <span class="function"><span class="keyword">function</span>(<span class="params">context, a</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> new_func = <span class="keyword">this</span>.bind(context);</div><div class="line">    retur new_func(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　它的作用，就是把 指定的上下文（context） 作为 自己的上下文（this） 的 上下文 ，然后再调用 自己的上下文（绑定上下文之后的 this） 。<br>　　上面一句话有些纠结哈，主要搞明白多种上下文的关系， f.call(context, x) 当中， 自己的上下文 上面是 f 。 指定的上下文 上面是 context 。<br>　　再看 f.call(context, x) 这个代码，结合“函数是单纯”这点，我想到，即使是原生对象的那些方法， 也不过是把一些单纯的函数放到了 prototype 中而已 ，比如把 call 函数放到了 Function.prototype 当中。<br>　　至此，再看 c.f() ， a.b.c() 这些，不要去想是调用 c 对象中的 f 方法（这么说没错，但是名字空间的问题是显而易见的嘛），而是想成，调用时把 c 作为 f 的上下文。<br>　　好了，回到开始的那行例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> new_bind = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Function</span>.prototype.bind)</div></pre></td></tr></table></figure></p>
<p>　　这个就非常好理解了（为了描述方便，我改成 new_bind 了），把 bind 作为上下文绑定到 call 中。<br>　　这里注意一下，绑定了上下文的 call 函数，还是 call 函数，但是 “此 call 已经非彼 call” 了。<br>　　所以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new_bind != <span class="built_in">Function</span>.prototype.call</div></pre></td></tr></table></figure></p>
<p>　　虽然调用形式上， new_bind 和 call 完全一样，但是他们的上下文行为不一样：</p>
<ul>
<li>call 是未绑定状态，所以 f.call() 会在执行时把 f 作为上下文绑定到 call 函数中。</li>
<li>new_bind 是已绑定状态，所以 f.new_bind() 对 new_bind() 的执行完全没影响。</li>
</ul>
<p>我们可以以这样的流程来帮助我们理解：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new_bind =&gt; <span class="function"><span class="params">call</span> =&gt;</span> bind.call =&gt; bind.call(f, context) =&gt; f.bind(context)</div></pre></td></tr></table></figure></p>
<p>一步一步解释：<br>　　new_bind =&gt; call：</p>
<pre><code>　　new_bind 在形式上就是 call 。
</code></pre><p>　　call =&gt; bind.call：</p>
<pre><code>　　只是这个 call ，是指定了 bind 作为它的上下文的。既然是 bind 作为它的上下文，那我们可以写成是 bind.call 的样式。
</code></pre><p>　　bind.call(f, context) =&gt; f.bind(context)：</p>
<pre><code>　　new_bind 的调用 new_bind(f, context) 就相当于是 bind.call(f, context) 。考虑 call 函数之前的行为： f.call(context, a) 是把 context 作为 f 的上下文，也就是 context.f(a) ，那么 bind.call(f, context) 对应的就是 f.bind(context) 。
</code></pre><p>　　f.bind(context)：</p>
<pre><code>　　不用多说了吧，把 context 绑定到 f 上，返回一个绑定了上下文的新函数。
</code></pre><p>　　完全是最基本的代数推导嘛，形式上，上下文前置总是没有问题的。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>　　我一直认同，要理解 js 的东西，从函数式语言入手，非常合适。硬要往面向对象的那套东西上套，太纠结了（我不管概念上到底什么样才叫面向对象，原生没有类定义，没有继承，没有实例化，就别扯这些就完了。对了，我认为原型追溯那不叫继承哈）。<br>　　当然，我不知道弄明白了最后那个“代数推导”到底有什么好处，也许没有，因为就算不明白这些也不影响我写了很多可以正常工作的 js 代码嘛。只是，我以后再写，思路上的可能会有一些不同了。比如代码组织的形式上，可以尝试把很多的小函数做到不同的“名字空间”中，然后再在业务层面，通过 Mixin 来拼出不同的业务对象。这些函数中可能到处充斥着 this ，我能控制好它们了。</p>
<p style="text-align: center;"><b>… End …</b></p>



]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原文链接&quot;&gt;&lt;a href=&quot;#原文链接&quot; class=&quot;headerlink&quot; title=&quot;原文链接&quot;&gt;&lt;/a&gt;原文链接&lt;/h3&gt;&lt;p&gt;　　本文转自&lt;a href=&quot;https://www.zouyesheng.com/&quot;&gt;邹业盛的博客&lt;/a&gt;：&lt;a href=&quot;https://www.zouyesheng.com/js-context.html&quot;&gt;Javascript 中的上下文，我的认识的三个阶段&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript知识总结" scheme="http://jasonzou.me/categories/JavaScript%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://jasonzou.me/tags/JavaScript/"/>
    
      <category term="this" scheme="http://jasonzou.me/tags/this/"/>
    
      <category term="上下文" scheme="http://jasonzou.me/tags/%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
      <category term="context" scheme="http://jasonzou.me/tags/context/"/>
    
  </entry>
  
  <entry>
    <title>记我第一次下厨</title>
    <link href="http://jasonzou.me/2017/04/18/%E8%AE%B0%E6%88%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8B%E5%8E%A8/"/>
    <id>http://jasonzou.me/2017/04/18/记我第一次下厨/</id>
    <published>2017-04-18T13:47:20.000Z</published>
    <updated>2017-04-21T11:56:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>王者以民为天,而民以食为天。 <br> <strong>《汉书·郦食其传》</strong> </p>
</blockquote>
<p>　　不过是一碗面罢了。<a id="more"></a><br>　　不过是一碗面罢了，怎好意思称之为下厨呢？但这的确是我第一次在厨房中捣鼓出能入口的食物。<br>　　客观而言，我煮的面很和我的口味。它没有猪油，我的母亲和外婆的面永远是有猪油的。它很细，奶奶煮的面总是选宽面。它软又不至于腻做一团，哥哥的面总是很硬。<br>　　下班后立马就往住处赶，我怕楼下负一层的菜市等不到我平时到家的那一刻。匆匆忙忙地，匆忙得像所有匆忙回家做饭的其他人。下地铁打电话问哥哥买多少钱的小葱和小白菜合适，偏偏问了还是把1块钱的小葱买做了2块钱的。<br>　　七点过就到家了。算是很早的。洗菜切葱拍蒜，又打电话给母亲询问调料该怎么配：醋、鸡精、酱油、花椒面、藤椒油、辣椒油和再半勺辣椒油，我是一个土生土长的峨眉乐山人。水开下面，再开下菜，再开试尝。软硬合适就关火装碗。<br>　　客观而言，味道真的是不错的。<br>　　但仍然不过是一碗面罢了。<br>　　面是现成的，辣椒油是现成的，配料都是现成的。煮面时出神，竟想到：用编程做比，这就是个什么接口都准备好了的体力活。我曾浅略地思考过，学习开发网页对我有什么改变，一条一条总结的话，读上去就像十一月树上的最后一片枯叶一样干煸乏味。有幸地是，给别人讲自己下厨煮面时的胡思乱想并不那么无趣。面是怎么做的，煮多久合适，最少煮多久，最多煮多久，养胃的面是说的所有的面吗？假如是，那煮多久都养胃吗？辣椒油又是怎么做的，多少合适。别的调料加多少合适？为什么不适合加花椒，要用花椒面呢？藤椒油和花椒面都是麻的为什么值得一样加一点？加多少面汤合适，不至于让味道太淡又不让面腻成一团。面汤为什么适合用来洗碗？菜对面的帮助有哪些？怎么装碗能让面看上去好看些。<br>　　无非是一大堆成熟的封装程度很高的公共库（各种调料）和一个自造的轮子（辣椒油）在开水和面汤的环境中对面条（主要的参数）进行简单的软化加热（类似于解析或是转换格式）和调味（改变一些旧的属性赋予一些新的属性），并最终输出食物：面条吗？<br>　　为什么原料和调料众多，但是想深入研究的只有面和辣椒油呢？因为辣椒油是自造的轮子，不是现成的，是自己迟早也要造的轮子。而面条和别的调料不同，在这个处理中，面条是最重要的主要参数，值得理解它的一些深层次的属性乃至原理。<br>　　大多数人十二岁前就会煮面喂饱自己了，而我自己第一次煮面竟然是二十一岁。<br>　　十二岁的我，大概会想，煮个面而已，想这么多不会累吗？而二十一岁的我竟然已经把这种并没有什么意思的联想当成了一种娱乐。<br>　　独自生活的话免不了要自己做饭的。我离开父亲母亲，从四川一路到了北京，其实早料到了会有个这样的第一次。<br>　　北京是一个让我抑郁的地方。午间小憩，不经意间回想起自己儿时的种种。<br>　　小时候的我被管束得很严，父亲是一个小学老师，我在过去的文字里应该也提过了。总之，那时候的我向往鸟，觉得自己是笼子里的小动物。后来真的就自由了，谁也管不了我，我不信宗教，不信马克思主义，不为传统文化骄傲，更不会热爱任何的党，任何的国家。我真的很自由，不论是身，还是心。<br>　　可是，真正成了鸟，又发现自己原来更想当条狗。城里的人想长出翅膀飞出墙外，到了墙外却不知道要飞到哪里，才明白，自由竟是迷茫脆弱恐惧和孤独的代名词。此时，才想回到城里，回到笼子里。没有约束自己的那层皮，气球就不是气球，只是一团随时会消散泯灭于世间的空气。飞在天上的鸟，他想去哪里就去那里，然而不管到了哪里，都和前一处一样，四周空荡荡的，只有从东西南北吹来的风、如来掌心般的云层和东升西落的太阳。而自己曾经奋力摆脱的那片大地，隔远一看，才是多姿多彩的。城外的天，只有在城里人的眼中才是美妙的。<br>　　反而怀念起了小学的日子。
　　</p>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;王者以民为天,而民以食为天。 &lt;br&gt; &lt;strong&gt;《汉书·郦食其传》&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　不过是一碗面罢了。
    
    </summary>
    
      <category term="胡诌" scheme="http://jasonzou.me/categories/%E8%83%A1%E8%AF%8C/"/>
    
    
      <category term="学做菜" scheme="http://jasonzou.me/tags/%E5%AD%A6%E5%81%9A%E8%8F%9C/"/>
    
  </entry>
  
  <entry>
    <title>减肥对精神健康的作用</title>
    <link href="http://jasonzou.me/2017/04/10/%E5%87%8F%E8%82%A5%E7%9A%84%E7%90%86%E7%94%B1/"/>
    <id>http://jasonzou.me/2017/04/10/减肥的理由/</id>
    <published>2017-04-09T17:16:47.000Z</published>
    <updated>2017-04-09T18:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>一鼓作气，再而衰，三而竭<br> <b>左丘明</b> </p>
</blockquote>
<p>　　这是我给女朋友写的小论文。纯属发泄情绪，胡诌乱道一通。</p>
<h3 id="减肥是一种理性行为"><a href="#减肥是一种理性行为" class="headerlink" title="减肥是一种理性行为"></a>减肥是一种理性行为</h3><p>　　减肥是一种理性的行为。尽可能的增重是人与生俱来的本能，在食物并不充足的时代，人会尽可能多的摄入食物。食物充足的时候，摄入的食物除了提供人日常劳作的能量，部分还会转化为脂肪，存储在人体中。而在人难以补充充足的能量时（例如生病后，不能很好的吸收食物），之前存储下的脂肪会成为宝贵的资源。因此，在过去的时代里，因为食物并不总是充足的，所以食欲旺盛的人更有活下去的可能性。旺盛的食欲在一番物竞天择后，留在了如今很多人的基因中。<br>　　当今绝大部分中国人并不缺少食物，尤其是青少年。因此，胃口太好在现代社会中，还会对人起到消极作用。缺乏节制地，不合理地饮食往往会让人肥胖。<br><a id="more"></a><br>　　当进食的本能成为健康的敌人，部分人选择减肥。减肥是不盲目遵从本能的理性行为。人类的各种理性行为是其与普通动物的区别所在。<br>　　过去谈到减肥，人们会更多地注意到它对人体健康的益处。我认为，减肥的意义不只在于促进人的身体健康，它更能促进一个人的精神健康。</p>
<h3 id="减肥能助人产生积极的意志"><a href="#减肥能助人产生积极的意志" class="headerlink" title="减肥能助人产生积极的意志"></a>减肥能助人产生积极的意志</h3><p>　　减肥能够磨炼人的意志。这里的意志，指的是一种对自我的控制力。<br>　　前文提到了：减肥这一行为，必然伴随着对本能的压制。这是一种自我控制的体现。具体而言，健康的减肥主要有合理饮食和适当运动组成。肥胖的人一般有着睡前四小时内进食，食物营养过盛或营养不均衡等行为现象。将不良的饮食习惯纠正，需要人对自己本能中的食欲进行控制。古人云：食色性也。作为人类的两大天性之一，控制食欲的难度是不低的。我们可以观察到，越是年幼的儿童乃至幼儿，越缺乏对食欲的控制能力。因此我们可以认为，对进食的控制，是成熟的人才具有的能力之一。而连控制进食都做不到的人，其自控力是不完善的。<br>　　减肥的人普遍还会自发的进行体育锻炼。趋利避害是人的一种重要的能力，而利益从时间划分可分为眼前的利益和长远的利益。举例而言，在床上睡一天，在短期内是让人愉悦的。但，从长期来看，荒废时间是不利于长远利益的。进行体育锻炼的人亦是如此。拒绝锻炼可以获得短期的利益，而进行锻炼将获得长远的利益。如果长远的利益大于短期的利益，理想情况下的人是会放弃短期利益而选择长期利益的。对此，美国科学家曾对一群小朋友做过一个简单的实验，能坚持30分钟不吃掉眼前的一颗糖的小孩，将获得三颗糖的奖励。成功坚持到三十分钟不吃糖的小朋友在长大后成就普遍远大于不能坚持三十分钟的小朋友。尽管进行减肥行为的不只是儿童，但同样的道理是适用的。能坚持锻炼的人往往更有实现自己的目标，成就自己的理想。<br>　　不论是对于本能的控制力，还是对于短期利益的抵抗力，这都属于积极的意志力。<br>　　减肥能够锻炼一个人对于长期利益和短期利益的取舍能力。人在达成一些事之后，产生满足感。从生物学的角度讲，满足感来源于大脑分泌的多巴胺。举例而言：吸毒之后，人的大脑中就会大量的堆积多巴胺，因此人会感到精神愉悦。同样能产生愉悦感的还有：每天都进行运动，坚持一年，并形成一副健康的躯体。前者和后者的差别不必多说。举这个极端的例子是为了说明一点：偷懒也是会产生依赖性的，万不可认为松懈一天没有关系，会轻易松懈某一天的人的结局往往是之后的每天都在偷懒松懈。这和吸毒上瘾的机制是有些类似的，吸毒者成瘾是因为毒品效力消失后，人体会产生不适感，毒品用量越大，不适感越强。屈服于自己的惰性也是同样的，偷懒时愉悦，事后后悔痛苦，为了从消极情绪中解脱，于是选择更多的懈怠以获取愉悦感。一但懈怠了，人就会越来越难以坚持原本的目标。<br>　　因此坚持减肥不仅是在打磨自己的身体，同样也是在打磨自己心灵。</p>
<h3 id="成功的减肥是一种强大的“精神资源”"><a href="#成功的减肥是一种强大的“精神资源”" class="headerlink" title="成功的减肥是一种强大的“精神资源”"></a>成功的减肥是一种强大的“精神资源”</h3><p>　　成功的减肥经历是一种“精神资源”。所谓“精神资源”，有可以称之为一个人自信的源泉。一个减肥成功的人，往往具有充足的自信。能成功减肥的人能对自己做出两个清晰的判断：一是，自己可以控制自己的天性。二是，自己能够不受短期的利益的诱惑。这样的人在面临挑战的时候必然是泰然自若的。<br>　　从反面而言，一个减肥失败的人，在做别的事时很可能会怀疑自己。比如，作为一个学生，如果他不能成功的减肥，那么他也会怀疑自己能否坚持每天背单词。一个研究人员，如果不能成功减肥，他必定会怀疑自己能否耐得住多次实验失败时的寂寞和苦闷。一位政府官员，倘若他连坚持减肥都做不到，那么他很可能会怀疑自己是否可以抵抗住金钱和美女的诱惑。<br>　　“精神资源”是一个人极为重要的财富，一个内心中空无一物，认为自己什么都没有做成过的人，哪怕他头脑聪明，背景显赫，他在处理问题的时候都会带着一份难以摒去的优柔寡断。这样的人是不具备优秀领导力的，因为他不能领导自己，所以更难以去领导一群人。<br>　　一个人如果没有克服困难达成某个目的的经历，那么这个人的内心往往是不足够强大的。而减肥这件事，正好可以提供给人这个经历，并进一步给予人以一颗强大的心脏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;一鼓作气，再而衰，三而竭&lt;br&gt; &lt;b&gt;左丘明&lt;/b&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　这是我给女朋友写的小论文。纯属发泄情绪，胡诌乱道一通。&lt;/p&gt;
&lt;h3 id=&quot;减肥是一种理性行为&quot;&gt;&lt;a href=&quot;#减肥是一种理性行为&quot; class=&quot;headerlink&quot; title=&quot;减肥是一种理性行为&quot;&gt;&lt;/a&gt;减肥是一种理性行为&lt;/h3&gt;&lt;p&gt;　　减肥是一种理性的行为。尽可能的增重是人与生俱来的本能，在食物并不充足的时代，人会尽可能多的摄入食物。食物充足的时候，摄入的食物除了提供人日常劳作的能量，部分还会转化为脂肪，存储在人体中。而在人难以补充充足的能量时（例如生病后，不能很好的吸收食物），之前存储下的脂肪会成为宝贵的资源。因此，在过去的时代里，因为食物并不总是充足的，所以食欲旺盛的人更有活下去的可能性。旺盛的食欲在一番物竞天择后，留在了如今很多人的基因中。&lt;br&gt;　　当今绝大部分中国人并不缺少食物，尤其是青少年。因此，胃口太好在现代社会中，还会对人起到消极作用。缺乏节制地，不合理地饮食往往会让人肥胖。&lt;br&gt;
    
    </summary>
    
      <category term="胡诌" scheme="http://jasonzou.me/categories/%E8%83%A1%E8%AF%8C/"/>
    
    
      <category term="养生" scheme="http://jasonzou.me/tags/%E5%85%BB%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】我是怎么变牛逼的</title>
    <link href="http://jasonzou.me/2017/04/01/How-I-Became-a-Better-Programmer/"/>
    <id>http://jasonzou.me/2017/04/01/How-I-Became-a-Better-Programmer/</id>
    <published>2017-04-01T07:07:15.000Z</published>
    <updated>2017-04-04T08:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原文出处："><a href="#原文出处：" class="headerlink" title="原文出处："></a>原文出处：</h3><p><a href="http://jlongster.com/How-I-Became-Better-Programmer" target="_blank" rel="external">http://jlongster.com/How-I-Became-Better-Programmer</a>.</p>
<h3 id="译者的话"><a href="#译者的话" class="headerlink" title="译者的话"></a>译者的话</h3><p>　　我一直认为：“知道”和“懂得”之间是存在着巨大的差距的。从别人那里得到的指导和教训，永远和别人真正想教授的东西往往相差不少。广义上举例讲，作者的原话和我的翻译之间也会存在差异（这是当然也和本人的水平实在有限有关，毕竟，这篇翻译也只是自行记录为主，传播分享为辅）。<br><a id="more"></a></p>
<h3 id="如何成为更好的程序员"><a href="#如何成为更好的程序员" class="headerlink" title="如何成为更好的程序员"></a>如何成为更好的程序员</h3><p>有人在 React Conf 上向问我如何成为更好的程序员。由于某些原因，人们觉得我是个值得向其求取意见的牛逼程序员。（既然听众们诚心诚意的发问了）我觉得，写下我这些年来编程成长之路的技巧法门是有意义的。</p>
<p>关于我的一些小故事：<br>我32岁，之前有过超过十年的硬编经验。长久以来，我对自己所做的事并不那么自信。甚至直到今天，我也是在怀疑自己的。重要的事，既然（客观上）这种感觉挥之不去，那不如（在主观上去）忽略它，只管继续完善自己，不断积累经验。</p>
<p>且让我声明一下：这些只是提升你编程技能的一些小提示。最后你得亲自弄明白，哪些是对你最有益的。这些只是我认为有用的东西。</p>
<h4 id="寻找给你灵感的人，但不要盲目崇拜他们"><a href="#寻找给你灵感的人，但不要盲目崇拜他们" class="headerlink" title="寻找给你灵感的人，但不要盲目崇拜他们"></a>寻找给你灵感的人，但不要盲目崇拜他们</h4><p>这些年里，我关注了很多我尊敬的人，从他们那里学习新技术。我只是相信他们的方向是对的，并探索他们的正在研究的领域，并从中学到了很多。这些人往往才智过人，充满灵性并且成果颇多。找到这些人，让人他们启发你，指导你。</p>
<p>但是，一定不要过分崇拜他们。Twitter上的信息让他们看上去牛逼的可怕，不过，如果你看看他们在平日里是怎么工作的，你会发现他们并不是那么与众不同。同样是修补的各种错误之类的。我们都是在实验中摸索向前的。最后，不要盲目相信他们；如果你不赞同某些东西，就怼他们，然后从质疑中学习。我的一些成果就是在这样的交流中产生的。</p>
<p>我的 EMACS 设置一团糟。我不知道为啥我的 OCaml 自动补出问题了（它坏了一个多月了）。我没有做任务自动化，因此，有时候得在我的shell输入历史里慢慢找某些我需要用到的命令。我一开始的时候写的代码其丑无比。我把很多东西绑定在全局对象中，直到有一天我意识到我都干了些什么。最牛逼的程序员会使用各种技巧。但最重要的（不是这些牛逼的技巧，而是）你能把问题给解决了。</p>
<h4 id="切莫妄之菲薄"><a href="#切莫妄之菲薄" class="headerlink" title="切莫妄之菲薄"></a>切莫妄之菲薄</h4><p>新人程序员总倾向于认为他们干的事意义不大，因为它们不成熟。或者，你是个老司机，但是刚刚涉及一个让你不舒服的新领域。我认为，一些最棒的点子来自于那些观点尚未成型的新人程序员，因为他们能看到思维模式成型的老鸟们看不到的，某些成熟技术中的可提高之处。</p>
<p>不管是啥，你干的事都是有意义的。再不济，如果你的点子行不通，那么社区中的众人也能学到这种方法行不通。（给社区的提示：有没有用和欢不欢迎新人是由我们决定的）</p>
<h4 id="不要一直在焦虑中工作"><a href="#不要一直在焦虑中工作" class="headerlink" title="不要一直在焦虑中工作"></a>不要一直在焦虑中工作</h4><p>技术每天都在推陈出新，这会让你觉得，你摸一晚上的鱼，你就会被整个世界落下。这是不对的。事实上，你会干的更好，如果你从过度紧张中解脱出来。你的观点会被刷新，并且，我发现，不工作的时候，有些新点子会下意识的涌现出来。</p>
<p>每天都出现的那些的所谓的新技术，大体上都是把旧知识换了个包装而已。真正的革命性的技术革新，每几年才会发生一次。关于这个，可以去看看 Hammock Driven Development。</p>
<h4 id="少花心思在浅层次的知识上"><a href="#少花心思在浅层次的知识上" class="headerlink" title="少花心思在浅层次的知识上"></a>少花心思在浅层次的知识上</h4><p>少花心思在不重要的事上是提升自己的技术的不二法门。换言之，也就是理智的使用你的时间。你每天的时间是有限的，如果你把这些时间花在一些深层次的东西上你会感觉很不一样。</p>
<p>所以，什么是所谓的皮毛知识呢？这是因人而异的，但我可以给你举我自己的例子，我认为的皮毛知识有：语言的语法，API库，编程软件设置等。相较于学习编译器是怎么运行的，学习ES7的某个新语法对你的提升是很有限的。学习一个库的实现原理比死记硬背库的API有意思得多。当然，这些“皮毛知识”也是很重要的，但我还是推荐你花更多的时间在学习深层次的东西上，这会在之后的很多年里都给你回报。</p>
<p>这里我要提个问题：你是否花了很多的时间在怎样让你的代码看上去好看上？如果是这样的，我建议你别花太多时间在上面。你的代码是会有很大改变的，随着时间的推移。你不如花更多注意力在如何解决核心问题和思考一下你的抽象层级上。待你确定你已经解决好了这些之后，你可以花点儿时间打磨一下你的代码。（这样你的代码也是很DRY的，别对这种问题担心过度，对充满重复性的工作放松一些。）</p>
<h4 id="回顾前辈的研究"><a href="#回顾前辈的研究" class="headerlink" title="回顾前辈的研究"></a>回顾前辈的研究</h4><p>如果你对某个新点子激动不已，那你肯定很想坐下来就开始怼它。但你应该先粗略的研究一下前人是如何解决这个问题，然后才开始你的行动。花几天的时间研究一下前辈们的工作，总会让我彻底改变我对这个问题的原始解决方案。</p>
<p>学习如何读学术文章是有价值的。我对“指示”、“操作”等专业术语的东西一无所知，所以我有很多文章看不懂。但（文章中）同样有很多的使用代码而不是数学符号（的内容）并不是那么难懂。过去三十年间的文献中，蕴含着海量的知识。如果你善于做这些事情的话，你将是一个思想上的领袖。</p>
<p>Prettier就是个典型的例子。我知道我想要什么效果，但是我不知道怎么去事实它。在经过了一些调研后，我找到了一篇文章，然后过了几天，我就明白了我到底需要做些什么。我在每个工作日还得做一些基础工作。如果我忽略掉了提前调研的话，我就得话很多的时间去解决这个问题。</p>
<p>如果你在找文献的话，你可以 star 一下 the Papers We Love 这个github库。</p>
<h4 id="搞些大项目，挑战一下自己"><a href="#搞些大项目，挑战一下自己" class="headerlink" title="搞些大项目，挑战一下自己"></a>搞些大项目，挑战一下自己</h4><p>没有什么是比实战经验更宝贵的了。并不是每个人都有能做大项目的条件。但，如果你有时间的话，尝试着去做些大项目吧。你并非一定要完成这些项目。只要你尝试去解决一些事儿，就比如尝试去写个编译器，这会在你干这个事的最初的几周里教给你成吨的知识。</p>
<p>说实话，我很讨厌不知道怎么解决一个复杂问题的时候。这很不爽。我知道我得花很多功夫，做很多研究，学习很多，在我只是单纯的接近解决方案之前。但我总会在挑战了这些困难之后变成一个更牛逼的程序员。</p>
<p>开始学习一门新语言。这是最好的让你从旧语言的使用习惯中解脱出来，开发新思路的办法。对我而言，我作为一个年轻的程序员做过的最好的是事是学习 Scheme。这是一门很简单的语言，它会迫使你用函数式编程思想做所有事情，并且让你真正学习到代码运行的基本原理。我花在 Scheme 上的几年功夫，直到今天也一直对我有很大的帮助；我看代码的方式从根本上改变了。（我甚至给我的公司取名叫 Shift Reset LLC ，这是向 Scheme 中的 shift/reset 操作符致敬。）</p>
<p>这里，我列一些我推荐去做的事。这些事都对我的程序员生涯产生了巨大的影响。其中的大部分工作，至今都在以微妙的方式产生着回报，并且会从思想上帮我煮结构一些新点子。你无须完全照做，有别的事也能帮助你成为更好的程序员，这些只是帮助我成长的事。</p>
<ul>
<li>学习C语言：学习基础的东西，如果你还没学过C语言的话。我认为，弄清楚为什么每个人都抱怨它是很值得的事。</li>
<li>写个编译器：这也许是最好的挑战自己的方式了，查一查一个<a href="https://github.com/thejameskyle/the-super-tiny-compiler" target="_blank" rel="external">超级小型的编译器</a>是怎么实现的。</li>
<li>学习 macros ：看看 Scheme，Lisp 或是 Clojure 。Macros 会非常显著的改变你看代码的方式。</li>
<li>看SICP：<a href="https://mitpress.mit.edu/sicp/full-text/book/book.html" target="_blank" rel="external">SICP</a> 是一本我认为今天依然有意义的老书（有些人不赞同）。它只讲了比较少的编程知识，并且会一直引导你到实现元循环评估器和编译器。另一本让我受益匪浅并让在编译器学习之路精进不少的书是 <a href="https://www.amazon.com/Lisp-Small-Pieces-Christian-Queinnec/dp/0521545668" target="_blank" rel="external">Lisp In Small Pieces</a> 。</li>
<li>理解 continuations ：<a href="https://en.wikipedia.org/wiki/Continuation" target="_blank" rel="external">Continuations</a> 是一种低等级的控制流机制。Scheme 是唯一一们继承了这些机制的语言，尽管你永远不会在你的生产中使用这门语言，但这些只是会改变你对控制流的思考。我写了篇<a href="http://jlongster.com/Whats-in-a-Continuation" target="_blank" rel="external">博客</a>解释这个。</li>
<li>如果说还有什么建议的话，那就是尝试一门新语言了：不管你是做什么的，你都很应该去探索一下别的语言。我的推荐依次是：Clojure，Rust，Elm，OCaml/Reason，Go，或者 Scheme。这其中的每一门语言都有它独特的地方，会迫使你学习一种新的思考问题的方式。</li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>



]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原文出处：&quot;&gt;&lt;a href=&quot;#原文出处：&quot; class=&quot;headerlink&quot; title=&quot;原文出处：&quot;&gt;&lt;/a&gt;原文出处：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://jlongster.com/How-I-Became-Better-Programmer&quot;&gt;http://jlongster.com/How-I-Became-Better-Programmer&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;译者的话&quot;&gt;&lt;a href=&quot;#译者的话&quot; class=&quot;headerlink&quot; title=&quot;译者的话&quot;&gt;&lt;/a&gt;译者的话&lt;/h3&gt;&lt;p&gt;　　我一直认为：“知道”和“懂得”之间是存在着巨大的差距的。从别人那里得到的指导和教训，永远和别人真正想教授的东西往往相差不少。广义上举例讲，作者的原话和我的翻译之间也会存在差异（这是当然也和本人的水平实在有限有关，毕竟，这篇翻译也只是自行记录为主，传播分享为辅）。&lt;br&gt;
    
    </summary>
    
      <category term="最无用的东西" scheme="http://jasonzou.me/categories/%E6%9C%80%E6%97%A0%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>map、filter和reduce</title>
    <link href="http://jasonzou.me/2017/03/31/map%E3%80%81filter%E5%92%8Creduce/"/>
    <id>http://jasonzou.me/2017/03/31/map、filter和reduce/</id>
    <published>2017-03-31T08:48:10.000Z</published>
    <updated>2017-04-04T08:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　map( ) 、 filter( ) 和 reduce( ) 是一系列很符合函数式编程思想的数组操作方法。我认为学习他们很重要，本文没有什么自己的见解，仅仅是作为学习<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">MDN</a>资料的摘录。<br><a id="more"></a></p>
<h3 id="map"><a href="#map" class="headerlink" title="map( )"></a>map( )</h3><p>　　map( ) 是根据旧数组<strong>产生新数组</strong>的方法，并不修改原数组。 </p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line"><span class="keyword">let</span> roots = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// roots is now [2, 10, 20, 30]</span></div><div class="line"><span class="comment">// numbers is still [1, 5, 10, 15]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>];</div><div class="line"><span class="comment">//es6: let roots = numbers.map(Math.sqrt);</span></div><div class="line"><span class="keyword">let</span> roots = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(x);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// roots is now [1, 2, 3]</span></div><div class="line"><span class="comment">// numbers is still [1, 4, 9]</span></div></pre></td></tr></table></figure>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> new_array = arr.map(callback[, thisArg])</div></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>callback<br>生成新数组元素的函数，使用三个参数：<ul>
<li>currentValue<br>callback 的第一个参数，数组中正在处理的当前元素。</li>
<li>index<br>callback 的第二个参数，数组中正在处理的当前元素的索引。</li>
<li>array<br>callback 的第三个参数，map 方法被调用的数组。</li>
</ul>
</li>
<li>thisArg<br>可选的。执行 callback 函数时 使用的this 值。</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>  一个新数组，每个元素都是回调函数的结果。</p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>　　map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。<br>　　callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。<br>　　如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象 。<br>　　map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。<br>　　使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter( )"></a>filter( )</h3><p>　　filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> value &gt;= <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].filter(isBigEnough);</div><div class="line"><span class="comment">// filtered is [12, 130, 44]</span></div></pre></td></tr></table></figure>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> new_array = arr.filter(callback[, thisArg])</div></pre></td></tr></table></figure>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul>
<li>callback<br>用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。<br>返回true表示保留该元素（通过测试），false则不保留。</li>
<li>thisArg<br>可选。执行 callback 时的用于 this 的值。</li>
</ul>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>　　一个新的通过测试的元素的集合的数组</p>
<h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>　　filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。<br>　　callback 被调用时传入三个参数：</p>
<ul>
<li>元素的值</li>
<li>元素的索引</li>
<li>被遍历的数组</li>
</ul>
<p>　　如果为 filter 提供一个 thisArg 参数，则它会被作为 callback 被调用时的 this 值。否则，callback 的 this 值在非严格模式下将是全局对象，严格模式下为 undefined。<br>　　The thisvalue ultimately observable by callback is determined according to the usual rules for determining thethis seen by a function.<br>　　filter 不会改变原数组。<br>　　filter 遍历的元素范围在第一次调用 callback 之前就已经确定了。在调用 filter 之后被添加到数组中的元素不会被 filter 遍历到。如果已经存在的元素被改变了，则他们传入 callback 的值是 filter 遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce( )"></a>reduce( )</h3><p>　　reduce() 方法对累加器和数组的每个值 (从左到右)应用一个函数，以将其减少为单个值。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sum = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">acc, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> acc + val;</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sum);</div><div class="line"><span class="comment">// 6</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> list1 = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]];</div><div class="line"></div><div class="line"><span class="keyword">let</span> list2 = [<span class="number">0</span>, [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>]]]]]]];</div><div class="line"></div><div class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> arr.reduce(</div><div class="line">        <span class="function">(<span class="params">acc, val</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> acc.concat(<span class="built_in">Array</span>.isArray(val) ? flatten(val) : val)</div><div class="line">        &#125;, []</div><div class="line">    );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">flatten(list1); </div><div class="line"><span class="comment">// [0, 1, 2, 3, 4, 5]</span></div><div class="line"></div><div class="line">flatten(list2); </div><div class="line"><span class="comment">// [ 0, 1, 2, 3, 4, 5, 6 ]</span></div></pre></td></tr></table></figure>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.reduce(callback,[initialValue])</div></pre></td></tr></table></figure>
<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul>
<li>callback<br>执行数组中每个值的函数，包含四个参数<ul>
<li>accumulator<br>上一次调用回调返回的值，或者是提供的初始值（initialValue）</li>
<li>currentValue<br>数组中正在处理的元素</li>
<li>currentIndex<br>数据中正在处理的元素索引，如果提供了 initialValue ，从0开始；否则从1开始</li>
<li>array<br>调用 reduce 的数组</li>
</ul>
</li>
<li>initialValue<br>可选项，其值用于第一次调用 callback 的第一个参数。</li>
</ul>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>　　函数累计处理的结果</p>
<h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>　　reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值 accumulator （或者上一次回调函数的返回值），当前元素值 currentValue ，当前索引 currentIndex ，调用 reduce 的数组。<br>　　回调函数第一次执行时，accumulator 和 currentValue 的取值有两种情况：调用 reduce 时提供initialValue，accumulator 取值为 initialValue ，currentValue 取数组中的第一个值；没有提供 initialValue ，accumulator 取数组中的第一个值，currentValue 取数组中的第二个值。<br>　　注意: 不提供 initialValue ，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。提供 initialValue ，从索引0开始。<br>　　如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。<br>　　提供 initialValue 通常更安全，正如下面的例子，没有 initialValue 有三种可能输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> maxCallback = <span class="function">(<span class="params"> pre, cur </span>) =&gt;</span> <span class="built_in">Math</span>.max( pre.x, cur.x );</div><div class="line"><span class="keyword">var</span> maxCallback2 = <span class="function">(<span class="params"> max, cur </span>) =&gt;</span> <span class="built_in">Math</span>.max( max, cur );</div><div class="line"></div><div class="line"><span class="comment">// reduce() without initialValue</span></div><div class="line">[ &#123; <span class="attr">x</span>: <span class="number">22</span> &#125;, &#123; <span class="attr">x</span>: <span class="number">42</span> &#125; ].reduce( maxCallback ); <span class="comment">// 42</span></div><div class="line">[ &#123; <span class="attr">x</span>: <span class="number">22</span> &#125;            ].reduce( maxCallback ); <span class="comment">// &#123; x: 22 &#125;</span></div><div class="line">[                      ].reduce( maxCallback ); <span class="comment">// TypeError</span></div><div class="line"></div><div class="line"><span class="comment">// map/reduce; better solution, also works for empty arrays</span></div><div class="line">[ &#123; <span class="attr">x</span>: <span class="number">22</span> &#125;, &#123; <span class="attr">x</span>: <span class="number">42</span> &#125; ].map( <span class="function"><span class="params">el</span> =&gt;</span> el.x )</div><div class="line">                        .reduce( maxCallback2, -<span class="literal">Infinity</span> );</div></pre></td></tr></table></figure></p>
<p style="text-align: center;"><b>… End …</b></p>





]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　map( ) 、 filter( ) 和 reduce( ) 是一系列很符合函数式编程思想的数组操作方法。我认为学习他们很重要，本文没有什么自己的见解，仅仅是作为学习&lt;a href=&quot;https://developer.mozilla.org/zh-CN/&quot;&gt;MDN&lt;/a&gt;资料的摘录。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript知识总结" scheme="http://jasonzou.me/categories/JavaScript%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://jasonzou.me/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://jasonzou.me/tags/ES6/"/>
    
      <category term="函数式编程" scheme="http://jasonzou.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>localhost到底是什么</title>
    <link href="http://jasonzou.me/2017/03/31/localhost%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://jasonzou.me/2017/03/31/localhost到底是什么/</id>
    <published>2017-03-31T06:01:13.000Z</published>
    <updated>2017-04-04T08:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>起因：<br>　　最近在为在维护一个项目。在以本机为服务器做移动端测试时，出现了页面资源载入失败的情况：playback-mobile.js（如下）文件并没有被成功加载。这个错误仅出现在了魅族系列手机上的native浏览器和QQ移动浏览器（也许还有别的非主流浏览器也不支持）中。和前辈交流后认为：有可能是这个src中的localhost应该替换为服务器地址。修改后发现，问题的确是出在这里的。<br>　　无独有偶，在 MacOS Safari 上进行开发测试时，发现了一个更为怪异的现象：当我使用 localhost 作为域名时，我访问某个配置了全域可访问头的资源（并且只有这个资源出现了问题）时，居然提示跨域错误。查看后发现，请求完全没有发出，是浏览器直接就把请求block了。把 localhost 换成本机IP后又一切正常了。<br>　　事后探究了一下原因，并在此做一个总结：<br><a id="more"></a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 原来的引入路径</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://localhost:9094/playback-mobile.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">// 修改后的引入路径</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://192.168.2.196:9094/playback-mobile.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="localhost、127-0-0-1-和-本机IP-三者的区别"><a href="#localhost、127-0-0-1-和-本机IP-三者的区别" class="headerlink" title="localhost、127.0.0.1 和 本机IP 三者的区别"></a>localhost、127.0.0.1 和 本机IP 三者的区别</h3><p>参考：<a href="https://www.zhihu.com/question/23940717/answer/26230963" target="_blank" rel="external">知乎</a></p>
<h4 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h4><p>　　localhost 是一个域名，在过去它指向 127.0.0.1 这个IP地址。在操作系统支持 ipv6 后，它同时还指向ipv6 的地址 [::1]。在 Windows 中，这个域名是预定义的，从 hosts 文件中可以看出：</p>
<pre><code>　　#localhost name resolution is handled within DNS itself.#    
　　127.0.0.1       localhost#    
　　::1             localhost
</code></pre><p>　　而在 Linux 中，其定义位于 /etc/hosts 中：</p>
<pre><code>　　127.0.0.1    localhost
</code></pre><p>　　注意这个值是可修改的，比如我把它改成 </p>
<pre><code>　　192.068.206.1    localhost
</code></pre><p>　　然后再去 ping localhost，提示就变成了PING localhost (192.168.206.1) 56(84) bytes of data.当然一般人不会像我这么蛋疼。</p>
<h4 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h4><p>　　127.0.0.1 这个地址通常分配给 loopback 接口。loopback 是一个特殊的网络接口(可理解成虚拟网卡)，用于本机中各个应用之间的网络交互。只要操作系统的网络组件是正常的，loopback 就能工作。Windows 中看不到这个接口，Linux中这个接口叫： </p>
<pre><code>　　lo：#ifconfigeth0    Link encap:Ethernet hwaddr 00:00:00:00:00:00            
　　inet addr :192.168.0.1 Bcase:192.168.0.255 Mask:255.255.255.0           
　　......lo        
　　Link encap:Local Loopback           
　　inetaddr: 127.0.0.1 Mask: 255.0.0.0           
　　......
</code></pre><p>　　可以看出 lo 接口的地址是 127.0.0.1。事实上整个 127.* 网段都算能够使用，比如你 ping 127.0.0.2 也是通的。但是使用127.0.0.1作为loopback接口的默认地址只是一个惯例，比如下面这样：</p>
<pre><code>　　#ifconfig lo 192.168.128.1#ping localhost   #
</code></pre><p>　　糟糕，ping不通了，试试ping 192.128.128.1：</p>
<pre><code>　　#ping 192.128.128.1  # 
</code></pre><p>　　可以通：</p>
<pre><code>　　#ifconfig lolo        Link encap:Local Loopback           
　　inetaddr: 192.168.128.1 Mask: 255.255.255.0          
　　......
</code></pre><p>　　当然，一般人更不会像我这样蛋疼。如果随便改这些配置，可能导致很多只认 127.0.0.1 的软件挂掉。</p>
<h4 id="本机IP（本机地址）"><a href="#本机IP（本机地址）" class="headerlink" title="本机IP（本机地址）"></a>本机IP（本机地址）</h4><p>　　确切地说，“本机地址”并不是一个规范的名词。通常情况下，指的是“本机物理网卡所绑定的网络协议地址”。由于目前常用网络协议只剩下了IPV4，IPX/Apple Tak消失了，IPV6还没普及，所以通常仅指IP地址甚至ipv4地址。一般情况下，并不会把 127.0.0.1 当作本机地址。原因没必要特别说明，大家都知道。本机地址是与具体的网络接口绑定的。比如以太网卡、无线网卡或者PPP/PPPoE拨号网络的虚拟网卡，想要正常工作都要绑定一个地址，否则其他设备就不知道如何访问它。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　localhost 是个域名，不是地址，它可以被配置为任意的 IP 地址，不过通常情况下都指向 127.0.0.1(ipv4)和 <a href="ipv6">::1</a>整个127.<em> 网段通常被用作 loopback 网络接口的默认地址，按惯例通常设置为 127.0.0.1。这个地址在其他计算机上不能访问，就算你想访问，访问的也是自己，因为每台带有TCP/IP协议栈的设备基本上都有 localhost/127.0.0.1。本机地址通常指的是绑定在物理或虚拟网络接口上的IP地址，可供其他设备访问到。最后，从开发度来看localhost是个域名，性质跟 “www.baidu.com” 差不多。不能直接绑定套接字，必须先gethostbyname转成IP才能绑定。127.0.0.1 是绑定在 loopback 接口上的地址，如果服务端套接字绑定在它上面，你的客户端程序就只能在本机访问。如果主机中存在多个网卡，分别连接不同的物理网络，比如 192.168.0.1/255.255.255.0 和 192.168.1.1/255.255.255.0，那么当你的服务端套接字绑到 192.168.0.1 这个地址上时，位于 192.168.1.</em> 网段的其他计算机是无法连接的，只有位于192.168.0.* 网段的计算机才能访问你的服务端程序。<br>　　之前举了一个修改 loopback 接口后无法ping通localhost的例子，我认为，这和我本次遇到的第一个问题的原理相同。魅族手机的native浏览器中可能存在对 loopback 接口的修改，并最终导致了本次错误。<br>　　对于第二个错误，我并不是很能确定是否也是相同的原因，我认为，更有可能是 Safari 浏览器的某些内部设置问题。如果确认了问题所在我会再更新本次总结。</p>
<p style="text-align: center;"><b>… End …</b></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起因：&lt;br&gt;　　最近在为在维护一个项目。在以本机为服务器做移动端测试时，出现了页面资源载入失败的情况：playback-mobile.js（如下）文件并没有被成功加载。这个错误仅出现在了魅族系列手机上的native浏览器和QQ移动浏览器（也许还有别的非主流浏览器也不支持）中。和前辈交流后认为：有可能是这个src中的localhost应该替换为服务器地址。修改后发现，问题的确是出在这里的。&lt;br&gt;　　无独有偶，在 MacOS Safari 上进行开发测试时，发现了一个更为怪异的现象：当我使用 localhost 作为域名时，我访问某个配置了全域可访问头的资源（并且只有这个资源出现了问题）时，居然提示跨域错误。查看后发现，请求完全没有发出，是浏览器直接就把请求block了。把 localhost 换成本机IP后又一切正常了。&lt;br&gt;　　事后探究了一下原因，并在此做一个总结：&lt;br&gt;
    
    </summary>
    
      <category term="计算机基础知识杂烩" scheme="http://jasonzou.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="计算机网络" scheme="http://jasonzou.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【转载】MVC, MVP, MVVM的区别和联系</title>
    <link href="http://jasonzou.me/2017/03/30/MVVM%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://jasonzou.me/2017/03/30/MVVM的联系和区别/</id>
    <published>2017-03-30T14:06:36.000Z</published>
    <updated>2017-04-04T08:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下转自：</strong><a href="http://codingjoker.github.io/" target="_blank" rel="external">JumoZhu的博客</a></p>
<a id="more"></a>
<h3 id="先说一下三者的共同点"><a href="#先说一下三者的共同点" class="headerlink" title="先说一下三者的共同点"></a>先说一下三者的共同点</h3><p>Model和ViewModel就是数据模型，同时，提供外部对应用程序数据的操作的接口，也可能在数据变化时发出变更通知。Model不依赖于View的实现，只要外部程序调用Model的接口就能够实现对数据的增删改查。<br>View就是UI层，提供对最终用户的交互操作功能，包括UI展现代码及一些相关的界面逻辑代码。</p>
<p>三者的差异在于如何粘合View和Model，实现用户的交互操作以及变更通知。</p>
<h3 id="MVC和MVP的关系"><a href="#MVC和MVP的关系" class="headerlink" title="MVC和MVP的关系"></a>MVC和MVP的关系</h3><p>MVC 进化为 MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架：<br>我们都知道MVP是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过 Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会以观察者的身份监听Model的变化，直接从Model中读取数据而不是通过 Controller。</p>
<h3 id="MVVM和MVP的关系"><a href="#MVVM和MVP的关系" class="headerlink" title="MVVM和MVP的关系"></a>MVVM和MVP的关系</h3><p>而 MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：（View的Model就是包含View的一些数据属性和操作的这么一个东东）这种模式的关键技术就是数据绑定（data binding），View的变化会直接影响ViewModel，ViewModel的变化或者内容也会直接体现在View上。这种模式实际上是框架替应用开发者做了一些工作，开发者只需要较少的代码就能实现比较复杂的交互。</p>
<h4 id="MVVM的优点"><a href="#MVVM的优点" class="headerlink" title="MVVM的优点"></a>MVVM的优点</h4><ul>
<li>低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响；</li>
<li>可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用；</li>
<li>独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModel），界面设计人员可以专注于UI(View)的设计；</li>
<li>可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单。</li>
</ul>
<h4 id="在angular中MVVM模式主要分为四部分"><a href="#在angular中MVVM模式主要分为四部分" class="headerlink" title="在angular中MVVM模式主要分为四部分"></a>在angular中MVVM模式主要分为四部分</h4><ul>
<li>View：它专注于界面的显示和渲染，在angular中则是包含一堆声明式Directive的视图模板。</li>
<li>ViewModel：它是View和Model的粘合体，负责View和Model的交互和协作，它负责给View提供显示的数据，以及提供了View中Command事件操作Model的途径；在angular中$scope对象充当了这个ViewModel的角色；</li>
<li>Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在web页面中，大部分Model都是来自Ajax的服务端返回数据或者是全局的配置对象；而angular中的service则是封装和处理这些与Model相关的业务逻辑的场所，这类的业务服务是可以被多个Controller或者其他service复用的领域服务。</li>
<li>Controller：这并不是MVVM模式的核心元素，但它负责ViewModel对象的初始化，它将组合一个或者多个service来获取业务领域Model放在ViewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态</li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;以下转自：&lt;/strong&gt;&lt;a href=&quot;http://codingjoker.github.io/&quot;&gt;JumoZhu的博客&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言知识杂烩" scheme="http://jasonzou.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="面向对象" scheme="http://jasonzou.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>【转载】《浅析nodeJS的几种文件路径》</title>
    <link href="http://jasonzou.me/2017/03/27/%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E3%80%8B/"/>
    <id>http://jasonzou.me/2017/03/27/的几种文件路径》/</id>
    <published>2017-03-27T11:10:40.000Z</published>
    <updated>2017-04-04T08:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天在使用webpack打包JS时报错，发现path不能是相对路径，发现自己对路径的理解一直都是似是而非的，在我的一位<a href="http://zerosrat.com" target="_blank" rel="external">良师益友</a>的指导帮助后学习了一下路径的相关知识。<br>　　在此转载一篇相关博客，以作记录：</p>
<p><strong>以下转自：</strong><a href="https://github.com/imsobear/blog/issues/48" target="_blank" rel="external">imsobear的博客</a></p>
<h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>　　Node 中的文件路径大概有 <strong>__dirname</strong>， <strong>__filename</strong> ， <strong>process.cwd()</strong> ， <strong>./</strong> 或者 <strong>../</strong>，前三个都是绝对路径，为了便于比较，<strong>./</strong> 和 <strong>../</strong> 我们通过 <strong>path.resolve(‘./‘)</strong> 来转换为绝对路径。</p>
<a id="more"></a>
<p>先看一个简单的例子：</p>
<p>假如我们有这样的文件结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app/</div><div class="line">  -lib/</div><div class="line">    -common.js</div><div class="line">  -model</div><div class="line">    -task.js</div><div class="line">    -test.js</div></pre></td></tr></table></figure></p>
<p>在 task.js 里编写如下的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(__dirname);</div><div class="line"><span class="built_in">console</span>.log(__filename);</div><div class="line"><span class="built_in">console</span>.log(process.cwd());</div><div class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">'./'</span>));</div></pre></td></tr></table></figure></p>
<p>在 model 目录下运行 $ node task.js 得到的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/Users/guo/Sites/learn/app/model.js</div><div class="line">/Users/guo/Sites/learn/app/model.js/task.js</div><div class="line">/Users/guo/Sites/learn/app/model.js</div><div class="line">/Users/guo/Sites/learn/app/model.js</div></pre></td></tr></table></figure></p>
<p>然后在 app 目录下运行 node model/task.js，得到的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/Users/guo/Sites/learn/app/model.js</div><div class="line">/Users/guo/Sites/learn/app/model.js/task.js</div><div class="line">/Users/guo/Sites/learn/app</div><div class="line">/Users/guo/Sites/learn/app</div></pre></td></tr></table></figure></p>
<p>那么，不好意思不是问题来了~T_T,我们可以得出一些肤浅的结论了：</p>
<ul>
<li>__dirname: 总是返回被执行的 js 所在文件夹的绝对路径</li>
<li>__filename: 总是返回被执行的 js 的绝对路径</li>
<li>process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径</li>
<li>./: 跟 process.cwd() 一样、一样、一样的吗？</li>
</ul>
<p>还是上面的结构，’model/task.js’ 里的代码改成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> common = <span class="built_in">require</span>(<span class="string">'../lib/common'</span>);</div><div class="line"></div><div class="line">fs.readFile(<span class="string">'../lib/common.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在 model 目录下运行 node task.js，一切 Ok，没有报错。然后在 app 目录下运行 node model/task.js，然后很果断滴报错了。</p>
<p>那么这下问题真的都是来了，按照上面的理论，在 app 下运行时，../lib/common.js 会被转成 /Users/guo/Sites/learn/lib/common.js，这个路径显然是不存在的，但是从运行结果可以看出 require(‘../lib/common’) 是 OK 的，只是 readFile 时报错了。</p>
<p>那么关于 ./ 正确的结论是：</p>
<p>在 require() 中使用是跟 __dirname 的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟 process.cwd() 效果相同，是相对于启动脚本所在目录的路径。</p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>只有在 require() 时才使用相对路径(./, ../) 的写法，其他地方一律使用绝对路径，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 当前目录下</div><div class="line">path.dirname(__filename) + &apos;/test.js&apos;;</div><div class="line">// 相邻目录下</div><div class="line">path.resolve(__dirname, &apos;../lib/common.js&apos;);</div></pre></td></tr></table></figure></p>
<ul>
<li><a href="http://stackoverflow.com/questions/8131344/what-is-the-difference-between-dirname-and-in-node-js" target="_blank" rel="external">参考1</a></li>
<li><a href="https://nodejs.org/api/" target="_blank" rel="external">参考2</a></li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　今天在使用webpack打包JS时报错，发现path不能是相对路径，发现自己对路径的理解一直都是似是而非的，在我的一位&lt;a href=&quot;http://zerosrat.com&quot;&gt;良师益友&lt;/a&gt;的指导帮助后学习了一下路径的相关知识。&lt;br&gt;　　在此转载一篇相关博客，以作记录：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下转自：&lt;/strong&gt;&lt;a href=&quot;https://github.com/imsobear/blog/issues/48&quot;&gt;imsobear的博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h2&gt;&lt;p&gt;　　Node 中的文件路径大概有 &lt;strong&gt;__dirname&lt;/strong&gt;， &lt;strong&gt;__filename&lt;/strong&gt; ， &lt;strong&gt;process.cwd()&lt;/strong&gt; ， &lt;strong&gt;./&lt;/strong&gt; 或者 &lt;strong&gt;../&lt;/strong&gt;，前三个都是绝对路径，为了便于比较，&lt;strong&gt;./&lt;/strong&gt; 和 &lt;strong&gt;../&lt;/strong&gt; 我们通过 &lt;strong&gt;path.resolve(‘./‘)&lt;/strong&gt; 来转换为绝对路径。&lt;/p&gt;
    
    </summary>
    
      <category term="nodeJS知识总结" scheme="http://jasonzou.me/categories/nodeJS%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://jasonzou.me/tags/JavaScript/"/>
    
      <category term="nodeJS" scheme="http://jasonzou.me/tags/nodeJS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript如何“面向对象”</title>
    <link href="http://jasonzou.me/2017/03/25/JavaScript%E5%A6%82%E4%BD%95%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://jasonzou.me/2017/03/25/JavaScript如何面向对象/</id>
    <published>2017-03-25T04:19:36.000Z</published>
    <updated>2017-03-26T14:09:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>不同的矛盾，只有用不同的方法才能解决。 <br> <strong>毛泽东</strong> </p>
</blockquote>
<p>　　JavaScript并不是一门严格的面向对象语言，因为JavaScript没有类。ES6给习惯了使用类的程序员们一个类的语法糖，但相较于别的面向对象语言，ES6的这个类也是很不成熟的类（将在本文后续讲详细说明）。虽然没有一个严格定义的类，但这并不影响面向对象的设计思想在JavaScript编程中发光发热。<br><a id="more"></a></p>
<h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><blockquote>
<p>百度百科：<br>　　面向对象是指一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的集合。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。狭义的“面向对象”是指在程序设计中采用封装、继承、多态等设计方法。</p>
</blockquote>
<p>　　面向对象的编程方法具有四个基本特性：</p>
<ul>
<li><p>抽象<br>我是一个前端，从日常实战中的角度出发，我认为“抽象”主要是针对两方面： </p>
<ul>
<li><p>抽象数据模型<br>如这篇博客，我要从数据层面去抽象出它的模型。得出的结果应该是类似于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="attr">title</span>: <span class="string">'JavaScript和面向对象'</span>,</div><div class="line">	<span class="attr">date</span>: <span class="string">'2017-03-25 12:19:36'</span>,</div><div class="line">	<span class="attr">categories</span>: <span class="string">'JavaScript知识总结'</span>,</div><div class="line">	<span class="attr">tags</span>: &#123;</div><div class="line">		<span class="attr">tag1</span>: <span class="string">'JavaScript'</span>,</div><div class="line">		<span class="attr">tag2</span>: <span class="string">'面向对象'</span></div><div class="line">	&#125;，</div><div class="line">	<span class="comment">//... 等等</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>抽象具体操作<br>如果将这篇博客抽象为一个对象，那么它对外并没有太多接口，只有一个提供给UI层的“读”接口。那么，“读”这个操作，就可以作为博客对象的方法被抽象出来。形如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">blog</span> </span>&#123;</div><div class="line">	<span class="comment">//提示：以下代码需经babel翻译后才能在常规生产环境中运行。</span></div><div class="line">	_data;</div><div class="line">	readData() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>._data;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>继承<br>“继承”思想是面向对象编程的重要一环，前端开发中并不缺少能用到继承的场景，如页面中常出现的列表对象：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">类</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">特征</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">父类</td>
<td style="text-align:left">普通列表</td>
<td style="text-align:left">列表</td>
</tr>
<tr>
<td style="text-align:left">子类</td>
<td style="text-align:left">可增删列表</td>
<td style="text-align:left">列表 + “增”、“删”方法</td>
</tr>
<tr>
<td style="text-align:left">“孙”类</td>
<td style="text-align:left">可增删重排序列表</td>
<td style="text-align:left">列表 + “增”、“删”方法 + 重排序方法</td>
</tr>
</tbody>
</table>
<p>　　如是就是前端开发中一个很普通的继承运用了。JavaScript没有严格定义的类，<br>　　因此JavaScript的继承相较于别的语言稍显特殊。详情将在本文后续介绍。</p>
<ul>
<li><p>封装<br>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。封装这一行为是面向对象编程的安全性保障。值得一提的是：JavaScript并没有私有变量。在ES6编程中通常约定：以下划线开头的变量（如 _data ）为私有变量。本文对封装不做详细介绍说明。</p>
</li>
<li><p>多态</p>
<blockquote>
<p>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。  </p>
</blockquote>
<p>实现多态，常见的方式无非是覆盖或重载。<br>JavaScript中，后创建的同名函数会覆盖先创建的同名函数。因此，直接在子类中重写需要实现多态的方法，覆盖从父类继承来的方法即可实现多态。<br>JavaScript的重载是颇为有趣的。JavaScript并不是理想的用于重载的语言，因为JavaScript函数对参数长度是没有限制的，因此，常规语言的重载思路并不对JavaScript适用。但，我们可以通过在函数内部判断参数类型和参数length来模拟重载。我认为，这样的灵活性是JavaScript这门语言的魅力所在。</p>
</li>
</ul>
<h3 id="为什么要面向对象"><a href="#为什么要面向对象" class="headerlink" title="为什么要面向对象"></a>为什么要面向对象</h3><p>为什么要面向对象？这是一个值得每一个前端工程师考虑的问题。JavaScript这门语言（尤其是ES6之后）也是适合使用函数式编程的。在此给出一些链接供读者参考：</p>
<ul>
<li><a href="http://taobaofed.org/blog/2017/03/16/javascript-functional-programing/" target="_blank" rel="external">我眼中的 JavaScript 函数式编程</a></li>
<li><a href="https://www.zhihu.com/question/20275578" target="_blank" rel="external">面向对象编程的弊端是什么？</a></li>
<li><a href="http://www.vaikan.com/whats-wrong-with-oop-and-fp/" target="_blank" rel="external">为什么说面向对象编程和函数式编程都有问题</a></li>
</ul>
<h3 id="ES5中的面向对象"><a href="#ES5中的面向对象" class="headerlink" title="ES5中的面向对象"></a>ES5中的面向对象</h3><p>JavaScript如何“面向对象”？这是一个非常基础的问题，我认为这是每一个前端工程师都应该花心思花时间去掌握的东西。</p>
<ul>
<li><p>首先，你要有个对象（创建对象的几种常用方法）： </p>
<ul>
<li><p>原始模式： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">'Jason'</span>,</div><div class="line">	<span class="attr">age</span>: <span class="number">21</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> Person = &#123;&#125;;</div><div class="line">Person.name = <span class="string">'Jason'</span>；</div><div class="line">Person.age = <span class="number">21</span></div></pre></td></tr></table></figure>
</li>
<li><p>原始模式的改进： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用一个函数来构造对象，解决代码重复的问题</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">name</span>: name,</div><div class="line">		<span class="attr">age</span>: age</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> personJ = Person(<span class="string">'Jason'</span>, <span class="number">21</span>);</div><div class="line"><span class="keyword">var</span> personX = Person(<span class="string">'Xku'</span>, <span class="number">18</span>);</div><div class="line"><span class="comment">// 这个模式存在的问题是，personJ和personX两个实例没有内在的联系，并不能看出他们是出于同一个原型的</span></div></pre></td></tr></table></figure>
</li>
<li><p>构造函数模式： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在函数内部使用this是构造函数的关键</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用new实例化对象</span></div><div class="line"><span class="keyword">var</span> personJ = <span class="keyword">new</span> Person(<span class="string">'Jason'</span>, <span class="number">21</span>);</div><div class="line"><span class="keyword">var</span> personX = <span class="keyword">new</span> Perspm(<span class="string">'Xku'</span>, <span class="number">18</span>);</div><div class="line"><span class="comment">// 此时personJ和personX会自动生成一个constructor属性，指向他们的构造函数</span></div><div class="line">personJ.constructor == Person <span class="comment">// true</span></div><div class="line">personX <span class="keyword">instanceof</span> Person <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
<li><p>Prototype模式： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数中可能会存在一些不变的属性</span></div><div class="line"><span class="comment">// 没有必要在每一次实例化对象的时候都将其加入新建对象之中</span></div><div class="line"><span class="comment">// 此时，我们可以采用Prototype + 构造函数模式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">Person.prototype.type = <span class="string">"哺乳动物"</span>；</div><div class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>构造函数的继承：<br>前文中已经讲到过了，JavaScript中，面向对象主要体现在对对象的封装和继承上，JavaScript常规上讲没有重载，多态的实现主要依赖覆盖，我学艺不精，在这方面暂时没有找到什么好讲的。因此，本文将重点介绍如何在使用JavaScript语言进行编程时实现封装和继承。前面已经介绍了封装。现在开始介绍继承：<br>场景：这里有个Animal类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和一个Person类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在要使Person类继承Animal类</p>
<ul>
<li><p>构造函数绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  使用call或apply方法，将父对象的构造函数绑定在子函数上</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> personJ = <span class="keyword">new</span> Person(<span class="string">'Jason'</span>, <span class="number">21</span>);</div><div class="line">conslo.log(personJ.species); <span class="comment">// 动物</span></div></pre></td></tr></table></figure>
</li>
<li><p>prototype模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将Person的prototype替换为Animal的prototype，</span></div><div class="line">Person.prototype = <span class="keyword">new</span> Animal();</div><div class="line"><span class="comment">// 注意：Person的prototype被替换后，他的constructor也被替换成Animal的了，因此注意立刻对此做出修改</span></div><div class="line">Person.prototype.constructor = Person;</div></pre></td></tr></table></figure>
</li>
<li><p>直接继承prototype</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我们可以把Animal类用prototype模式写，如是就不需要new Animal()了</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Animal.prototype.species = <span class="string">'动物'</span>；</div><div class="line">Person.prototype = Animal.prototype;</div><div class="line">Person.prototype.constructor = Person;</div><div class="line"><span class="comment">// 此方法的缺点是，任何针对Person的prototype修改，都将影响到Animal的prototype，因为二者现在属于同一内存的不同引用</span></div></pre></td></tr></table></figure>
</li>
<li><p>利用空对象作为中介</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这样，修改就不会互相影响了</span></div><div class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">F.prototype = Animal.prototype;</div><div class="line">Person.prototype = <span class="keyword">new</span> F();</div><div class="line">Person.prototype.constructor = Person;</div><div class="line"><span class="comment">// 利用这个原理，我们可以封装出一个继承方法：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    F.prototype = Parent.prototype;</div><div class="line">    Child.prototype = <span class="keyword">new</span> F();</div><div class="line">    Child.prototype.constructor = Child;</div><div class="line">    <span class="comment">// 留下通往父函数的通道</span></div><div class="line">    Child.uber = Parent.prototype;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>拷贝继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拷贝继承原理类似于上一种继承方式</span></div><div class="line"><span class="comment">// 首先依然把不变属性都绑定在prototype上</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Animal.prototype.species = <span class="string">'动物'</span>；</div><div class="line"><span class="comment">// 拷贝函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = Parent.prototype;</div><div class="line">    <span class="keyword">var</span> c = Child.prototype;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</div><div class="line">        c[i] = p[i];</div><div class="line">    &#125;</div><div class="line">    c.uber = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>非构造函数的继承：</p>
<ul>
<li><p>object() 方法<br>先来看Douglas Crockford ( json 的发明人 ) 如何实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 道格拉斯提出了一个object函数来完成非构造函数的继承</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 上面将子对象的的prototype指向父对象了，之后还需要将子对象本身的属性加上</span></div></pre></td></tr></table></figure>
</li>
<li><p>浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 顾名思义，将父对象的属性拷贝给子对象：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">p</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c = &#123;&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</div><div class="line">    c[i] = p[i];</div><div class="line">  &#125;</div><div class="line">  c.uber = p;</div><div class="line">  retrun c;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 浅拷贝的问题很明显，子类和父类的属性只是同一个内存的不同引用，因此子类修改属性，父类也会被影响</span></div></pre></td></tr></table></figure>
</li>
<li><p>深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 递归调用浅拷贝，实现深拷贝，实现真正的拷贝既可避免浅拷贝中出现的问题</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c = c || &#123;&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> p[i] === <span class="string">'object'</span>) &#123;</div><div class="line">      c[i] = (p[i].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</div><div class="line">      deepCopy(p[i], c[i]);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      c[i] = p[i];</div><div class="line">    &#125; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"><span class="comment">// PS jQuery库正是用的这种方式实现的继承</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="ES6中的面向对象"><a href="#ES6中的面向对象" class="headerlink" title="ES6中的面向对象"></a>ES6中的面向对象</h3><p>ES6给了习惯使用类的程序员们一个class语法糖，先给出<a href="http://babeljs.io/repl/" target="_blank" rel="external">babel</a>对class的翻译：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是ES6代码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name, age) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line">  sayName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// babel翻译后的代码</span></div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</div><div class="line">				<span class="keyword">var</span> descriptor = props[i];</div><div class="line">				descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</div><div class="line">				descriptor.configurable = <span class="literal">true</span>;</div><div class="line">				<span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</div><div class="line">				<span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</div><div class="line">			<span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</div><div class="line">			<span class="keyword">return</span> Constructor</div><div class="line">		&#125;</div><div class="line">	&#125;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    _classCallCheck(<span class="keyword">this</span>, Person);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  _createClass(Person, [&#123;</div><div class="line">    <span class="attr">key</span>: <span class="string">"sayName"</span>,</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">  &#125;]);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Person;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>参考代码后，发现，ES6中的类是构造函数+继承方法的一个语法糖，这里不做详细解析。考虑到原理上并无差异，这里只给出ES6 class中继承的语法供读者参考：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height, width) &#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'Polygon'</span>;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(length) &#123;</div><div class="line">    <span class="keyword">super</span>(length, length);</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'Square'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 请不要忘记 super() 倘若不调用 super() 方法，是不能调用父类方法的，子类的构造函数也无法完成。</span></div></pre></td></tr></table></figure></p>
<p>关于super()用法请参考： <a href="https://www.zhihu.com/question/38292361?sort=created" target="_blank" rel="external">ES6中的关键字super该如何理解？</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="external">阮一峰的博客</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" target="_blank" rel="external">JavaScript面向对象简介</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class" target="_blank" rel="external">MDN-JavaScript-class</a></li>
<li>百度百科</li>
<li>知乎</li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;不同的矛盾，只有用不同的方法才能解决。 &lt;br&gt; &lt;strong&gt;毛泽东&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　JavaScript并不是一门严格的面向对象语言，因为JavaScript没有类。ES6给习惯了使用类的程序员们一个类的语法糖，但相较于别的面向对象语言，ES6的这个类也是很不成熟的类（将在本文后续讲详细说明）。虽然没有一个严格定义的类，但这并不影响面向对象的设计思想在JavaScript编程中发光发热。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript知识总结" scheme="http://jasonzou.me/categories/JavaScript%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://jasonzou.me/tags/JavaScript/"/>
    
      <category term="面向对象" scheme="http://jasonzou.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>我目前的前端开发环境</title>
    <link href="http://jasonzou.me/2017/03/24/%E6%88%91%E7%9B%AE%E5%89%8D%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://jasonzou.me/2017/03/24/我目前的前端开发环境/</id>
    <published>2017-03-24T15:55:03.000Z</published>
    <updated>2017-03-25T03:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>工欲善其事，必先利其器。 <br> <strong>《论语·卫灵公》</strong> </p>
</blockquote>   
<p>　　我目前使用的前端开发工具：npm做包管理，webpack做工程化，babel用于翻译es6，IDE用webstorm，git用作版本控制。给自己的提醒：前端开发工具一定是在真正需要用到的时候才值得被学习使用，为了追求时髦而去学习使用工具是违背了工具的实用性这一特点的。<br><a id="more"></a></p>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>NPM（<a href="https://www.npmjs.com/" target="_blank" rel="external">官网</a>）是随同nodeJS一同安装的包管理工具，能解决NodeJS代码部署上的很多问题。常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用，前端开发中，也会常常使用别人开发的JS库。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装nodeJS后就可以使用npm进行包管理了，直接去<a href="https://nodejs.org/en/" target="_blank" rel="external">nodeJS官网</a>下载安装吧。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>npm的使用是很简单的，这里给出一个现成的<a href="http://www.runoob.com/nodejs/nodejs-npm.html" target="_blank" rel="external">详细教程</a>。</p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>Webpack是当下最热门的前端资源模块化管理和打包工具。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>首先要安装 Node.js，Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。<br>用 npm 全局安装Webpack： </p>
<pre><code># 其实不推荐全局安装，最好使用项目本地的webpack
$ npm install webpack -g
</code></pre><p>通常还需要将webpack安装进项目的依赖中，理论上每个项目都需要一个本地的webpack，这样避免了可能出现的版本冲突：</p>
<pre><code># 在项目所在的目录下
# 检查是否有package.json 没有就运行  $ npm init 
$ npm install webpack --save-dev
</code></pre><p>安装Webpack开发工具也是有意义的，Webpack Server会提供一个热更新的node后台，在实际开发时比较有用：</p>
<pre><code>#安装开发工具
$ npm install webpack-dev-server --save-dev
</code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>Webpack的使用方法很简单，只用写好它的配置文件即可，另外要注意，Loader是需要单独下载的。下面给出两篇比较详细的webpack使用教程：</p>
<ul>
<li><a href="http://www.jianshu.com/p/42e11515c10f" target="_blank" rel="external">入门Webpack，看这篇就足够了</a></li>
<li><a href="http://www.w2bc.com/Article/50764" target="_blank" rel="external">一小时包会——webpack入门指南</a></li>
</ul>
<h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>Babel is a JavaScript compiler. 这是babel给自己的介绍。通常，我是配合Webpack使用babel的，主要是用babel翻译es6，别的功能用的很少。</p>
<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><p>babel的安装很简单，还是直接用npm：</p>
<pre><code># 安装babel 作为webpack的一个loader
$ npm install --save-dev babel-loader
</code></pre><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>使用babel的第一步是配置Webpack的config文件：</p>
<pre><code># 找到config文件中的module，添加babel-loader
    module: {
      loaders: [
        { test: /\.js$/, exclude: /node_modules/, loader: &quot;babel-loader&quot;}
      ]
    }
</code></pre><p>第二步是配置.babelrc文件，这一步是关键，请参照阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="external">Babel 入门教程</a>。请记住：babel的转码规则是需要单独用npm安装的，所以配置完.babelrc文件后，还应该用npm安装对应的转码规则。</p>
<h2 id="WebStorm"><a href="#WebStorm" class="headerlink" title="WebStorm"></a>WebStorm</h2><p>WebStorm自称是最好的JavaScript IDE，简单说书我对WebStorm的看法。作为一款IDE，WebStorm吃的内存不算多，自动跳转，语法检查，自动补全这些是比较方便的，虽然sublime（当然也包括vim）配合插件也可以达成这些效果，但既然电脑能无压力的跑IDE为啥还要去用sublime呢。此外，sublime集成了版本控制插件，这点在实际开发中也是很方便的。</p>
<ul>
<li><a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="external">WebStorm官网</a></li>
<li><a href="http://www.cnblogs.com/gavin007/p/6379384.html" target="_blank" rel="external">破解WebStorm（如果经济上不是特别困难，请支持正版）</a></li>
</ul>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git就不必多说了，每个程序员都应该都会使用，哪怕确实不喜欢git，也很少有不会用git的程序员。如果是刚刚接触编程的同学可以参考<a href="http://git.oschina.net/progit/" target="_blank" rel="external">Pro Git</a>进行学习。</p>
<p>　　还有待填补的空缺：Karma之类的自动化测试工具，esLint之类的语法差错工具，CSS的预编译工具，HTML压缩工具和我不知道前端工具等等。等到有需求要用到这些新工具的时候我会学习之后再做一次总结的。</p>
<p style="text-align: center;"><b>… End …</b></p>





]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;工欲善其事，必先利其器。 &lt;br&gt; &lt;strong&gt;《论语·卫灵公》&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;   
&lt;p&gt;　　我目前使用的前端开发工具：npm做包管理，webpack做工程化，babel用于翻译es6，IDE用webstorm，git用作版本控制。给自己的提醒：前端开发工具一定是在真正需要用到的时候才值得被学习使用，为了追求时髦而去学习使用工具是违背了工具的实用性这一特点的。&lt;br&gt;
    
    </summary>
    
      <category term="工具使用技巧" scheme="http://jasonzou.me/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="webpack" scheme="http://jasonzou.me/tags/webpack/"/>
    
      <category term="babel" scheme="http://jasonzou.me/tags/babel/"/>
    
      <category term="git" scheme="http://jasonzou.me/tags/git/"/>
    
      <category term="WebStorm" scheme="http://jasonzou.me/tags/WebStorm/"/>
    
      <category term="前端工程化" scheme="http://jasonzou.me/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>md文档编辑方法小结</title>
    <link href="http://jasonzou.me/2017/03/23/md%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://jasonzou.me/2017/03/23/md文档编辑方法小结/</id>
    <published>2017-03-23T10:33:50.000Z</published>
    <updated>2017-03-23T11:55:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>好好学习，天天向上！ <br> <strong>毛泽东</strong> </p>
</blockquote>   
<p>　　这两天学习了md文档的编辑方法。不翻墙的话，在网上比较难找到一份十分详细的markdown标签文档（这是当然的，毕竟不同的环境里有不同的md“方言”），索性就按照wiki自己动笔写一份。   </p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><pre><code>[图片名称](图片链接)
</code></pre><p><img src="http://s13.sinaimg.cn/mw690/0028V8trzy6QIsLfTeA5c&amp;690" alt="星空">  </p>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><pre><code>*强调*  **加重强调** ***加重强调斜体***    
_强调_ __加重强调__ ___加重强调斜体___
</code></pre><p><em>强调</em> 、<strong>强调</strong> 、<strong><em>强调</em></strong><br><em>强调</em> 、 <strong>强调</strong> 、<strong><em>强调</em></strong>    </p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><pre><code># 一级标题
## 二级标题
### 三级标题
...
###### 六级标题
</code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>…</p>
<h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><pre><code>一级标题
==========
二级标题
----------
</code></pre><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre><code>&gt; 这段内容会成为引用内容
</code></pre><blockquote>
<p>被引用的内容 </p>
<p>引用可以分成多行<br>    这是第二行</p>
<blockquote>
<p>这是引用中的嵌套引用。这是第一行<br>    这是第二行</p>
</blockquote>
<p>这是外层引用的第三行，前面要加一个空白的引用表示内层嵌套的结束，空行最前面的(‘&gt;’)可有可无。</p>
<p>引用可以分成多行<br>这是第二行</p>
<blockquote>
<p>这是引用中的嵌套引用。这是第一行<br>这是第二行</p>
</blockquote>
<p>这是外层引用的第三行，前面要加一个空白的引用表示内层嵌套的结束，空行最前面的(‘&gt;’)可有可无。   </p>
</blockquote>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><pre><code>[链接标题](http://链接地址.com)
</code></pre><p><a href="http://jasonzou.me">夹缝</a>  </p>
<h3 id="水平区分线"><a href="#水平区分线" class="headerlink" title="水平区分线"></a>水平区分线</h3><pre><code>* * *
***
*****
- - -
-----------
</code></pre><hr>
<hr>
<hr>
<h2 id="-1"><a href="#-1" class="headerlink" title="- - -"></a>- - -</h2><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><pre><code>文字之间，不论你空格多少次，都只会出现一个空格，并且在行首是不能添加空格的。解决方案：输出&amp;emsp; 
或是将输入法切换到全角再空格即可。
</code></pre><p>&emsp;&emsp;测试   </p>
<h3 id="方言"><a href="#方言" class="headerlink" title="方言"></a>方言</h3><p>　　一如文章开头所说，md文档在不同的环境下是有其特有方言的。故而，全部列出意义并不大，我只是将最基本的语法列出，更多的语法可以参考以下链接：    </p>
<ul>
<li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">这篇文章讲了md文档是如何兼容HTML的</a></li>
<li><a href="http://mahua.jser.me/" target="_blank" rel="external">麻花</a></li>
<li><a href="https://maxiang.io/" target="_blank" rel="external">马克飞象</a></li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>　　最后，我必须提出，md文档最后是会转译为HTML文档的，因此，只要有基本的前端知识，理论上我们是可以写出任何样式的文本的。所有的md标记，只是让文档编辑更轻松而已，实在不知道某个样式所对应的标签，不妨就用HTML将其完成吧。</p>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;好好学习，天天向上！ &lt;br&gt; &lt;strong&gt;毛泽东&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;   
&lt;p&gt;　　这两天学习了md文档的编辑方法。不翻墙的话，在网上比较难找到一份十分详细的markdown标签文档（这是当然的，毕竟不同的环境里有不同的md“方言”），索性就按照wiki自己动笔写一份。   &lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="工具使用技巧" scheme="http://jasonzou.me/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="md文档" scheme="http://jasonzou.me/tags/md%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>为什么净是耻辱</title>
    <link href="http://jasonzou.me/2017/03/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%80%E6%98%AF%E8%80%BB%E8%BE%B1/"/>
    <id>http://jasonzou.me/2017/03/22/为什么净是耻辱/</id>
    <published>2017-03-22T14:57:57.000Z</published>
    <updated>2017-03-24T15:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>悲剧将人生的有价值的东西毁灭给人看。<br> <b>鲁迅</b> </p>
</blockquote>
<p>　　在我初二初三的时候，常常认为自己是个悲剧。这种“病态”的想法，犹如附骨之躯，数年间，在我独自一人时，他总会不请自来，搔弄我颇为敏感的神经。<br>随着时间的流逝，我逐渐习惯了份瘙痒，对其见怪不怪了。甚至有段时间里，我一度认为，这份灵魂深处的自我鄙视，会让自己带上几分忧郁气质，成为某种“招蜂引蝶”的芬芳。<br>但，随后的几年里，我又迅速明白了那是一个错误的对于自身的认知。<strong>事实上，我不是一个悲剧，我是个滑稽剧，滑稽透顶。</strong>我的生命中（如<strong>《人间失格》</strong>的主人公一样）充满了耻辱。</p>
<a id="more"></a>
<h2 id="实在算不上有价值"><a href="#实在算不上有价值" class="headerlink" title="实在算不上有价值"></a>实在算不上有价值</h2><p>　　相较于鲁迅先生对于悲剧的定义，他对于喜剧的定义是鲜为人知的。<strong>“悲剧将人生的有价值的东西毁灭给人看，喜剧将那无价值的撕破给人看。”</strong>会一度认为自己是个悲剧，这本身就是出喜剧。要说我的价值，存不存在是一个大大的疑问，哪怕真的存在，恐怕也不会超过只剩下一只的鞋太多。<br>　　我是渴望“有价值”的，而且我一直认为：<strong>人的价值，应该是不可或缺的。</strong>倘若能被取代，那这份价值只能被称作物品的价值。所以我希望自己能不可或缺，对于别人而言也好，对于自己而言也好。<br>　　因为害怕能被取代，所以我在与朋友和恋人的相处中都付出了巨大的努力。我是一个乞丐，一条摇尾乞怜的狗，一切所作所为都不过是为了从别人那里得到认可。哪怕只是在某一个瞬间，我希望对方会产生“生命中不能没有他”这种想法。也只有这样，我才觉得自己是有价值的。<br>　　我曾一直有个困惑：为什么我会成为一个极端不自私的人。原本，我认为这或许是种优点。但后来才明白，我无法给予自己认可，所以才无法成为一个自私的人。相较于自己吃下一个苹果，送别人一个苹果并且看她吃掉会更让我满足。我给不了自己精神上的满足，并且，越是在肉体上满足自己，我越是会去寻求精神满足。为人所驱使，被不公平的对待，不仅不会让我觉得难过，相反，我会感到满足，会产生自己离成为别人的“不可或缺”更进了一步。即使后来恍然大悟，发现我不可能得到这份所谓的“不可或缺”，但这病态的心理，却被可耻的保留在了我的灵魂深处，成为了我与他人交际中挥之不去的耻辱。<br>　　一个连认同自己都无法做到的人，实在算不上有价值。</p>
<h2 id="从未达成过目标"><a href="#从未达成过目标" class="headerlink" title="从未达成过目标"></a>从未达成过目标</h2><p>　　整个小学，我都是按照别人（主要是我的父亲）的命令去学习的，因此，刚上初中时，我根本就不具备自己给自己设立目标并且努力去达成的经验和能力。所有出于主观想做的事，要么被否定，要么得不到足够的支持。我的父亲对我是缺乏耐心的，他是一名小学教师，熟知怎么样能让一个小学生得到好的成绩，所以我一直以来，只需要按照他的命令学习，我就能一直保持很优秀的成绩。但小学的成绩是微不足道的，哪怕我在初中的招生考试中考了全市第二，那点点成绩对我而言也实在算不上有意义。<br>　　初中的我脱离了父亲的管束，学习成绩迅速下滑了。那时的我对成绩不好充满了恐惧，倒不如说，年幼的孩子在他所经历的教育中产生了这样一个想法：我的未来，源自于我的成绩。所以成绩下滑，对那时的我而言（只是我无知地认为）意味着我的一生都要被葬送了。正如小学时每每听到别人夸我聪明时我会极度地心满意足认为自己前途无量一样，班主任皱着眉头问我，为什么考成这样时，我身上的每一寸肌肉都在战栗和哭泣。<br>　　严厉的管束带给我的，除了一份本不该属于我的成绩，还有一个凡是能“偷懒”的时候一定要偷懒的习惯。这简直是一个恶毒的诅咒。如开头所述，那时的我并没有出于自己的意志去做“正事”的经验。在这样的条件下，为了让自己的成绩有所提升，我开始试着让自己主动地去做一些事，不管是坚持背单词，还是独立按时完成作业。而这，正是我经历过的最大的耻辱。<strong>因为，从我初一到现在，接近十年间，竟从未达成过任何一个“目标”。</strong><br>　　到现在为止，我已经有了丰富的订立目标的经验了，但我却没有任何一点完成目标的经验。<br>　　初三的时候，我决心要用三个月的时间做完一本英语阅读资料。这是我距离完成目标最近的一次，哪怕是在拖延了几个月之后，一直到了第二个学期，才做完。因为，别的目标，大多是要么被遗忘，要么被放弃了。连被拖延的资格都没有。更不必说，我高中的时候想督促自己学好物理（别的学科也都有类似的经历），所以试图超前自学，结果不仅没有提前学完课程，反倒是有一些部分完全没有学好，成为了高考中的遗憾。大学的时候，每一学期都没有例外，我会在期末的时候给自己定下学习时间表，期望自己不要挂科。但是每一个学期，我都会有考不过的科目。<br>　　我甚至都会怀疑，是不是自己的智商存在问题。但客观的评价是，我虽然算不上是聪明人，但也绝不是特别笨的那种，也许我做不到门门科目优秀，但我肯定不至于有哪门科目连及格都不做到。要说这些都不是我的兴趣，达不成还尚存有借口，可我连自己极度痴迷的游戏都没办法玩好，达不成定下的目标。其他的种种，实在是没有脸面再提了。<br>　　一份让自己极度恶心的耻辱。<br>　　<strong>一个从未达成过目标的人，什么事都做不成。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;悲剧将人生的有价值的东西毁灭给人看。&lt;br&gt; &lt;b&gt;鲁迅&lt;/b&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　在我初二初三的时候，常常认为自己是个悲剧。这种“病态”的想法，犹如附骨之躯，数年间，在我独自一人时，他总会不请自来，搔弄我颇为敏感的神经。&lt;br&gt;随着时间的流逝，我逐渐习惯了份瘙痒，对其见怪不怪了。甚至有段时间里，我一度认为，这份灵魂深处的自我鄙视，会让自己带上几分忧郁气质，成为某种“招蜂引蝶”的芬芳。&lt;br&gt;但，随后的几年里，我又迅速明白了那是一个错误的对于自身的认知。&lt;strong&gt;事实上，我不是一个悲剧，我是个滑稽剧，滑稽透顶。&lt;/strong&gt;我的生命中（如&lt;strong&gt;《人间失格》&lt;/strong&gt;的主人公一样）充满了耻辱。&lt;/p&gt;
    
    </summary>
    
      <category term="胡诌" scheme="http://jasonzou.me/categories/%E8%83%A1%E8%AF%8C/"/>
    
    
      <category term="太宰治" scheme="http://jasonzou.me/tags/%E5%A4%AA%E5%AE%B0%E6%B2%BB/"/>
    
      <category term="生之耻辱" scheme="http://jasonzou.me/tags/%E7%94%9F%E4%B9%8B%E8%80%BB%E8%BE%B1/"/>
    
  </entry>
  
</feed>
