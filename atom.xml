<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夹缝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jasonzou.me/"/>
  <updated>2018-02-17T20:56:12.000Z</updated>
  <id>http://jasonzou.me/</id>
  
  <author>
    <name>Jason Zou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何在一局LOL中获得胜利</title>
    <link href="http://jasonzou.me/2018/02/13/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%B1%80LOL%E4%B8%AD%E8%8E%B7%E5%BE%97%E8%83%9C%E5%88%A9/"/>
    <id>http://jasonzou.me/2018/02/13/如何在一局LOL中获得胜利/</id>
    <published>2018-02-12T16:53:55.000Z</published>
    <updated>2018-02-17T20:56:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　从S3到S8，不知不觉的，我已经开启了在召唤师中第六个赛季的旅程。虽不敢说自己的技术是一直都在进步的，但我的游戏理解绝对是已经进步到了一个比大部分人都高的位置。这其中离不开我多年观看解说教学视频，观看比赛，观看直播以及不断地实践。令人遗憾的是，我并没有一个令人尊敬的段位，因为在游戏中我有很多自己知道该做好，但是还是没有做好的事。这并不影响我分享自己的经验，毕竟，哪怕是失败的经验也能成为很好的学习素材。下面，我将分享自己在LOL世界中的五年所学。<br><a id="more"></a></p>
<h2 id="为了胜利而游戏"><a href="#为了胜利而游戏" class="headerlink" title="为了胜利而游戏"></a>为了胜利而游戏</h2><p>LOL 的游戏玩家有很多种，本文是为对胜利的渴望高过其他所有东西的人而写的。想在和他人的对弈中取胜，是需要努力和付出耐心的。LOL 这种类型的游戏和别的游戏有些区别，别的游戏，比如 RPG 带给你的负面情绪可能只是觉得无聊了，玩得没意思了。而 LOL 可能会让你觉得愤怒，沮丧，难过甚至对自己失去信心，如果你脾气够大，你甚至还可能因此失去友情。我想表达的是，这款游戏并不那么适合休闲，如果你不是为了胜利和胜利之后的那种无与伦比的喜悦而玩这款游戏的话，可以趁早退坑，出门右转吃鸡，刺激战场，爽到飞起，死了重开，把把嗨皮。我非常喜欢这个游戏，它对我来说意味着很多，它是我的朋友，是我的老师，是我反省自己的镜子。我相信很多人和我一样，这款游戏可能曾经陪伴你打发时光，也可能曾教会你要耐心、要用理智克制情绪、要自信同时信任他人、更重要的是要学会原谅别人和原谅自己。这个游戏是一面镜子，你的所有进步，不管是技术的还是心态的甚至哪怕是努力调整后变规律了的作息，都能很直接的在你的排位战记中映射出来。如果你也恰好因为以上的任意一点，而喜欢这款游戏，那么这篇小总结，就是为你——一个为了胜利和进步而战的你所写的。</p>
<h3 id="目标意识和心态"><a href="#目标意识和心态" class="headerlink" title="目标意识和心态"></a>目标意识和心态</h3><p>考虑到我们是为了胜利而进行游戏的，那么我们就应该找到通往胜利的路。路是有很多条的，哪怕你技术不足，走路走得慢，只要你能保证自己不走弯路，你同样可以有机会战胜技术超过你的对手。而避免走弯路无非就是两回事：认清目标，保持心态。</p>
<h4 id="游戏分期和目标意识"><a href="#游戏分期和目标意识" class="headerlink" title="游戏分期和目标意识"></a>游戏分期和目标意识</h4><p>从我刚刚接触这款游戏到现在，LOL 已经逐渐进步成了一个分期非常明确的游戏了。<br>游戏前期：<br>　　游戏前期一般就是我们说的对线期。有人一听名字，认为：哦，顾名思义，对线期是属于线上英雄的时期。其实恰恰相反，对线期是打野的黄金时间。在这个时期中，双方的线上英雄互相对抗，发育，交换技能然后面对 GANK ，并最终在打野大约6J，中上平均7J的时候，分出线上的优劣，大优（最低标准：杀了对面1次并领先召唤师技能；杀了对面2次，召唤师技能平等；没有杀对面，但压了对面25刀以上，并领先1整J同时领先召唤师技能），中优（最低标准：杀了1次，不领先召唤师技能；杀了两次，落后两个召唤师技能；没有产生击杀，但压刀15刀并压制半级，最好还领先召唤师技能–其实通常就是把对面逼出闪现打回家一次，然后多吃了一波炮车兵同时因为对线压力的问题，压了对面几刀），小优（最低标准：DF二连杀了对面然后压了点刀；补刀比对面好压15刀同时压点血量），劣势就是反过来，不值得再多BB了，值得一提的是，当你DF二连杀了对面，然后最后没有压刀压经验这是妥妥的均势，不可太过嚣张。同样的标准也可以在稍作调整后用在打野位上，以打野为例子说明一个注意事项：当你作为打野，交闪现抓了一路取得击杀后直接回家，然后对面打野反了你1-2组野怪，同时多吃了河蟹，你在打野对位上，根本算不上是优势，所以前期的前期（也就是6J前）中，打野的GANK一定要非常谨慎。不然前期结束的时候，你可能会3-0打不过对面0-0的打野，还想不清为什么。<br>　　总之，在打野到达6J的这个时候，一般会成为前期的关键时间点，老打野会判断了线上形势后选择来一次足够左右整局游戏走向的GANK。在当前版本，最典型模型的就是，你选个努努，上中任意一路优势（哪怕只是小优），你 ALL IN ，技能全交，帮他把把优势扩大到能无压力压线的程度。然后发育，控制对面打野，在你第二个大招转好的时候，越好你刚刚帮起来的小伙伴，去下路来一次激动人心的4V3(2)，或是中（上）路来一波3V1(2)，当然，一般这个时候吃亏的都是下路，毕竟下路因为人多的原因，一般要相对稳定一些，哪怕是小劣，也是可以拉着一并越塔的。这一波战斗一般出现在，下路6J之后。一旦胜利，拆掉了关键的一塔，之后游戏就能顺利地以优势进入中期。<br>　　前期是打野的时期，作为线上的人，只要你想赢，你应该在任何一个可以帮助打野，同时<strong>不损害自己发育</strong>的时机去帮助你的打野。而如果你是打野，你绝对不能梦游，在这个时期梦游，或者胡乱抓人入侵，你可能会眼睁睁的看着自己的队友优势变劣势，大优被推塔等。<br>　　顺带也分享一些游戏前期很重要的技巧或注意事项：记召唤师技能时间；正常的刷野路线下 2：30-2：50 打野抓上（他要是反着抓那就抓下呗）；闷头刷六组野怪，刷完的时间一般为3：30-3：50，不会gank，十有八九都不会GANK，因为已经残了；尝试抓上（中），但没有斩获，回头打一组野怪抓下的时间：4：10 之后；下路防2J GANK眼断眼时间：3：30；中路防上方GANK眼消失时间：4：50；第二轮 BUFF 刷新后gank时间：6：50S（很重要，中上6或者快6了）；10：00 峡谷先锋出现；峡谷先锋一般是优势方在局势僵持住，不能推进节奏时才考虑拿的，劣势不要去吃峡谷先锋，没有意义，如果是前期阵容，但是局势均势，实在没有推塔机会，打野可以尝试强行拿一波峡谷先锋打开局面，总之，路人局中峡谷先锋是锦上添花的东西，请不要为了峡谷先锋耽搁正事；不论在前中期的任何时候，推塔是最优选，吃小龙是次优选，峡谷先锋是最后实在没事做的时候吃一吃的东西；上路很奇怪，如果你的上单是个瑞文鳄鱼诺手之类的半肉战士，哪怕你们的团队帮他或是他靠自己自己建立了大优势，也不要太早推塔，路人局中过早的吃掉上单线的塔将会把你的上单暴露给对面的中野，并且让对面的上单得到控线发育的机会，最好上单快9J了再推；如果上单是劣势，不管你是什么英雄，能推塔就快推了吧，单线打不过对面就保证不死，同时吃线跑图，对面没有一塔的情况下，对方上单不敢轻易越河道压制你，如果他还是压制得很厉害，请小心对面的打野是不是就在上路的草丛里。<br>　　那么现在说回来，讲讲前期的目标具体应该怎么分解。<br>　　线上：想办法压刀压经验逼技能甚至击杀，如果不能，那就想办法别被压刀压经验逼技能，如果你在前期结束时只是被压了十几刀，那根本不算是劣势；如果你死了，请你不论如何都不要死第二次，不然你将成为团队的累赘；前期的线上没什么好说的，主要是技巧性的东西，简单讲可以这么说，我觉得对线最可怕的人是，他稳定补刀，不被消耗，注意打野动向，不被gank，他也许杀不了你，但是一旦野区有问题，他能第一时间反应，如果打野来了，他一定能配合打野给你压力哪怕只是借机让你少补几个刀，他们不在自己不必发力的时候乱发力，而一旦有机会或者是你一旦有失误他们一定能抓到。想象一下自己对线时最怕的是什么样的对手，然后向他们学习。<br>　　打野：1、判断敌我打野英雄克制关系。2、预先判断线上优劣，也就是上中下的英雄克制关系。3、根据1、2的结论选择正常刷野还是先打两个BUFF再升3，甚至直接2J去对面野区搞事：A上中推线优势路，你是个努努对面是个猪妹木木之类的，你直接去对面野区跳舞就行了。B上中推线劣势或均势，你打不过对面打野，请直接把两个BUFF吃了再干别的。其他AB之间的情况最好正常刷野，不要轻易扰乱你线上队友的节奏。4、打完BUFF后提醒队友做视野小心打野前期最具有威胁的3J抓人，同时判断哪路可抓，2v2是否打得过，打不过能不能跑（其实打不过能不能跑才是重点）。5、如果有机会抓并且2v2打不过也能跑那么就勇敢地上吧，毕竟打野前期的发动机，你有机会都不发动，那对面打野就要想办法发动点什么了。如果成了，请一定要推线，线上的人给你打撤退你就求他逼他，因为你不一起分一点经验，别人要是看你露头反了你的野，你就会非常难受了，因为等级肯定会落后。推了线不管状态如何最好都直接回家，先对手回家，先对手出门对于打野而言是至关重要的。6、如果没有机会抓，那么请打字提醒你的队友小心对面打野，然后你认为自己刷野比对面快就去日个蟹，反之就直接一路往回刷就行了，对面的打野日完蟹又没有gank机会那他就要来你的野区看望你了，你留着野怪不打别人不会客气的。7、如果一直到吃下路河蟹的时候你都还没有跟对面打野碰面，说明他到处旋了一圈儿发现没事做，回去打自己的野怪了，那你日了蟹回家就行了，你很难碰到跟你一样思路清晰的打野，所以你一般会比他快，你在第二波将先他出门，出门时请带上一个真眼。8、回家后补装备，朝线上走，观察优势路，准备好前文中讲的至关重要的那一次gank了，真眼是用来确保没有后顾之忧的，如果你的优势路是小优，请谨慎行事。9、如果三路劣势怎么办？请找一路看山去智商没问题的路，强行把他帮成优势，然后紧接着做之后的事情。机智的同学已经看出了本文的问题了，作为读者可能想问：那我要是不能帮成优势怎么办呢？那我也没办法啊，队友实在太菜太菜了，而且你也很菜，你就只有埋头刷了，有些时候玩游戏玩成了比哪边更菜去了，这种玩得是很让人哭笑不得的。一句话：你要是总是不能在三路劣势时做到把某一路的劣势扳回的话，那你换位置吧。10、如果你成功的养出了一个中优或者大优路，就要想办法掌控对面打野的动向（这是一个打野的基本功，是必须做到的，你要是线上优势都搞不清对面打野的位置你就换位置吧），并且在保证自己的发育的前提下，进一步压制对面的劣势路或是帮你的劣势队友稍微稳住局面了。等你优势路伙伴，比如上路的TP好了，或是中路的线推过去了，就着手去搞某一路的倒霉蛋吧，这个步骤一定要尽快完成，不然最后3V1越塔可能变成3V3，那就要把优势全给吐出来了。11、如此说来，当你处于一个绝对逆风的节奏时，该怎么做就很清晰了，假如你出现了两位不幸的线上绝对劣势的队友，请在保护自己发育的前提下，保护他们不要被轻易越塔，尽量把前期拖长，哪怕最后还是掉了塔，在有一定的装备基础的情况下，对面是不容易进行中期的雪球滚动的。这也是中期逆风抗压的基础。逆风对打野的要求更高，你可能需要冒着背锅的风险去想办法限制对面推进节奏，比如，队友被推线还去反野，比如，在2v2如果打不过就很容易死并且跑不掉的情况下，还是开启了一次gank等。不要怕被喷，坐以待毙的人是不会也不能理解宁愿背锅也不想输的人的想法的。12、到己方一塔掉了，或是对面一塔掉了开始，前期就结束了，游戏进入最激动人心的中期。值得一提的是，下路的塔在下路两人6J之前推掉了也不算前期结束，必须要下路两人都发育到至少6J，才能算是前期结束。</p>
<p>游戏中期：<br>　　游戏中期分为劣势中期，和优势中期，判断标准很简单，看被推的塔的数量即可。现在的各个版本为了增加比赛的激烈程度，在不断地提升前期对整个游戏的影响力，带着优势进入中期的队伍将极为有利。在职业比赛中，带着优势进入中期的队伍，胜率超过七成。而高分局中，带着优势进入中期，只要阵容不差，且队友不乱搞，基本上可以宣告游戏胜利。遗憾的是，低分段的小伙伴们，能够在进入优势的前两三分钟迅速地将优势挥霍出去甚至转变为劣势。<br>　　这里我分别用劣势中期的中上，优势中期的中上，劣势中期的辅助和优势中期的辅助等多个视角，大概介绍一下该如何推进优势or阻止劣势扩大。<br>　　劣势中期的上单：当你被推塔了，你的首要任务是做视野，一个被推掉了塔的上单最需要做的事情，就是保证队友的安全，不要让队友为你的劣势埋单。劣势时，最理想的情况是，你做好了视野，掌控了对面上单的动向，他虽然被解放出来了，但是最多就只是多比你日个蟹，而你可以控线吃刀，慢慢补充发育到成型。并在支援中找到机会打赢小规模团战，反推塔，扳回劣势。<br>　　劣势中期的中单：如果所有塔中，第一个掉的是你的中塔，而且这种事情在劣势时不止一次发生，我建议你换位置。中塔是中期的支柱，两座中塔只要还没有陷落，中期就会一直延续，逆风中，你的打野和边线队友将留有发育机会，而顺风里，从你中塔处源源不断向对方中塔压进的小兵，就是对对面中野最好的牵制。你要做的是尽量推线，在保证自己不死的前提下，尽可能的推线，把对面的打野甚至是对面的下路组合吸引到你身边来，给你的队友喘息的机会，中路线段，只要你是平稳渡过了前期，并且不是偏门的中单英雄，你一定是拥有推线能力的，这个时候，你最好的carry方式不是放弃你的兵线去支援某一路，而是想办法把兵线推出去，然后同被你吸引而来的对面下路组合或者打野进行小规模团战，如果你是逆风，那么最好耐心等待以多打少的机会，哪怕没有机会，也要推迟塔被磨掉的时间，尽量让自己和多有多出点装备，这样才能在后期有抢龙翻盘的资本。如果你线上是优势。那么请勇敢地站出来，这正好就是你需要发力的时间点。<br>　　优势中期的上单：你如果吃掉了对面的一血塔，请购买两个真眼然后慢慢推线，这个慢慢是非常精髓的，一个机智的上单不会在推掉了对面的一血塔之后就无脑推线。最理想的做法是，在不让对面上单轻易吃刀地情况下慢慢推线，这样可以让线上汇聚很多的小兵，如果你的处理很得当，你可以汇聚大约2.5波以上的小兵在对面的一塔前一些的位置朝对面的二塔进发，这个时候假装凶一凶对面上单，在这之前，你已经在你身后做了视野了，并且是真眼视野。凶一下的目的是让他往自家二塔退，凶了之后迅速吃完一波线，你就可以朝中路走了，一大波线可以确保对面上单支援比你慢很多，他要是放弃兵线强行跟你一起支援，哪怕最后他们打过了，只要不是小团血崩，己方都是不会亏的。中期的上单很关键，他们往往能决定一些关键小团战的胜负，要知道同样是3v3，一个优势上单+中+野 对抗对面的中+野+辅/ad 往往是血虐的，为什么对面没有上单呢？因为对面上单会受到兵线的牵制。中期的上单主要任务就是让对面的视野一片黑，给对面中野巨大的压力，并且第一时间参与团战，掌控团战的走向。<br>　　优势中期的中单：你要是能吃了对面的中塔作为一血塔，那要么说明你技术已经超过了本分段了，要么就是你家上下路受了对面中单不少恩惠。如果是前者，那就不谈了，如果是后者，那么你一定要想办法和打野一起把你劣势路一方的敌方野区点亮，然后拔线推出去，做出一副我要吃你二塔了的样子，然后随时准备溜到下路去支援一波，如果你吃了对面中塔，那么对面的野区的出入权就握在手里了，一定要去对面野区多转悠，做视野，偷野怪，不出意外，所有gank也都应该是从对方野区发起的，在你做了视野或击杀对面打野后进行。保证自己不要死，多尝试几次，上下路的劣势很快就回来了，掉中塔对于对面打野而言是最难受的，如果你和你的打野稍有经验，他的行动一定是裸露在外的，干什么都会心惊胆战，而压制对面打野其实是对对面三路都进行了轻微的压制，保持推线，在视野明亮的地方作战，积累优势，最后才是想办法帮助队友推塔。<br>　　劣势中期的辅助：下路被推塔基本上可以算是常事了，不出意外，你的塔掉了之后，下路二人将面对对方的上单或者中单。这样其实很不好，作为劣势一方，你们没有办法在身后没有视野的情况下轻易压制一个等级更高的人，而同时你可怜的队友要一个人面对两个人吃了一血塔的人的压制，并且对面打野指不定就在身后等着兵线进塔。赶紧跟上对面下路两人的步伐，和他们想推进的那一路的队友换路，抵抗他们推进的同时发育。<br>　　优势中期的辅助：看过青蛙直播的人应该都知道青蛙的一个爱好，那就是日常大哥。聪明的小伙伴会思考常大哥到底做了什么，让青蛙每次下路塔一推就要去日一次呢？我们发现，哪怕是在钻石局的路人局中，下路被推后的劣势两兄弟都是不会跟即将抗压的队友换路的。于是乎，青蛙就称呼上单为大哥，说一句：上单大哥，您去下发育，我和AD推上。上路逆风，那他这么一听，就开心的去下路了，上路要是顺风，就更不会拒绝队友的请求了。然后对面可怜的上单，如果没有打野的帮助一般三四波兵线后就会被吃掉上路一塔。而后下路二人组利用发育优势转中不管是越塔还是吃小龙或峡谷先锋都是非常自由的。在峡谷先锋的加持下，中一塔是很容易就被拆掉的，如果中路是优势，那么甚至可以强拆一塔，峡谷先锋送给对面二塔。<br>　　中期最关键的就是视野，你可以因为经验丰富，在前期不做视野，也能安然度过乃至取得优势。但中期不同，你不仅要做视野防对面gank，你还要换上扫描清理对面的视野，这是搞事和应对搞事的关键时期，优势方只要有视野优势，对地图资源基本上是可以为所欲为的。正如我之前所说的，只要队伍是优势，实在我们推不动了，就把视野一扫去日个峡谷先锋，照样能打开局面，而这个“实在不行就打了”的峡谷先锋，就成为了这个版本节奏快，并且高分段优势很难输的原因了。<br>　　当双方的一塔全部掉完后，游戏就进入了后期。有小伙伴会奇怪，那我要是一塔没有掉完就把对面推完了算什么呢？那当然是算，你们在游戏的中期就结束了战斗呗。一个正常的中期雪球滚完后，双方一般人均至少差个半件大件。所以翻盘在会玩的人中真的是小概率事件，虽然也时有发生，但是这就是个尽人事，听天命的活路。要是你真的中期完美处理了，最后还是被对面一波完美团，拿大龙给翻了，那要么是状态不好，要么就是菜呗。</p>
<p>游戏后期：<br>　　中期的差距没有拉开的话，游戏就会被迫进入后期。现实对战中，你作为中单上单或是打野，帮你们下路吃了对面下路一塔，回头一看，诶，老子的上（中）塔也丢了。像上述这种情况，往往就会让双方在中期展开拉锯战，具体各个位置的人应该做什么之前已经讲了。而拉锯拉的差不多了，一塔基本上掉了，或者一边剩一个的时候，这个时候，最能左右游戏的召唤师峡谷生物——男爵就出现了。有些人玩了几年的游戏都理解不了，男爵其实是后期的核心。因为理解不了，所以他们会四个人跑去抓人家下路带线的上单，因为理解不了，所以哪怕对面四个人去抓你家带线的上弹了，大家还是该干啥干啥不去开龙。<br>　　事实上，在上分阶段，也就是说分段还不高的时候，最容易上分的两个位置无非就是打野和带线英雄（打野也可以是带线英雄）。打野英雄就不谈了，想在前中期建立起优势，一个脑袋清醒的打野是非常关键的。而带线上（中）单则是因为他们可以把敌人从大龙或是一塔二塔的阵线前拉走，一旦自己是优势，并且队伍成功的拖到了后期，就可以让队友有机会以多打少，而因为长时间的带线，一但真的需要参与团战时，自己也能发挥巨大的影响。<br>　　低分段老是把可以提前结束的游戏一直往后拖，打野闭着眼睛抓人，有机会吃小龙，跑到对角线方向的野区去刷野；队友要么太怂，有机会越塔，非要杵着不动，要么太刚，大优势就不死不回城；总之感觉不想赢或者不知道怎么赢的人太多了。这个时候，后期最可怕的一类英雄——带线英雄，就要开始崭露头角了。<br>　　后期的制胜方式一个是团战，一个是运行，团战是技术问题，多打打大乱斗会比较有帮助。这里多说说四一分推。<br>　　蛮王最辉煌灿烂的时候是S3到S4的时候，那个时候的蛮王线上只要是优势，就会变得非常难以处理，打野来抓不死一个带疾跑还自己带位移的上单，慢慢的吃掉对面的塔之后，他就能开始表演了，把线一压，视野一做，看来几个人，一个人守，越塔杀了，两个人守杀一个溜了，三个人守，野怪吃了还能给你换一个。你不能不管他，他野怪给你吃完，塔给你一路推到高地，你也不能管他，你好不容易压制住的除了他之外的其他人将得到巨大的喘息机会甚至还能偷掉大龙。现在的顺风剑姬贾克斯鳄鱼等一系列半肉战士同样能这么玩，只是因为游戏平衡机制在不断改进，现在做不到以前的巅峰蛮王那么夸张了。<br>　　当然带线英雄并不那么好玩，这种非常C的英雄，对玩家的要求是很大的。首先，你不能是逆风，并且最好是顺风，你越顺，影响力越大。第二，假如你不是卡牌瑞兹梦魇这种自带位移的英雄，你必须要带TP，这削弱了你的对线能力。第三，当对面选择了强开团英雄时，对面可能会不管你直接开你的队友，而你要是不管你的队友，很可能某一波关键团你队友被开了游戏就结束了，你必须要把握好带线的时候同时支援要及时。第四，你绝对不可以被两个人抓死更不能被单杀。第五，需要你有一定的交流能力，不要小看这个，很多人屁都不放一个就单带，分稍微高些队友理解你，分低了队友指不定乱开团，然后团输了后给你狂发问号。<br>　　游戏后期的核心在于阵容和技巧，到此为止，文章主要讲的是战略的内容，而团战怎么打属于战术，之后合适再说。</p>
<h4 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h4><p>　　心态是理智的基础，而失了智是没办法正常执行自己的战略的，因此心态某种意义上讲，是比这之前的内容都要重要的。这里并不是要给一些鸡汤，鼓励同志们不要喷人，不要放弃。这里要讲的是，作为一个想赢的人，到底应该怎么做。<br>心态分级：<br>　　心态是可以分为好几个等级的，由低到高，第一个是毒瘤型，不仅自己一点就着，还能非常熟练地把队友心态也搞蹦，第二个是自闭型，自己很容易产生负面情绪，但是不瞎叫唤，但其实理智已经没了，会时不时送死，不听队友信号，拒绝交流拒绝和队友配合。第三个是我佛慈悲型，队友惹他生气，他立马原谅，自己被抓十次，默默补防御装，补眼，永远不会忘记自己应该做的事。第四个是普度众生型，你和他一起玩游戏，就算输了你也会心态良好，在欢声笑语中打出GG，然后还有意愿去主动总结，在下一局打的更好。<br>　　这游戏的绝大多数人是处于第二个到第三个之间的，他们心情好点呢，就稳住心态，大不了屏蔽瞎比比的队友，心情坏点呢，就走走死胡同，比如某局游戏想一定要杀谁谁谁一次。<br>　　不需要我说，你也能知道，最后一类人是对游戏有巨大帮助的。如果一个人总是能使争吵的队友安静，能使瞎浪的队友稳住，能使焦头烂额的打野看清下一步应该做什么，能使爆炸的队友坚持不懈的偷发育，能使队友舒服等等。那这个人肯定很容易赢游戏，哪怕他技术有限。<br>　　必须要说的是，这是个技术活，怎么样让队友的心态不炸，怎么样让队友保持积极。这些都是要你去做很多小动作，才能达成的。比如，打野gank完推线，把兵都A残，让线上的人吃，自己不脏兵。比如要吃蓝了，提前20S告诉中，让别人有时间推线。比如你是队友，看到打野在打野，你没事做随手帮忙输出一点。比如自己失误之后，承认说一句我的。比如把“中单你是瞎子吗？为什么不帮我？”换成“中单兄弟，我在野区打架的时候没有你打不过，请你多帮帮我”。再比如青蛙的日常大哥等等。这些都是很实际的东西，不是鸡汤也不是空谈，但其中每一个都对心态有非常重要的影响。说白了，高分段的人，他哪怕不能鼓励队友，也绝对不会说些消极的影响别人心情的话。<br>　　克制自己是至关重要的，我之前说的，死了一次之后绝对不能在对线期死第二次，这其实是一个心态问题，也许别人为了杀你没了双招，而你觉得能杀，刚T回线上被对面等着的打野又干死一次，你自己的对线就提前宣告结束了。很多东西看上去是技术或者战略问题，但其实很大一部分都是心态问题。<br>　　有的人连续被队友坑了之后就会很不爽，认为我啥都不管，我一定要自己C，然后你就在排位中发现了不帮你抗野怪甚至不帮你打野怪的队友；你发现了求他帮你看看野怪有没有被偷，他还是不去的队友；你发现了一个玩发条为了压制对手劫不带完美时机的队友；你发现了一个线都推到对面二塔都不愿意看一眼在野区被追的你的队友。首先，我们不愿意遇到这样的人我想任何人都是一样的，其次，自己想C绝对是没问题的。但是一定要熟知什么叫C，不是说你线上单杀对面，甚至还顺便双杀打野就是C了，而是说你在适当的实际，把你当时该做的事情完美的完成，并能促使你的队友也能更好地完成他的任务，这才是C。知乎上有人评价DOPA如何强，他说：DOPA 对线很完美，你感觉他的卡牌前期也不杀人也不怎么，光是对线，然后选择机会支援两拨，游戏就带着大优势结束了。如果说，之前瞬间爆炸类的解说视频是激励你如何对线打过对手，那 DOPA 如何玩这个游戏才是一个中单真正应该学习的获胜之道。</p>
<p style="text-align: center;"><b>… 待续 …</b></p>






]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　从S3到S8，不知不觉的，我已经开启了在召唤师中第六个赛季的旅程。虽不敢说自己的技术是一直都在进步的，但我的游戏理解绝对是已经进步到了一个比大部分人都高的位置。这其中离不开我多年观看解说教学视频，观看比赛，观看直播以及不断地实践。令人遗憾的是，我并没有一个令人尊敬的段位，因为在游戏中我有很多自己知道该做好，但是还是没有做好的事。这并不影响我分享自己的经验，毕竟，哪怕是失败的经验也能成为很好的学习素材。下面，我将分享自己在LOL世界中的五年所学。&lt;br&gt;
    
    </summary>
    
      <category term="LOL" scheme="http://jasonzou.me/categories/LOL/"/>
    
    
  </entry>
  
  <entry>
    <title>加州招待所-神雕乐队</title>
    <link href="http://jasonzou.me/2017/05/29/%E5%8A%A0%E5%B7%9E%E6%8B%9B%E5%BE%85%E6%89%80-%E7%A5%9E%E9%9B%95%E4%B9%90%E9%98%9F/"/>
    <id>http://jasonzou.me/2017/05/29/加州招待所-神雕乐队/</id>
    <published>2017-05-29T11:52:23.000Z</published>
    <updated>2017-05-29T13:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>welcome to the hotel California <br> <strong>hotel California via Eagles</strong> </p>
</blockquote>
<p>　　hotel California 是一首深受老一代人喜爱的经典歌曲。大多人喜欢它是因为好听，并且它很适合当车载音乐。少数是因为歌词引发了听众的某些共鸣。<br><a id="more"></a><br>　　我想说的和 hotel California 这首歌并没有特别必要的关联。<br>　　但是还是有一些关联的——关于自由。<br>　　hotel California 中的 hotel 暗喻深陷于“物质”中的社会。光鲜的生活后是自我的丢失，糜烂的生活下，人们丢失了“自由”，“激情”和“信念”。<br>　　物质至上的社会中“信念”是没有意义的。你需要的不是坚持，而是随时做出“正确”的选择。<br>　　“激情”也是没有意义的，冷静的人才能最快的获得最多的“物质”。<br>　　更不要谈“自由”了。<br>　　关于“自由”，很多人存在误解，“自由”绝非为所欲为，自由的人并非没有束缚。自由的人自己束缚自己，而真正有胆识和魄力去追求自由的人，其对自己的驾驭能力以及他自己对于自身的束缚往往是极为出众和强烈的。<br>　　我看到了穿着内裤上台献唱的 guns and roses ，他的那条鲜红的内裤让我突然有了一个大概毫不相关的问题：如果，自由的人对自己的规则站在了社会规则的对立面该怎么办？其实于我而言这不是一个问题。换一个问法，倘若一个人的追求的事物不是别人允许他追求的事物该怎么办？<br>　　对于这个问题，我的回答也有些答非所问，hotel California 前两句就唱到：On a dark desert highway cool wind in my hair, warm smell of colitas rising up through the air. colitas 是西班牙语，是在美国年轻人中极为流行的大麻。而这里说的大麻的香气飘荡的地方，指的是 hotel California ，也就是深陷于“物质”中的社会。这个社会有一种神奇的魔力，这种魔力让人昏沉，产生幻觉而后又飘飘欲仙，最终丢失自我。<br>　　所谓的实业家们创造的崇尚物质的社会，是反对毒品的，这个社会有它自己特有的毒品：香车，美女，帅哥，归根到底，钱所象征的物质，就是这个时代的毒品。他们先是反对毒品，然后又醉心于一些无异于毒品的追求。<br>　　不吸食毒品，是因为毒品可能会让你丢失你真正所想要追求的东西。为什么说“可能”，是因为有人真的追求的就是吸毒，并最终死在吸毒的过程中。而倘若别人对你的束缚，或者对你的“教育”，也会像毒品一样，试图赋予你一些它想赋予你的志趣，不管这个志趣是帮扶弱小，维护和平，尊老爱幼或是别的什么，总之他最终让丢失你真正想追求的东西。你是不是还是会毫无疑虑地接受你的国家甚至你的家庭对你的塑造？<br>　　他们对你唱到：welcome to hotel California, such a lovely place, such a lovely face. 这里的每个人都载歌载舞，这里欢声笑语。然后你也开始成为欢声笑语的一部分，丧失“自由”，丧失只属于自己的“激情”和“信念”。<br>　　但其实我是痛恨自由的。这是一种根本不能带给你快乐的东西。有人把自由比喻成翅膀，幻想自由就是为所欲为，对自由充满离谱的臆想和无知的向往。殊不知它更像是断掉的腿。自由的人是危险的，不健全的，自由不是一种高尚的属性，而是人类在进化中出现的一种华丽而炫目的残疾。<br>　　曾经看到有个人做过一个精彩的比喻。问：为什么有些人觉得哲学索然无味，而有些人对哲学极为痴迷。答：因为哲学是药，爱好思考的人是病患。生病的人才需要吃药。没病的人不需要吃药。<br>　　自由也是类似的，这其实是一种无法治愈的疾病。没有患病的人对其存在着误解，就像对思索没有兴趣的人对哲学会抱有错觉一样。<br>　　当你从 hotel California 夺门而出的那一刻开始，痛苦和迷惘就会开始成为生命的主旋律。你丧失了麻痹自己的能力，不能沉溺进别人给你营造的温柔乡中。<br>　　陷入孤独，然后避开其他的人，你是空间中唯一的一个点。只有唯一的一个点才是自由的，如果只有一个点，那么坐标轴不管怎么定，点的位置都是不会改变的，改变坐标轴，点也是从没有位置到没有位置。<br>　　没有坐标轴的唯一一个点，怎么可能不迷茫，不孤独。<br>　　最可怕的是，如果让你再选择一次，要不要成为一个自由的人，你不可能拒绝。哪怕你憎恶它，抗拒它，你也无法逃脱它对你的吸引。<br>　　这是最完美的毒药，让所有尝过它的人都愿意死在它手里，不论多少次，都愿意死在它手里。</p>
<p style="text-align: center;"><b>… End …</b></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;welcome to the hotel California &lt;br&gt; &lt;strong&gt;hotel California via Eagles&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　hotel California 是一首深受老一代人喜爱的经典歌曲。大多人喜欢它是因为好听，并且它很适合当车载音乐。少数是因为歌词引发了听众的某些共鸣。&lt;br&gt;
    
    </summary>
    
      <category term="胡诌" scheme="http://jasonzou.me/categories/%E8%83%A1%E8%AF%8C/"/>
    
    
      <category term="音乐" scheme="http://jasonzou.me/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>入门函数式编程</title>
    <link href="http://jasonzou.me/2017/05/12/%E5%85%A5%E9%97%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://jasonzou.me/2017/05/12/入门函数式编程/</id>
    <published>2017-05-12T02:50:03.000Z</published>
    <updated>2017-05-12T06:40:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先想说"><a href="#首先想说" class="headerlink" title="首先想说"></a>首先想说</h3><p>　　三个月前，公司有前辈向我建议，应该学习一下函数式编程。三个月来，在有空的时候会看看函数式编程相关的博客、教程和书籍，但一直没有花时间整理自己所学。四天前，仔细思考了一下自己对函数式编程思想的理解，发现其在我脑中完全处在一个混沌的状态，因此打算借这两周任务较少，完成一次对函数式编程的入门，并写下本文作为记录。<br>　　本文主要记录了：什么是函数式编程、为什么要进行函数式编程和如何学习和使用函数式编程三个问题。考虑到我立志做一个前端工程师，应用和举例时，我会尽可能的使用 JavaScript 语言。<a id="more"></a></p>
<h3 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h3><h4 id="简单地说，什么是函数式编程"><a href="#简单地说，什么是函数式编程" class="headerlink" title="简单地说，什么是函数式编程"></a>简单地说，什么是函数式编程</h4><p>　　函数式编程是一种编程范式。常见的编程范式有：命令式编程、逻辑式编程和函数式编程。而常见的面向对象编程也是一种命令式编程。<br>　　命令式编程是面向计算机硬件的抽象，有变量（对应着存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令）。用一句话总结：命令式程序就是一个冯诺依曼机的指令序列。<br>　　而函数式程序是面对数学的抽象，将计算描述为一种表达式求值。用一句话总结：函数式程序就是一个表达式。<br>　　值得一提的是：函数式编程的“函数”并非编程语言中的函数，而是数学领域的函数——是自变量的映射。<br>　　函数式编程有几大特征：函数是一等公民、函数无副作用、变量不变和闭包。</p>
<h4 id="什么是一等公民的函数"><a href="#什么是一等公民的函数" class="headerlink" title="什么是一等公民的函数"></a>什么是一等公民的函数</h4><p>　　程序世界中，有且不仅有这么几种权力：创建、赋值和传递。<br>　　非一等公民的函数是不具备这些权利的，只能依附拥有这些权力的 object 才可以完成这些操作。而一等公民的函数就不需要依托 object 完成这一系列操作。<br>　　以 JavaScript 为例，JavaScript 中，函数是一等公民。因此我们可以直接对函数进行赋值，传值等操作（ JavaScript 中，函数本身也是对象）。我们甚至可以把函数作为参数传递给别的函数。比如大家从初学前端就会用的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> clickHandler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'我是一等公民。'</span>)；</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> someBtn = <span class="built_in">document</span>.querySelector(<span class="string">'.someBtn'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 我们在此可以将 clickHandler 函数直接作为参数传递给 addEventListener 函数。</span></div><div class="line">someBtn.addEventListener(<span class="string">'click'</span>, clickHandler);</div></pre></td></tr></table></figure></p>
<h4 id="什么是无副作用的函数"><a href="#什么是无副作用的函数" class="headerlink" title="什么是无副作用的函数"></a>什么是无副作用的函数</h4><p>　　无副作用的函数又可以叫做纯函数（ pure function ）。它是指同时满足以下两个条件的函数：</p>
<ul>
<li>函数的结果只依赖于输入的参数且与外部系统状态无关——只要输入相同，返回值总是不变的。</li>
<li>除了返回值外，不修改程序的外部状态（比如全局变量、入参）。——满足这个条件也被称作“没有副作用 (side effect)”。</li>
</ul>
<p>　　函数式编程中常提到“引用透明”，“引用透明”就是指：如果一个表达式，对于相同的输入，总是有相同的结果并且不修改程序其他部分的状态，那么这个表达式是引用透明的。<br>　　因为函数式编程建议甚至强制使用纯函数，所以函数式程序是不需要维护状态的。这是其优势之一。
　　</p>
<h4 id="什么是无污染的变量"><a href="#什么是无污染的变量" class="headerlink" title="什么是无污染的变量"></a>什么是无污染的变量</h4><p>　　无污染的变量和纯函数是结对出现的。变量无法被改变，所有声明的变量都是作为数学定义中的变量，而非一块存储区域。因此，变量包括“对象”的状态是无法被修改的。</p>
<h4 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h4><p>　　闭包就不在这里详细讲说了，相信有 JavaScript 基础的同学是很清楚闭包原理的。</p>
<h3 id="为什么要使用函数式编程"><a href="#为什么要使用函数式编程" class="headerlink" title="为什么要使用函数式编程"></a>为什么要使用函数式编程</h3><h4 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h4><p>　　CPU 的发展已经不满足摩尔定律了，因此现代 CPU 的性能提升主要是依赖增加其核心数，多线程编程是大势所趋。而传统面向对象编程对于多线程的支持非常无力，状态维护成本高。而函数式编程中不存在状态，因为多个线程之间不需要共享状态，不会造成资源争用，也就不需要用锁来保护可变状态。也就不会出现死锁。这样有利于在对称多处理器架构下尽可能多的使用到各个处理器（核），提高程序的并行处理能力。<br>　　除此之外，函数式编程是使用的数学思想，更贴近人类语言，可读性和可维护性都是极高的。<br>　　当然，函数式编程对程序员更友善也是有代价的，和机器语言的差别导致函数式编程很不擅长处理 IO ，也不擅长维护状态（这是当然的）。</p>
<h3 id="如何学习和使用函数式编程"><a href="#如何学习和使用函数式编程" class="headerlink" title="如何学习和使用函数式编程"></a>如何学习和使用函数式编程</h3><h4 id="我也不是一个熟练的使用者"><a href="#我也不是一个熟练的使用者" class="headerlink" title="我也不是一个熟练的使用者"></a>我也不是一个熟练的使用者</h4><p>　　前几天我花了不少时间搞清楚到底什么是函数式编程，这种编程范式到底是要做什么事。但是对于怎么使用函数式编程，我甚至不敢以“入门”自居，只敢说是刚从门外汉转变为一个初学者，在这里给大家分享一些学习资料为主。</p>
<h4 id="阮一峰老师的函数式编程入门："><a href="#阮一峰老师的函数式编程入门：" class="headerlink" title="阮一峰老师的函数式编程入门："></a>阮一峰老师的函数式编程入门：</h4><p>　　<a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="external">函数式编程入门教程</a>：本文中阮老师主要给大家介绍了函数式编程的数学理论源头。如果是真心想深入学习函数式编程的同学，兴许可以从这篇文章中找到门路。</p>
<h4 id="阮一峰老师的图解-Monad-："><a href="#阮一峰老师的图解-Monad-：" class="headerlink" title="阮一峰老师的图解 Monad ："></a>阮一峰老师的图解 Monad ：</h4><p>　　<a href="http://www.ruanyifeng.com/blog/2015/07/monad.html" target="_blank" rel="external">图解 Monad</a>：Monad 是学习函数式编程所绕不开的一环，它也曾让阮老师感到困惑，这里是阮老师的一篇非常好的介绍 Monad 的文章。</p>
<h4 id="JavaScript-的函数式编程："><a href="#JavaScript-的函数式编程：" class="headerlink" title="JavaScript 的函数式编程："></a>JavaScript 的函数式编程：</h4><p>　　<a href="https://blog.oyanglul.us/javascript/functional-javascript.html" target="_blank" rel="external">Functional JavaScript Mini Book</a>：关注这个作者，你能学到更多。</p>
<h4 id="JS函数式编程指南："><a href="#JS函数式编程指南：" class="headerlink" title="JS函数式编程指南："></a>JS函数式编程指南：</h4><p>　　<a href="https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details" target="_blank" rel="external">JS函数式编程指南</a>：一本中文的，JavaScript 函数式编程指南，主要讲的是怎么具体用函数式编程。</p>
<h4 id="当然，你可能还需要补充-JavaScript-的基础知识："><a href="#当然，你可能还需要补充-JavaScript-的基础知识：" class="headerlink" title="当然，你可能还需要补充 JavaScript 的基础知识："></a>当然，你可能还需要补充 JavaScript 的基础知识：</h4><p>　　<a href="https://developer.mozilla.org/cn/docs/Web/JavaScript/Closures" target="_blank" rel="external">比如，你还没有弄清楚什么是闭包</a>：闭包对于函数式编程是意义重大的，没有闭包，我就不知道怎么进行函数的科里化了。</p>
<h4 id="函数式编程的模式匹配："><a href="#函数式编程的模式匹配：" class="headerlink" title="函数式编程的模式匹配："></a>函数式编程的模式匹配：</h4><p>　　<a href="http://www.cnblogs.com/SinSay/archive/2010/09/20/1831455.html" target="_blank" rel="external">pattern matching</a>：又一个函数式编程必须掌握的技巧。</p>
<h3 id="最后想说"><a href="#最后想说" class="headerlink" title="最后想说"></a>最后想说</h3><p>　　本文引用了大量的知乎内容，由于引用知乎流程太麻烦了，我就不写引用了。这是不对的。我知道。<br>　　我认为函数式编程在将来很可能成为一种程序员非常值得掌握乃至必须掌握的编程范式。很有学习的意义，我非常希望本文不是你了解函数式编程的终点而是起点。</p>
<h4 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h4><p>　　如果希望自己不再对诸如函数式编程这样的“突然兴起”的技术感到懵逼或是迷茫。你需要一本 SICP 。我认为每一个真正的程序员都应该通读并理解 SICP 。</p>
<p style="text-align: center;"><b>… End …</b></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;首先想说&quot;&gt;&lt;a href=&quot;#首先想说&quot; class=&quot;headerlink&quot; title=&quot;首先想说&quot;&gt;&lt;/a&gt;首先想说&lt;/h3&gt;&lt;p&gt;　　三个月前，公司有前辈向我建议，应该学习一下函数式编程。三个月来，在有空的时候会看看函数式编程相关的博客、教程和书籍，但一直没有花时间整理自己所学。四天前，仔细思考了一下自己对函数式编程思想的理解，发现其在我脑中完全处在一个混沌的状态，因此打算借这两周任务较少，完成一次对函数式编程的入门，并写下本文作为记录。&lt;br&gt;　　本文主要记录了：什么是函数式编程、为什么要进行函数式编程和如何学习和使用函数式编程三个问题。考虑到我立志做一个前端工程师，应用和举例时，我会尽可能的使用 JavaScript 语言。
    
    </summary>
    
      <category term="编程语言知识杂烩" scheme="http://jasonzou.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="函数式编程" scheme="http://jasonzou.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>用LESS升级CSS</title>
    <link href="http://jasonzou.me/2017/05/03/%E7%94%A8less%E4%BB%A3%E6%9B%BFcss/"/>
    <id>http://jasonzou.me/2017/05/03/用less代替css/</id>
    <published>2017-05-03T11:42:06.000Z</published>
    <updated>2017-05-04T03:44:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Brevity is the soul of wit. <br> <strong>William Shakespeare</strong> </p>
</blockquote>   
<p>　　学习了一下 LESS 的使用，在此简单记录用法，并总结一下自己的思考。<a id="more"></a></p>
<h3 id="为什么使用预编译工具？"><a href="#为什么使用预编译工具？" class="headerlink" title="为什么使用预编译工具？"></a>为什么使用预编译工具？</h3><p>　　我本打算将文章命名为“用 LESS 替代 CSS ”。但发现这样的说法很不合理，LESS 是一个 CSS 预编译工具，和其他的 CSS 预编译工具一样，它们的工作是基于 CSS 的。我的理解是，它们就像 ES2015 为 ES5 所提供的诸多语法糖一样，并非替代 CSS ，而是“升级” CSS 。总之使用预编译工具的目的，在我看来有两点：</p>
<ul>
<li>让 CSS 代码更 DRY 。</li>
<li>让前端们写CSS时更加得心应手。</li>
</ul>
<h3 id="为什么使用-LESS-而不是-SASS-或-Stylus"><a href="#为什么使用-LESS-而不是-SASS-或-Stylus" class="headerlink" title="为什么使用 LESS 而不是 SASS 或 Stylus ?"></a>为什么使用 LESS 而不是 SASS 或 Stylus ?</h3><p>　　先说前两个。 LESS 和 SASS 很像：LESS 是其作者受到 SASS 的启发后开发而出的。但二者之间还是略有区别，首先 SASS 的 Scope 和别的编程语言不类似，变量“查值”时不是逐级向“外层”找的，而是直接“扁平”地向上找的。换种说法，可以理解为所有的变量都是全局变量。与之相对的 LESS 则是逐级向“外层”查找变量的。这让我这种写JS的程序员看着闹心，这是从感情上讲不喜欢 SASS 的原因。此其一。第二：SASS 不能兼容 CSS 。这是让我觉得最尴尬的地方。虽然在进行改进更新之后还是兼容了。但是，这种行为让我怀疑其开发者的思路。看《JavaScript DOM 编程艺术》后，我明白了“平稳退化”的重要性。但 SASS 的行为违背了这种思想。同样是进行改进工作的 TypeScript ，作为 JavaScript 的超集，完全兼容 JavaScript 。对比之后，高下立判（也许是我对这个问题的认识还不够，理解不了其作者的意图吧）。第三：SASS 功能“过于”强大了。它甚至支持 IF 和 FOR 。。。我不明白这是要做什么。从我刚开始学前端开始，我就被前辈训诫要记住一些基本的原则，其中包括：前端开发中应尽可能的保持结构、样式和功能分离。(X)HTML 文档负责结构，CSS 负责样式，JavaScript 负责功能。条件判断真的是需要由 CSS 来做的工作吗？除非是一个真的几乎不需要写 JavaScript 的项目，那用 SASS 写一些逻辑我认为可以理解。但如果是普通的项目我实在是不认为应该把逻辑交由 CSS 来写。<br>　　看到这里，也应该明白我为什么不愿意用 Styules 了。和上述的第三点是一样的，Stylus 打着更贴近 JavaScript 的旗号，吸了不少粉。为什么 CSS 需要更贴近 JavaScript ，那我们为什么要 JavaScript ？还是说作者有更美好的愿景准备把 JavaScript 淘汰掉或者退一步讲只是准备在 某些场景完全淘汰掉 JavaScript ？我不明白，我不理解。<br>　　当然不是说 SASS 和 Styuls 不好，我只是说我不理解，我不理解所以不用，毕竟眼看着就要过了可以随心所欲不求甚解囫囵吞枣的年纪和阶段了。<br>　　话又说回来， LESS 在经历更新后也增加了对 IF 等条件判断语句的支持，让 CSS 更像一门普通的编程语言。但，我认为 LESS 的初衷更符合我对我所做之事的理解。所以我用 LESS 。题外话：于我而言，这个选择也是对于戒骄戒躁不浮夸不虚伪的努力践行。</p>
<h3 id="LESS-用法"><a href="#LESS-用法" class="headerlink" title="LESS 用法"></a>LESS 用法</h3><h4 id="安装为可执行文件"><a href="#安装为可执行文件" class="headerlink" title="安装为可执行文件"></a>安装为可执行文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install less -g（以全局安装为例）</div></pre></td></tr></table></figure>
<p>　　安装完毕后，直接在命令行使用就行了，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ lessc bootstrap.less bootstrap.css</div><div class="line">//将.less 文件编译为.css 文件</div></pre></td></tr></table></figure></p>
<p>　　options 在这里查看：<a href="http://less.bootcss.com/usage/" target="_blank" rel="external">命令行用法</a></p>
<h4 id="配合webpack使用"><a href="#配合webpack使用" class="headerlink" title="配合webpack使用"></a>配合webpack使用</h4><ul>
<li>安装 less-loader 。</li>
<li>阅读 webpack <a href="http://zhaoda.net/webpack-handbook/configuration.html" target="_blank" rel="external">文档</a>。</li>
</ul>
<h4 id="更多使用方法"><a href="#更多使用方法" class="headerlink" title="更多使用方法"></a>更多使用方法</h4><p>　　如果前两种都不能满足需求可以去查<a href="http://less.bootcss.com/usage/" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="LESS-特性"><a href="#LESS-特性" class="headerlink" title="LESS 特性"></a>LESS 特性</h3><p>　　在这里简单记录一下 LESS 的主要特性。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>　　可以用 @ 定义变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">// Variables</div><div class="line">@link-color:        #428bca; // sea blue</div><div class="line">@link-color-hover:  darken(@link-color, 10%);</div><div class="line"></div><div class="line">// 用法</div><div class="line">a,</div><div class="line">.link &#123;</div><div class="line">  color: @link-color;</div><div class="line">&#125;</div><div class="line">a:hover &#123;</div><div class="line">  color: @link-color-hover;</div><div class="line">&#125;</div><div class="line">.widget &#123;</div><div class="line">  color: #fff;</div><div class="line">  background: @link-color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 1.4.0 之后还支持：</div><div class="line">// Variables</div><div class="line">@mySelector: banner;</div><div class="line"></div><div class="line">// Usage</div><div class="line">.@&#123;mySelector&#125; &#123;</div><div class="line">  font-weight: bold;</div><div class="line">  line-height: 40px;</div><div class="line">  margin: 0 auto;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Variables</div><div class="line">@images: &quot;../img&quot;;</div><div class="line"></div><div class="line">// 用法</div><div class="line">body &#123;</div><div class="line">  color: #444;</div><div class="line">  background: url(&quot;@&#123;images&#125;/white-sand.png&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Variables</div><div class="line">@themes: &quot;../../src/themes&quot;;</div><div class="line"></div><div class="line">// Usage</div><div class="line">@import &quot;@&#123;themes&#125;/tidal-wave.less&quot;;</div><div class="line"></div><div class="line">// 1.6.0 之后支持：</div><div class="line">@property: color;</div><div class="line"></div><div class="line">.widget &#123;</div><div class="line">  @&#123;property&#125;: #0ee;</div><div class="line">  background-@&#123;property&#125;: #999;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　LESS 中，变量是懒加载的，所以先后定义变量不影响编译时查值。此外：LESS 作用域和 JavaScript 基本相同。</p>
<h4 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h4><p>　　CSS 类中可以嵌套 CSS 类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">// input</div><div class="line">.a, #b &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line">.mixin-class &#123;</div><div class="line">  .a();</div><div class="line">&#125;</div><div class="line">.mixin-id &#123;</div><div class="line">  #b();</div><div class="line">&#125;</div><div class="line">//output</div><div class="line">.a, #b &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line">.mixin-class &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line">.mixin-id &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 注意对比： </div><div class="line">// input</div><div class="line">.my-mixin &#123;</div><div class="line">  color: black;</div><div class="line">&#125;</div><div class="line">.my-other-mixin() &#123;</div><div class="line">  background: white;</div><div class="line">&#125;</div><div class="line">.class &#123;</div><div class="line">  .my-mixin;</div><div class="line">  .my-other-mixin;</div><div class="line">&#125;</div><div class="line">// output</div><div class="line">.my-mixin &#123;</div><div class="line">  color: black;</div><div class="line">&#125;</div><div class="line">.class &#123;</div><div class="line">  color: black;</div><div class="line">  background: white;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 可以带参数使用：</div><div class="line">// input</div><div class="line">.border-radius(@radius) &#123;</div><div class="line">  -webkit-border-radius: @radius;</div><div class="line">     -moz-border-radius: @radius;</div><div class="line">          border-radius: @radius;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#header &#123;</div><div class="line">  .border-radius(4px);</div><div class="line">&#125;</div><div class="line">.button &#123;</div><div class="line">  .border-radius(6px);</div><div class="line">&#125;</div><div class="line"></div><div class="line">.border-radius(@radius: 5px) &#123;</div><div class="line">  -webkit-border-radius: @radius;</div><div class="line">     -moz-border-radius: @radius;</div><div class="line">          border-radius: @radius;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 你甚至可以：</div><div class="line">.mixin() &#123;</div><div class="line">  @width:  100%;</div><div class="line">  @height: 200px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.caller &#123;</div><div class="line">  .mixin();</div><div class="line">  width:  @width;</div><div class="line">  height: @height;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　这是一个非常方便的功能，但是输出的 CSS <a href="http://www.cnblogs.com/kidsitcn/p/4916767.html" target="_blank" rel="external">不够DRY</a>。我们需要 Extend 。</p>
<h4 id="Extend"><a href="#Extend" class="headerlink" title="Extend"></a>Extend</h4><p>　　Extend 和 Mixin 类似，但输出不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//仔细和上面的例子对比：</div><div class="line">// input</div><div class="line">nav ul &#123;</div><div class="line">  &amp;:extend(.inline);</div><div class="line">  background: blue;</div><div class="line">&#125;</div><div class="line">.inline &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line">// output</div><div class="line">nav ul &#123;</div><div class="line">  background: blue;</div><div class="line">&#125;</div><div class="line">.inline,</div><div class="line">nav ul &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><p>　　所谓的高级用法，就是条件判断，循环等语法。我是不那么支持过多使用这些语法的，复杂的项目中过多的使用这些东西会让 UI 部分的代码很难维护。如果要学习的话，移步<a href="http://less.bootcss.com/features/" target="_blank" rel="external">官方文档</a>吧。</p>
<p style="text-align: center;"><b>… End …</b></p>

<p>　　
　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Brevity is the soul of wit. &lt;br&gt; &lt;strong&gt;William Shakespeare&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;   
&lt;p&gt;　　学习了一下 LESS 的使用，在此简单记录用法，并总结一下自己的思考。
    
    </summary>
    
      <category term="工具使用技巧" scheme="http://jasonzou.me/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="webpack" scheme="http://jasonzou.me/tags/webpack/"/>
    
      <category term="css" scheme="http://jasonzou.me/tags/css/"/>
    
      <category term="前端工程化" scheme="http://jasonzou.me/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>风行水上，自然成纹</title>
    <link href="http://jasonzou.me/2017/04/24/%E9%A3%8E%E8%A1%8C%E6%B0%B4%E4%B8%8A%EF%BC%8C%E8%87%AA%E7%84%B6%E6%88%90%E7%BA%B9/"/>
    <id>http://jasonzou.me/2017/04/24/风行水上，自然成纹/</id>
    <published>2017-04-24T13:46:39.000Z</published>
    <updated>2017-05-03T16:39:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>风行水上，自然成纹。 <br> <strong>朱光潜</strong> </p>
</blockquote>
<p>　　美是什么？<br>　　美是擦身而过后仍然如挂在眼角上的水珠般水灵的姑娘；美是入耳后让人驻足顾盼心生向往的笛鸣；美是求婚时含在嘴里的玫瑰和玫瑰一样兴奋脸红的准新娘；美是苦苦等待后终于从地平线下渗出的朝阳；美也是晚霞映衬下一支微<a id="more"></a>微颤烁的发簪；美可以是“烟笼寒水月笼沙”；美也可以是“大漠孤烟直，长河落日圆。”；有人说美是斑驳如老人皱纹般的古树之经络；也有人说美是如古树般沧桑的老人的皱纹。<br>　　美是难以用例子穷尽的。不论是文字，乐曲，图画这种人为之物还是某一个人，某一棵树，某一座山，某一颗星球这种自然之物，都可能蕴藏着所谓的美。<br>　　“美”这个字本身是人类语言匮乏的证明，但难以表达传播本身也是美的一大特征。<br>　　如此抽象之物就不多去给它下些苍白乏味的定义了。<br>　　朱光潜先生说：美的本质不是孤立的。<br>　　试图去定义它，必须要考虑所处时期的各种背景。此等繁杂且专业之事并非我想说的。<br>　　如何创造美更让我好奇。<br>　　美不是自然，如果说自然的就是美的，那么“创造美”也就无从谈起了。自然不是美，但自然却可被称为美的土壤。人的意愿是种子，人的抽象是培植。<br>　　创造美应是一种邂逅。<br>　　心境和所处之处能交织共鸣时，美就播下了种子。而之后是匠人的雕刻，诗人的吟诵，钢琴家的哆啦咪发，书法家的纵情挥毫，让美绽放并刻录进每一份作品之中。<br>　　并不是说只有作家才有能力创造美，有时美也可以是印在瞳孔上的影子，可以是环绕耳畔的鸟鸣。只是说，作家更擅长记录和传播美。<br>　　我想学会如何创造和传播美。<br>　　这便是我的读后感。<br>　　“创造美”突然间就成了我非常想做的事。<br>　　这源于我对自己和身边人的愧疚。<br>　　我实在不是什么美的东西，但我能看见我身边的人包括我自己对于各种“美”的期待。而和我的相处难免会误了不少本属于她们的与美相遇的机会，那我理应用上自己的浑身解数去记录下并分享一些美的东西给她们和我自己。<br>　　这算是一种严肃而要紧的救赎。<br>　　再回到“如何创造美”上。<br>　　朱光潜先生在书中给出了他的见解。<br>　　我总结大致为：美是不可强求的。灵感所至之时，用恰当的匠人技法，将其发挥和记录即可。<br>　　技法是重要的，不论是书法，写作，创作乐曲，作画还是别的所有创造，都需要一定的技法支持。这一点只能多做学习，勤加磨练了。<br>　　而我认为最值得我记住的是：美不可强求。<br>　　“乘兴而来，兴尽而返”<br>　　如前文所说的，美是邂逅。随灵感而来，你若不握紧并雕琢之，她很快就会随时间的流沙而返。<br>　　因此，好美之人理应把握和珍惜灵感。<br>　　与此同时，光是匠人之工巧，是不足以创造美的，没有灵感的卖弄，只会让人尴尬作呕，避退不及。<br>　　因此，好美之人理应适时放手。决不可为作文而作文。<br>　　所谓：风行水上，自然成纹。<br>　　我希望我至少在这片小小的夹缝中，我所有的文字都能是行云和流水，都是风划过我心中时，自然留下的波纹。</p>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;风行水上，自然成纹。 &lt;br&gt; &lt;strong&gt;朱光潜&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　美是什么？&lt;br&gt;　　美是擦身而过后仍然如挂在眼角上的水珠般水灵的姑娘；美是入耳后让人驻足顾盼心生向往的笛鸣；美是求婚时含在嘴里的玫瑰和玫瑰一样兴奋脸红的准新娘；美是苦苦等待后终于从地平线下渗出的朝阳；美也是晚霞映衬下一支微
    
    </summary>
    
      <category term="感" scheme="http://jasonzou.me/categories/%E6%84%9F/"/>
    
    
      <category term="灵感" scheme="http://jasonzou.me/tags/%E7%81%B5%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于如何抽时间做自己不想做的事</title>
    <link href="http://jasonzou.me/2017/04/23/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%8A%BD%E6%97%B6%E9%97%B4%E5%81%9A%E8%87%AA%E5%B7%B1%E4%B8%8D%E6%83%B3%E5%81%9A%E7%9A%84%E4%BA%8B/"/>
    <id>http://jasonzou.me/2017/04/23/关于如何抽时间做自己不想做的事/</id>
    <published>2017-04-23T07:04:36.000Z</published>
    <updated>2017-04-23T08:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　写这篇文章是基于我现在十分困扰的现状。现状指：最近的一周中，我尝试在下班之后抽时间复习学校里的功课准备补考，发现并没有办法找到时间和状态。没有办法找到时间和状态的原因主要有：我计划要自己做饭填饱自己占用了下班到九点过的时间，人比较困乏，没有足够的动力。<br>　　简单思考一下后，我认为：时间的问题还是可以解决的，以后回家路上买好吃的面包就行了。人比较困乏，这个只能尽量早上床了。没有足够的动力这才是核心的问题所在。<br><a id="more"></a><br>　　事实上，没有足够的动力，也意味着只要稍微有点困乏我就不会去看书学习。这是我从小到大都一直头疼的问题：如何抽时间做自己不想做的事？<br>　　倘若是我主观上想去做的事，那没有条件我会想办法去创造条件，或者条件不好我也能忍受。但面对不想做的事，这实在是难以骗自己去好好做。我有时候甚至会问自己，我到底值不值得为了个毕业证逼自己去学这些没用的课程。毕业证是不是真的有那么重要的以至于我要花费我我宝贵的下班时间和宝贵的玩游戏的时间去学习课本知识以获取。<br>　　可是人这一辈子，总是会遇到必须要做自己不想做的事的情况。因而我有理由而且有必要思考一下，遇到这种情况时，该怎么办。<br>　　我在我的计划列表的开头引用了：欲取其中必求其上…但是，在这次的实习中，我发现了一个让我很无奈的规律，以最近的一个任务为例：组长说，给你一个任务，下周二前做完，于是我给自己定了个目标——周二前尽量做完，而后我在周二完成了七成，之后一直修补，直到第二周周四才完全做完。这哪里是欲取其中必求其上啊？这分明是欲取其中必求上上，而后可得其下啊。真心而言：我并不为这件事感到沮丧。倒不如说，我找到了一个做不愿做的事时的一个时间轴。先给自己找个距离deadline比较远的时间点为目标开始工作，到了deadline求别人宽限点时间大概就能做完那件事了。<br>　　所以我在想，倘若再让我订一次学习目标，那么我要要求自己以八十分为基准，提前一个月全部复习完，那我可能最后考试可以及格。<br>　　区别还是有的：我认为自己对公司给的活是尽心尽力的，公司的活在主观上根本不算是不想做的事。<br>　　拿公司的经历做比是因为公司的活要比重修难不少，算上我自己的怠惰之后，其实两者的难度是差不多的。<br>　　因此不妨，以后就这么去订目标，指不定，我真的可以在有生之年拿到这个我还没想清楚拿来做什么的毕业证。暂且试一试吧。<br>　　还是没办法想到一个合适的解决方案。只靠我自己的话，暂时还没有办法让自己坚持做自己不想做的事。<br>　　太难了。</p>
<p style="text-align: center;"><b>… 待续 …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　写这篇文章是基于我现在十分困扰的现状。现状指：最近的一周中，我尝试在下班之后抽时间复习学校里的功课准备补考，发现并没有办法找到时间和状态。没有办法找到时间和状态的原因主要有：我计划要自己做饭填饱自己占用了下班到九点过的时间，人比较困乏，没有足够的动力。&lt;br&gt;　　简单思考一下后，我认为：时间的问题还是可以解决的，以后回家路上买好吃的面包就行了。人比较困乏，这个只能尽量早上床了。没有足够的动力这才是核心的问题所在。&lt;br&gt;
    
    </summary>
    
      <category term="最无用的东西" scheme="http://jasonzou.me/categories/%E6%9C%80%E6%97%A0%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>【转载】JavaScript中的上下文，我的认识的三个阶段</title>
    <link href="http://jasonzou.me/2017/04/21/%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%8C%E6%88%91%E7%9A%84%E8%AE%A4%E8%AF%86%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
    <id>http://jasonzou.me/2017/04/21/中的上下文，我的认识的三个阶段/</id>
    <published>2017-04-21T01:54:38.000Z</published>
    <updated>2017-05-26T07:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p>　　本文转自<a href="https://www.zouyesheng.com/" target="_blank" rel="external">邹业盛的博客</a>：<a href="https://www.zouyesheng.com/js-context.html" target="_blank" rel="external">Javascript 中的上下文，我的认识的三个阶段</a>。<br><a id="more"></a></p>
<p>　　js 中的 上下文 Context，可以说是一个，你即使不知道，没听过，也不影响你继续写 js 代码的一个概念。但是，它又确确实实是无所不在的一个东西，是的，无所不在。<br>从我自己的经验来看，对上下文的认识，算是分成了三个阶段，每一个阶段，都让我从外在的表现中，理解了一些更本质上的东西。</p>
<h3 id="第一阶段，不知"><a href="#第一阶段，不知" class="headerlink" title="第一阶段，不知"></a>第一阶段，不知</h3><p>　　我最开始接触 js 的时候，看到了它的 new ，看到了它的 this ，很自然地会把 js 和其它的一些 OOP 语言等同起来看待，并且，好像，也是这么回事。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Class = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ins = <span class="keyword">new</span> Class(<span class="number">1</span>);</div><div class="line">ins.add();</div><div class="line"><span class="built_in">console</span>.log(ins.a); <span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>　　上面的代码，可以按预期的那样，最后得到 2 的输出。<br>　　但是，如果仅仅是 类，实例 这种层面的认识，我无法解释下面的问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ins = <span class="keyword">new</span> Class(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> func = ins.add;</div><div class="line">func();</div><div class="line"><span class="built_in">console</span>.log(ins.a); <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>　　甚至解释不清楚下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj.add();</div><div class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>　　这里可没有<strong>类</strong>，也没有<strong>实例</strong>。<br>　　我上面的最开始对 js 的认识当中，局限就在于，把 this 理解成了 实例 。也许在其它语言中（比如 Python 常用的实例方法第一个参数 self），是这样。但是在 js 中， this 跟 实例 完全没有关系。</p>
<h3 id="第二阶段，this"><a href="#第二阶段，this" class="headerlink" title="第二阶段，this"></a>第二阶段，this</h3><p>　　当我明白问题出在 this 上，或者说，当我终于理解了 this 这个东西之后，上面的代码，再也不会困扰我了。<br>　　我知道了， js 中有一个东西叫 上下文 ，可惜的是，这时，我对上下文的概念，仅仅停留在 this 上。<br>　　这时我的理解是： this 表示的是，函数调用时的 上下文 。<br>　　说得详细一点，就是 this 不是表示的 实例 ，而是函数调用时的 上下文 。 上下文 这个东西，默认是 window ，即 全局 。但是，你可以明确地为函数指定一个 上下文 。回到 this 上，就是在定义时你根本不知道 this 是什么，因为在调用时，它可以是任何东西（因为 上下文 是可以人为指定的）。</p>
<p>　　回到刚开始的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Class = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ins = <span class="keyword">new</span> Class(<span class="number">1</span>);</div><div class="line">ins.add();</div><div class="line"><span class="built_in">console</span>.log(ins.a); <span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>　　这段代码的结构之所以是 2 ，不是因为 实例 ，而是因为 上下文 。<br>　　首先说一下 new 。 new 在 js 中，不考虑原型链，它的作用相当于是先创建了一个空的对象，然后把这个空的对象，作为 构造函数 的 上下文 ，再去执行 构造函数 ，最后再返回这个当初的空对象。即：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> what_new = <span class="function"><span class="keyword">function</span>(<span class="params">func, a</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> context = &#123;&#125;;</div><div class="line">  func.apply(context, [a]);</div><div class="line">  <span class="keyword">return</span> context;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Class = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ins = what_new(Class, <span class="number">1</span>);</div><div class="line">ins.add();</div><div class="line"><span class="built_in">console</span>.log(ins.a);</div></pre></td></tr></table></figure></p>
<p>　　当然， new 除了上面的 func.apply 的作用之外， 它还会处理原型链 ，这里就不介绍了。上面的代码仅是为了说明 new 对于所谓的构造函数做了什么事。<br>　　有了上下文，就不难解释 ins 这个东西了。所谓的构造函数，只是在指定了 this 到底是哪一个对象之后，作了相应的赋值操作而已，最后得到这个对象的返回，经过了一些赋值操作，对象中就有了新的东西了。<br>　　同样，对于一个在定义时包含了 this 的函数，比如前面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　如果来一句：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = obj.add;</div><div class="line">func(); <span class="comment">//undefined</span></div><div class="line">func.apply(&#123;<span class="attr">a</span>: <span class="number">0</span>&#125;) <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>　　这些都很容易明白了。 js 中的函数，都是一些很单纯的函数，所有的函数跟它在哪里定义完全没有关系（考虑闭包的情况除外）。所以上面的代码，虽然 add 函数是写在 obj 中的，但是，它跟你在 window 中写一个函数是 完全一样 的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.a++&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">add</span>: add</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　既然 add 函数中有 this ，那么这个函数执行时的行为，就要小心一点了。所以上面明确地指定了一个上下文给它 func.apply({a: 0}) 。<br>　　还是回到开始的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　对于上面的代码，我知道了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.add();</div></pre></td></tr></table></figure></p>
<p>　　和：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = obj.add();</div><div class="line">func();</div></pre></td></tr></table></figure></p>
<p>　　会得到不一样的结果。并且知道，这个不一样的结果是上下文引起的，还知道，后者 func() 执行时，上下文是全局的 window 了。<br>　　我虽然知道是这样的一个情况，但是，为什么？执行同一个函数结果怎么就不一样了呢？<br>　　我在很长时间里，都没有去细细考虑过这个问题。不过，因为知道了“上下文是一个在定义时无意义，其具体值完全由执行时决定”这点之后，我都尽量避免去使用 this ，实在要用，在调用时，我都会通过 apply 或 call 明确指定上下文，这样，至少不会踩坑里。</p>
<h3 id="第三阶段，一切都是上下文"><a href="#第三阶段，一切都是上下文" class="headerlink" title="第三阶段，一切都是上下文"></a>第三阶段，一切都是上下文</h3><p>　　某天，我在网上看到了这样一段代码（原始出处不知道）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bind = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Function</span>.prototype.bind)</div></pre></td></tr></table></figure></p>
<p>　　这个新定义的 bind 函数具体做什么事先不管它，我好奇的是 call.bind() 这个调用。因为 call 这个函数，之前一直以为它是 Function 对象的一个方法（它本身也是一个函数），但是，如果按“对象的方法”这个角度去想的话，那对它绑定一个上下文（ bind() 的调用 ）不就完全没有意义了么？（因为对象的方法应该是跟上下文无关的）<br>　　后来看到了这篇文章，<a href="http://www.html-js.com/article/JavaScript-functional-programming-in-Javascript-Bind-Call-and-Apply" target="_blank" rel="external">http://www.html-js.com/article/JavaScript-functional-programming-in-Javascript-Bind-Call-and-Apply</a><br>　　其中以 slice 函数举的例子让我恍然大悟：</p>
<ul>
<li>上下文控制不仅仅是 apply / call，所有的点 . ，都是在指定上下文。</li>
<li>js 中的函数比我想像的还要纯，根本没有“对象中的方法”这个东西，即使是“原生对象”中。（它仅仅起一个名字空间的作用）</li>
</ul>
<p>　　所有的函数调用，都有两层意义，比如 c.f()：</p>
<ul>
<li>f 这个函数，它在 c 中。（名字空间的问题）</li>
<li>把 c 作为 f 的上下文，去调用 f 。（前提是 f 没有绑定过上下文）如果 c 没有，则默认是 window 。</li>
</ul>
<p>　　所有的，js 中所有的函数调用，都是如此。即使是 f.call(context, x) ，我之前只看到了第一层意义（ f 中有一个 call 方法可以使用），则忽略了第二层意义 —— 把 f 作为 call 的上下文。<br>　　简单来说，我们可以相像 call 这个函数，它的代码大概是这样的（可变参数的问题先不管）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> call = <span class="function"><span class="keyword">function</span>(<span class="params">context, a</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> new_func = <span class="keyword">this</span>.bind(context);</div><div class="line">    retur new_func(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　它的作用，就是把 指定的上下文（context） 作为 自己的上下文（this） 的 上下文 ，然后再调用 自己的上下文（绑定上下文之后的 this） 。<br>　　上面一句话有些纠结哈，主要搞明白多种上下文的关系， f.call(context, x) 当中， 自己的上下文 上面是 f 。 指定的上下文 上面是 context 。<br>　　再看 f.call(context, x) 这个代码，结合“函数是单纯”这点，我想到，即使是原生对象的那些方法， 也不过是把一些单纯的函数放到了 prototype 中而已 ，比如把 call 函数放到了 Function.prototype 当中。<br>　　至此，再看 c.f() ， a.b.c() 这些，不要去想是调用 c 对象中的 f 方法（这么说没错，但是名字空间的问题是显而易见的嘛），而是想成，调用时把 c 作为 f 的上下文。<br>　　好了，回到开始的那行例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> new_bind = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Function</span>.prototype.bind)</div></pre></td></tr></table></figure></p>
<p>　　这个就非常好理解了（为了描述方便，我改成 new_bind 了），把 bind 作为上下文绑定到 call 中。<br>　　这里注意一下，绑定了上下文的 call 函数，还是 call 函数，但是 “此 call 已经非彼 call” 了。<br>　　所以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new_bind != <span class="built_in">Function</span>.prototype.call</div></pre></td></tr></table></figure></p>
<p>　　虽然调用形式上， new_bind 和 call 完全一样，但是他们的上下文行为不一样：</p>
<ul>
<li>call 是未绑定状态，所以 f.call() 会在执行时把 f 作为上下文绑定到 call 函数中。</li>
<li>new_bind 是已绑定状态，所以 f.new_bind() 对 new_bind() 的执行完全没影响。</li>
</ul>
<p>我们可以以这样的流程来帮助我们理解：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new_bind =&gt; <span class="function"><span class="params">call</span> =&gt;</span> bind.call =&gt; bind.call(f, context) =&gt; f.bind(context)</div></pre></td></tr></table></figure></p>
<p>一步一步解释：<br>　　new_bind =&gt; call：</p>
<pre><code>　　new_bind 在形式上就是 call 。
</code></pre><p>　　call =&gt; bind.call：</p>
<pre><code>　　只是这个 call ，是指定了 bind 作为它的上下文的。既然是 bind 作为它的上下文，那我们可以写成是 bind.call 的样式。
</code></pre><p>　　bind.call(f, context) =&gt; f.bind(context)：</p>
<pre><code>　　new_bind 的调用 new_bind(f, context) 就相当于是 bind.call(f, context) 。考虑 call 函数之前的行为： f.call(context, a) 是把 context 作为 f 的上下文，也就是 context.f(a) ，那么 bind.call(f, context) 对应的就是 f.bind(context) 。
</code></pre><p>　　f.bind(context)：</p>
<pre><code>　　不用多说了吧，把 context 绑定到 f 上，返回一个绑定了上下文的新函数。
</code></pre><p>　　完全是最基本的代数推导嘛，形式上，上下文前置总是没有问题的。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>　　我一直认同，要理解 js 的东西，从函数式语言入手，非常合适。硬要往面向对象的那套东西上套，太纠结了（我不管概念上到底什么样才叫面向对象，原生没有类定义，没有继承，没有实例化，就别扯这些就完了。对了，我认为原型追溯那不叫继承哈）。<br>　　当然，我不知道弄明白了最后那个“代数推导”到底有什么好处，也许没有，因为就算不明白这些也不影响我写了很多可以正常工作的 js 代码嘛。只是，我以后再写，思路上的可能会有一些不同了。比如代码组织的形式上，可以尝试把很多的小函数做到不同的“名字空间”中，然后再在业务层面，通过 Mixin 来拼出不同的业务对象。这些函数中可能到处充斥着 this ，我能控制好它们了。</p>
<p style="text-align: center;"><b>… End …</b></p>



]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原文链接&quot;&gt;&lt;a href=&quot;#原文链接&quot; class=&quot;headerlink&quot; title=&quot;原文链接&quot;&gt;&lt;/a&gt;原文链接&lt;/h3&gt;&lt;p&gt;　　本文转自&lt;a href=&quot;https://www.zouyesheng.com/&quot;&gt;邹业盛的博客&lt;/a&gt;：&lt;a href=&quot;https://www.zouyesheng.com/js-context.html&quot;&gt;Javascript 中的上下文，我的认识的三个阶段&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="前端和 JavaScript 知识总结" scheme="http://jasonzou.me/categories/%E5%89%8D%E7%AB%AF%E5%92%8C-JavaScript-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://jasonzou.me/tags/JavaScript/"/>
    
      <category term="this" scheme="http://jasonzou.me/tags/this/"/>
    
      <category term="上下文" scheme="http://jasonzou.me/tags/%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
      <category term="context" scheme="http://jasonzou.me/tags/context/"/>
    
  </entry>
  
  <entry>
    <title>记我第一次下厨</title>
    <link href="http://jasonzou.me/2017/04/18/%E8%AE%B0%E6%88%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8B%E5%8E%A8/"/>
    <id>http://jasonzou.me/2017/04/18/记我第一次下厨/</id>
    <published>2017-04-18T13:47:20.000Z</published>
    <updated>2017-04-21T11:56:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>王者以民为天,而民以食为天。 <br> <strong>《汉书·郦食其传》</strong> </p>
</blockquote>
<p>　　不过是一碗面罢了。<a id="more"></a><br>　　不过是一碗面罢了，怎好意思称之为下厨呢？但这的确是我第一次在厨房中捣鼓出能入口的食物。<br>　　客观而言，我煮的面很和我的口味。它没有猪油，我的母亲和外婆的面永远是有猪油的。它很细，奶奶煮的面总是选宽面。它软又不至于腻做一团，哥哥的面总是很硬。<br>　　下班后立马就往住处赶，我怕楼下负一层的菜市等不到我平时到家的那一刻。匆匆忙忙地，匆忙得像所有匆忙回家做饭的其他人。下地铁打电话问哥哥买多少钱的小葱和小白菜合适，偏偏问了还是把1块钱的小葱买做了2块钱的。<br>　　七点过就到家了。算是很早的。洗菜切葱拍蒜，又打电话给母亲询问调料该怎么配：醋、鸡精、酱油、花椒面、藤椒油、辣椒油和再半勺辣椒油，我是一个土生土长的峨眉乐山人。水开下面，再开下菜，再开试尝。软硬合适就关火装碗。<br>　　客观而言，味道真的是不错的。<br>　　但仍然不过是一碗面罢了。<br>　　面是现成的，辣椒油是现成的，配料都是现成的。煮面时出神，竟想到：用编程做比，这就是个什么接口都准备好了的体力活。我曾浅略地思考过，学习开发网页对我有什么改变，一条一条总结的话，读上去就像十一月树上的最后一片枯叶一样干煸乏味。有幸地是，给别人讲自己下厨煮面时的胡思乱想并不那么无趣。面是怎么做的，煮多久合适，最少煮多久，最多煮多久，养胃的面是说的所有的面吗？假如是，那煮多久都养胃吗？辣椒油又是怎么做的，多少合适。别的调料加多少合适？为什么不适合加花椒，要用花椒面呢？藤椒油和花椒面都是麻的为什么值得一样加一点？加多少面汤合适，不至于让味道太淡又不让面腻成一团。面汤为什么适合用来洗碗？菜对面的帮助有哪些？怎么装碗能让面看上去好看些。<br>　　无非是一大堆成熟的封装程度很高的公共库（各种调料）和一个自造的轮子（辣椒油）在开水和面汤的环境中对面条（主要的参数）进行简单的软化加热（类似于解析或是转换格式）和调味（改变一些旧的属性赋予一些新的属性），并最终输出食物：面条吗？<br>　　为什么原料和调料众多，但是想深入研究的只有面和辣椒油呢？因为辣椒油是自造的轮子，不是现成的，是自己迟早也要造的轮子。而面条和别的调料不同，在这个处理中，面条是最重要的主要参数，值得理解它的一些深层次的属性乃至原理。<br>　　大多数人十二岁前就会煮面喂饱自己了，而我自己第一次煮面竟然是二十一岁。<br>　　十二岁的我，大概会想，煮个面而已，想这么多不会累吗？而二十一岁的我竟然已经把这种并没有什么意思的联想当成了一种娱乐。<br>　　独自生活的话免不了要自己做饭的。我离开父亲母亲，从四川一路到了北京，其实早料到了会有个这样的第一次。<br>　　北京是一个让我抑郁的地方。午间小憩，不经意间回想起自己儿时的种种。<br>　　小时候的我被管束得很严，父亲是一个小学老师，我在过去的文字里应该也提过了。总之，那时候的我向往鸟，觉得自己是笼子里的小动物。后来真的就自由了，谁也管不了我，我不信宗教，不信马克思主义，不为传统文化骄傲，更不会热爱任何的党，任何的国家。我真的很自由，不论是身，还是心。<br>　　可是，真正成了鸟，又发现自己原来更想当条狗。城里的人想长出翅膀飞出墙外，到了墙外却不知道要飞到哪里，才明白，自由竟是迷茫脆弱恐惧和孤独的代名词。此时，才想回到城里，回到笼子里。没有约束自己的那层皮，气球就不是气球，只是一团随时会消散泯灭于世间的空气。飞在天上的鸟，他想去哪里就去那里，然而不管到了哪里，都和前一处一样，四周空荡荡的，只有从东西南北吹来的风、如来掌心般的云层和东升西落的太阳。而自己曾经奋力摆脱的那片大地，隔远一看，才是多姿多彩的。城外的天，只有在城里人的眼中才是美妙的。<br>　　反而怀念起了小学的日子。
　　</p>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;王者以民为天,而民以食为天。 &lt;br&gt; &lt;strong&gt;《汉书·郦食其传》&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　不过是一碗面罢了。
    
    </summary>
    
      <category term="胡诌" scheme="http://jasonzou.me/categories/%E8%83%A1%E8%AF%8C/"/>
    
    
      <category term="学做菜" scheme="http://jasonzou.me/tags/%E5%AD%A6%E5%81%9A%E8%8F%9C/"/>
    
  </entry>
  
  <entry>
    <title>减肥对精神健康的作用</title>
    <link href="http://jasonzou.me/2017/04/10/%E5%87%8F%E8%82%A5%E7%9A%84%E7%90%86%E7%94%B1/"/>
    <id>http://jasonzou.me/2017/04/10/减肥的理由/</id>
    <published>2017-04-09T17:16:47.000Z</published>
    <updated>2017-04-09T18:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>一鼓作气，再而衰，三而竭<br> <b>左丘明</b> </p>
</blockquote>
<p>　　这是我给女朋友写的小论文。纯属发泄情绪，胡诌乱道一通。</p>
<h3 id="减肥是一种理性行为"><a href="#减肥是一种理性行为" class="headerlink" title="减肥是一种理性行为"></a>减肥是一种理性行为</h3><p>　　减肥是一种理性的行为。尽可能的增重是人与生俱来的本能，在食物并不充足的时代，人会尽可能多的摄入食物。食物充足的时候，摄入的食物除了提供人日常劳作的能量，部分还会转化为脂肪，存储在人体中。而在人难以补充充足的能量时（例如生病后，不能很好的吸收食物），之前存储下的脂肪会成为宝贵的资源。因此，在过去的时代里，因为食物并不总是充足的，所以食欲旺盛的人更有活下去的可能性。旺盛的食欲在一番物竞天择后，留在了如今很多人的基因中。<br>　　当今绝大部分中国人并不缺少食物，尤其是青少年。因此，胃口太好在现代社会中，还会对人起到消极作用。缺乏节制地，不合理地饮食往往会让人肥胖。<br><a id="more"></a><br>　　当进食的本能成为健康的敌人，部分人选择减肥。减肥是不盲目遵从本能的理性行为。人类的各种理性行为是其与普通动物的区别所在。<br>　　过去谈到减肥，人们会更多地注意到它对人体健康的益处。我认为，减肥的意义不只在于促进人的身体健康，它更能促进一个人的精神健康。</p>
<h3 id="减肥能助人产生积极的意志"><a href="#减肥能助人产生积极的意志" class="headerlink" title="减肥能助人产生积极的意志"></a>减肥能助人产生积极的意志</h3><p>　　减肥能够磨炼人的意志。这里的意志，指的是一种对自我的控制力。<br>　　前文提到了：减肥这一行为，必然伴随着对本能的压制。这是一种自我控制的体现。具体而言，健康的减肥主要有合理饮食和适当运动组成。肥胖的人一般有着睡前四小时内进食，食物营养过盛或营养不均衡等行为现象。将不良的饮食习惯纠正，需要人对自己本能中的食欲进行控制。古人云：食色性也。作为人类的两大天性之一，控制食欲的难度是不低的。我们可以观察到，越是年幼的儿童乃至幼儿，越缺乏对食欲的控制能力。因此我们可以认为，对进食的控制，是成熟的人才具有的能力之一。而连控制进食都做不到的人，其自控力是不完善的。<br>　　减肥的人普遍还会自发的进行体育锻炼。趋利避害是人的一种重要的能力，而利益从时间划分可分为眼前的利益和长远的利益。举例而言，在床上睡一天，在短期内是让人愉悦的。但，从长期来看，荒废时间是不利于长远利益的。进行体育锻炼的人亦是如此。拒绝锻炼可以获得短期的利益，而进行锻炼将获得长远的利益。如果长远的利益大于短期的利益，理想情况下的人是会放弃短期利益而选择长期利益的。对此，美国科学家曾对一群小朋友做过一个简单的实验，能坚持30分钟不吃掉眼前的一颗糖的小孩，将获得三颗糖的奖励。成功坚持到三十分钟不吃糖的小朋友在长大后成就普遍远大于不能坚持三十分钟的小朋友。尽管进行减肥行为的不只是儿童，但同样的道理是适用的。能坚持锻炼的人往往更有实现自己的目标，成就自己的理想。<br>　　不论是对于本能的控制力，还是对于短期利益的抵抗力，这都属于积极的意志力。<br>　　减肥能够锻炼一个人对于长期利益和短期利益的取舍能力。人在达成一些事之后，产生满足感。从生物学的角度讲，满足感来源于大脑分泌的多巴胺。举例而言：吸毒之后，人的大脑中就会大量的堆积多巴胺，因此人会感到精神愉悦。同样能产生愉悦感的还有：每天都进行运动，坚持一年，并形成一副健康的躯体。前者和后者的差别不必多说。举这个极端的例子是为了说明一点：偷懒也是会产生依赖性的，万不可认为松懈一天没有关系，会轻易松懈某一天的人的结局往往是之后的每天都在偷懒松懈。这和吸毒上瘾的机制是有些类似的，吸毒者成瘾是因为毒品效力消失后，人体会产生不适感，毒品用量越大，不适感越强。屈服于自己的惰性也是同样的，偷懒时愉悦，事后后悔痛苦，为了从消极情绪中解脱，于是选择更多的懈怠以获取愉悦感。一但懈怠了，人就会越来越难以坚持原本的目标。<br>　　因此坚持减肥不仅是在打磨自己的身体，同样也是在打磨自己心灵。</p>
<h3 id="成功的减肥是一种强大的“精神资源”"><a href="#成功的减肥是一种强大的“精神资源”" class="headerlink" title="成功的减肥是一种强大的“精神资源”"></a>成功的减肥是一种强大的“精神资源”</h3><p>　　成功的减肥经历是一种“精神资源”。所谓“精神资源”，有可以称之为一个人自信的源泉。一个减肥成功的人，往往具有充足的自信。能成功减肥的人能对自己做出两个清晰的判断：一是，自己可以控制自己的天性。二是，自己能够不受短期的利益的诱惑。这样的人在面临挑战的时候必然是泰然自若的。<br>　　从反面而言，一个减肥失败的人，在做别的事时很可能会怀疑自己。比如，作为一个学生，如果他不能成功的减肥，那么他也会怀疑自己能否坚持每天背单词。一个研究人员，如果不能成功减肥，他必定会怀疑自己能否耐得住多次实验失败时的寂寞和苦闷。一位政府官员，倘若他连坚持减肥都做不到，那么他很可能会怀疑自己是否可以抵抗住金钱和美女的诱惑。<br>　　“精神资源”是一个人极为重要的财富，一个内心中空无一物，认为自己什么都没有做成过的人，哪怕他头脑聪明，背景显赫，他在处理问题的时候都会带着一份难以摒去的优柔寡断。这样的人是不具备优秀领导力的，因为他不能领导自己，所以更难以去领导一群人。<br>　　一个人如果没有克服困难达成某个目的的经历，那么这个人的内心往往是不足够强大的。而减肥这件事，正好可以提供给人这个经历，并进一步给予人以一颗强大的心脏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;一鼓作气，再而衰，三而竭&lt;br&gt; &lt;b&gt;左丘明&lt;/b&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　这是我给女朋友写的小论文。纯属发泄情绪，胡诌乱道一通。&lt;/p&gt;
&lt;h3 id=&quot;减肥是一种理性行为&quot;&gt;&lt;a href=&quot;#减肥是一种理性行为&quot; class=&quot;headerlink&quot; title=&quot;减肥是一种理性行为&quot;&gt;&lt;/a&gt;减肥是一种理性行为&lt;/h3&gt;&lt;p&gt;　　减肥是一种理性的行为。尽可能的增重是人与生俱来的本能，在食物并不充足的时代，人会尽可能多的摄入食物。食物充足的时候，摄入的食物除了提供人日常劳作的能量，部分还会转化为脂肪，存储在人体中。而在人难以补充充足的能量时（例如生病后，不能很好的吸收食物），之前存储下的脂肪会成为宝贵的资源。因此，在过去的时代里，因为食物并不总是充足的，所以食欲旺盛的人更有活下去的可能性。旺盛的食欲在一番物竞天择后，留在了如今很多人的基因中。&lt;br&gt;　　当今绝大部分中国人并不缺少食物，尤其是青少年。因此，胃口太好在现代社会中，还会对人起到消极作用。缺乏节制地，不合理地饮食往往会让人肥胖。&lt;br&gt;
    
    </summary>
    
      <category term="胡诌" scheme="http://jasonzou.me/categories/%E8%83%A1%E8%AF%8C/"/>
    
    
      <category term="养生" scheme="http://jasonzou.me/tags/%E5%85%BB%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】我是怎么变牛逼的</title>
    <link href="http://jasonzou.me/2017/04/01/How-I-Became-a-Better-Programmer/"/>
    <id>http://jasonzou.me/2017/04/01/How-I-Became-a-Better-Programmer/</id>
    <published>2017-04-01T07:07:15.000Z</published>
    <updated>2017-04-04T08:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原文出处："><a href="#原文出处：" class="headerlink" title="原文出处："></a>原文出处：</h3><p><a href="http://jlongster.com/How-I-Became-Better-Programmer" target="_blank" rel="external">http://jlongster.com/How-I-Became-Better-Programmer</a>.</p>
<h3 id="译者的话"><a href="#译者的话" class="headerlink" title="译者的话"></a>译者的话</h3><p>　　我一直认为：“知道”和“懂得”之间是存在着巨大的差距的。从别人那里得到的指导和教训，永远和别人真正想教授的东西往往相差不少。广义上举例讲，作者的原话和我的翻译之间也会存在差异（这是当然也和本人的水平实在有限有关，毕竟，这篇翻译也只是自行记录为主，传播分享为辅）。<br><a id="more"></a></p>
<h3 id="如何成为更好的程序员"><a href="#如何成为更好的程序员" class="headerlink" title="如何成为更好的程序员"></a>如何成为更好的程序员</h3><p>有人在 React Conf 上向问我如何成为更好的程序员。由于某些原因，人们觉得我是个值得向其求取意见的牛逼程序员。（既然听众们诚心诚意的发问了）我觉得，写下我这些年来编程成长之路的技巧法门是有意义的。</p>
<p>关于我的一些小故事：<br>我32岁，之前有过超过十年的硬编经验。长久以来，我对自己所做的事并不那么自信。甚至直到今天，我也是在怀疑自己的。重要的事，既然（客观上）这种感觉挥之不去，那不如（在主观上去）忽略它，只管继续完善自己，不断积累经验。</p>
<p>且让我声明一下：这些只是提升你编程技能的一些小提示。最后你得亲自弄明白，哪些是对你最有益的。这些只是我认为有用的东西。</p>
<h4 id="寻找给你灵感的人，但不要盲目崇拜他们"><a href="#寻找给你灵感的人，但不要盲目崇拜他们" class="headerlink" title="寻找给你灵感的人，但不要盲目崇拜他们"></a>寻找给你灵感的人，但不要盲目崇拜他们</h4><p>这些年里，我关注了很多我尊敬的人，从他们那里学习新技术。我只是相信他们的方向是对的，并探索他们的正在研究的领域，并从中学到了很多。这些人往往才智过人，充满灵性并且成果颇多。找到这些人，让人他们启发你，指导你。</p>
<p>但是，一定不要过分崇拜他们。Twitter上的信息让他们看上去牛逼的可怕，不过，如果你看看他们在平日里是怎么工作的，你会发现他们并不是那么与众不同。同样是修补的各种错误之类的。我们都是在实验中摸索向前的。最后，不要盲目相信他们；如果你不赞同某些东西，就怼他们，然后从质疑中学习。我的一些成果就是在这样的交流中产生的。</p>
<p>我的 EMACS 设置一团糟。我不知道为啥我的 OCaml 自动补出问题了（它坏了一个多月了）。我没有做任务自动化，因此，有时候得在我的shell输入历史里慢慢找某些我需要用到的命令。我一开始的时候写的代码其丑无比。我把很多东西绑定在全局对象中，直到有一天我意识到我都干了些什么。最牛逼的程序员会使用各种技巧。但最重要的（不是这些牛逼的技巧，而是）你能把问题给解决了。</p>
<h4 id="切莫妄之菲薄"><a href="#切莫妄之菲薄" class="headerlink" title="切莫妄之菲薄"></a>切莫妄之菲薄</h4><p>新人程序员总倾向于认为他们干的事意义不大，因为它们不成熟。或者，你是个老司机，但是刚刚涉及一个让你不舒服的新领域。我认为，一些最棒的点子来自于那些观点尚未成型的新人程序员，因为他们能看到思维模式成型的老鸟们看不到的，某些成熟技术中的可提高之处。</p>
<p>不管是啥，你干的事都是有意义的。再不济，如果你的点子行不通，那么社区中的众人也能学到这种方法行不通。（给社区的提示：有没有用和欢不欢迎新人是由我们决定的）</p>
<h4 id="不要一直在焦虑中工作"><a href="#不要一直在焦虑中工作" class="headerlink" title="不要一直在焦虑中工作"></a>不要一直在焦虑中工作</h4><p>技术每天都在推陈出新，这会让你觉得，你摸一晚上的鱼，你就会被整个世界落下。这是不对的。事实上，你会干的更好，如果你从过度紧张中解脱出来。你的观点会被刷新，并且，我发现，不工作的时候，有些新点子会下意识的涌现出来。</p>
<p>每天都出现的那些的所谓的新技术，大体上都是把旧知识换了个包装而已。真正的革命性的技术革新，每几年才会发生一次。关于这个，可以去看看 Hammock Driven Development。</p>
<h4 id="少花心思在浅层次的知识上"><a href="#少花心思在浅层次的知识上" class="headerlink" title="少花心思在浅层次的知识上"></a>少花心思在浅层次的知识上</h4><p>少花心思在不重要的事上是提升自己的技术的不二法门。换言之，也就是理智的使用你的时间。你每天的时间是有限的，如果你把这些时间花在一些深层次的东西上你会感觉很不一样。</p>
<p>所以，什么是所谓的皮毛知识呢？这是因人而异的，但我可以给你举我自己的例子，我认为的皮毛知识有：语言的语法，API库，编程软件设置等。相较于学习编译器是怎么运行的，学习ES7的某个新语法对你的提升是很有限的。学习一个库的实现原理比死记硬背库的API有意思得多。当然，这些“皮毛知识”也是很重要的，但我还是推荐你花更多的时间在学习深层次的东西上，这会在之后的很多年里都给你回报。</p>
<p>这里我要提个问题：你是否花了很多的时间在怎样让你的代码看上去好看上？如果是这样的，我建议你别花太多时间在上面。你的代码是会有很大改变的，随着时间的推移。你不如花更多注意力在如何解决核心问题和思考一下你的抽象层级上。待你确定你已经解决好了这些之后，你可以花点儿时间打磨一下你的代码。（这样你的代码也是很DRY的，别对这种问题担心过度，对充满重复性的工作放松一些。）</p>
<h4 id="回顾前辈的研究"><a href="#回顾前辈的研究" class="headerlink" title="回顾前辈的研究"></a>回顾前辈的研究</h4><p>如果你对某个新点子激动不已，那你肯定很想坐下来就开始怼它。但你应该先粗略的研究一下前人是如何解决这个问题，然后才开始你的行动。花几天的时间研究一下前辈们的工作，总会让我彻底改变我对这个问题的原始解决方案。</p>
<p>学习如何读学术文章是有价值的。我对“指示”、“操作”等专业术语的东西一无所知，所以我有很多文章看不懂。但（文章中）同样有很多的使用代码而不是数学符号（的内容）并不是那么难懂。过去三十年间的文献中，蕴含着海量的知识。如果你善于做这些事情的话，你将是一个思想上的领袖。</p>
<p>Prettier就是个典型的例子。我知道我想要什么效果，但是我不知道怎么去事实它。在经过了一些调研后，我找到了一篇文章，然后过了几天，我就明白了我到底需要做些什么。我在每个工作日还得做一些基础工作。如果我忽略掉了提前调研的话，我就得话很多的时间去解决这个问题。</p>
<p>如果你在找文献的话，你可以 star 一下 the Papers We Love 这个github库。</p>
<h4 id="搞些大项目，挑战一下自己"><a href="#搞些大项目，挑战一下自己" class="headerlink" title="搞些大项目，挑战一下自己"></a>搞些大项目，挑战一下自己</h4><p>没有什么是比实战经验更宝贵的了。并不是每个人都有能做大项目的条件。但，如果你有时间的话，尝试着去做些大项目吧。你并非一定要完成这些项目。只要你尝试去解决一些事儿，就比如尝试去写个编译器，这会在你干这个事的最初的几周里教给你成吨的知识。</p>
<p>说实话，我很讨厌不知道怎么解决一个复杂问题的时候。这很不爽。我知道我得花很多功夫，做很多研究，学习很多，在我只是单纯的接近解决方案之前。但我总会在挑战了这些困难之后变成一个更牛逼的程序员。</p>
<p>开始学习一门新语言。这是最好的让你从旧语言的使用习惯中解脱出来，开发新思路的办法。对我而言，我作为一个年轻的程序员做过的最好的是事是学习 Scheme。这是一门很简单的语言，它会迫使你用函数式编程思想做所有事情，并且让你真正学习到代码运行的基本原理。我花在 Scheme 上的几年功夫，直到今天也一直对我有很大的帮助；我看代码的方式从根本上改变了。（我甚至给我的公司取名叫 Shift Reset LLC ，这是向 Scheme 中的 shift/reset 操作符致敬。）</p>
<p>这里，我列一些我推荐去做的事。这些事都对我的程序员生涯产生了巨大的影响。其中的大部分工作，至今都在以微妙的方式产生着回报，并且会从思想上帮我煮结构一些新点子。你无须完全照做，有别的事也能帮助你成为更好的程序员，这些只是帮助我成长的事。</p>
<ul>
<li>学习C语言：学习基础的东西，如果你还没学过C语言的话。我认为，弄清楚为什么每个人都抱怨它是很值得的事。</li>
<li>写个编译器：这也许是最好的挑战自己的方式了，查一查一个<a href="https://github.com/thejameskyle/the-super-tiny-compiler" target="_blank" rel="external">超级小型的编译器</a>是怎么实现的。</li>
<li>学习 macros ：看看 Scheme，Lisp 或是 Clojure 。Macros 会非常显著的改变你看代码的方式。</li>
<li>看SICP：<a href="https://mitpress.mit.edu/sicp/full-text/book/book.html" target="_blank" rel="external">SICP</a> 是一本我认为今天依然有意义的老书（有些人不赞同）。它只讲了比较少的编程知识，并且会一直引导你到实现元循环评估器和编译器。另一本让我受益匪浅并让在编译器学习之路精进不少的书是 <a href="https://www.amazon.com/Lisp-Small-Pieces-Christian-Queinnec/dp/0521545668" target="_blank" rel="external">Lisp In Small Pieces</a> 。</li>
<li>理解 continuations ：<a href="https://en.wikipedia.org/wiki/Continuation" target="_blank" rel="external">Continuations</a> 是一种低等级的控制流机制。Scheme 是唯一一们继承了这些机制的语言，尽管你永远不会在你的生产中使用这门语言，但这些只是会改变你对控制流的思考。我写了篇<a href="http://jlongster.com/Whats-in-a-Continuation" target="_blank" rel="external">博客</a>解释这个。</li>
<li>如果说还有什么建议的话，那就是尝试一门新语言了：不管你是做什么的，你都很应该去探索一下别的语言。我的推荐依次是：Clojure，Rust，Elm，OCaml/Reason，Go，或者 Scheme。这其中的每一门语言都有它独特的地方，会迫使你学习一种新的思考问题的方式。</li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>



]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原文出处：&quot;&gt;&lt;a href=&quot;#原文出处：&quot; class=&quot;headerlink&quot; title=&quot;原文出处：&quot;&gt;&lt;/a&gt;原文出处：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://jlongster.com/How-I-Became-Better-Programmer&quot;&gt;http://jlongster.com/How-I-Became-Better-Programmer&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;译者的话&quot;&gt;&lt;a href=&quot;#译者的话&quot; class=&quot;headerlink&quot; title=&quot;译者的话&quot;&gt;&lt;/a&gt;译者的话&lt;/h3&gt;&lt;p&gt;　　我一直认为：“知道”和“懂得”之间是存在着巨大的差距的。从别人那里得到的指导和教训，永远和别人真正想教授的东西往往相差不少。广义上举例讲，作者的原话和我的翻译之间也会存在差异（这是当然也和本人的水平实在有限有关，毕竟，这篇翻译也只是自行记录为主，传播分享为辅）。&lt;br&gt;
    
    </summary>
    
      <category term="最无用的东西" scheme="http://jasonzou.me/categories/%E6%9C%80%E6%97%A0%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>map、filter和reduce</title>
    <link href="http://jasonzou.me/2017/03/31/map%E3%80%81filter%E5%92%8Creduce/"/>
    <id>http://jasonzou.me/2017/03/31/map、filter和reduce/</id>
    <published>2017-03-31T08:48:10.000Z</published>
    <updated>2017-04-04T08:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　map( ) 、 filter( ) 和 reduce( ) 是一系列很符合函数式编程思想的数组操作方法。我认为学习他们很重要，本文没有什么自己的见解，仅仅是作为学习<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">MDN</a>资料的摘录。<br><a id="more"></a></p>
<h3 id="map"><a href="#map" class="headerlink" title="map( )"></a>map( )</h3><p>　　map( ) 是根据旧数组<strong>产生新数组</strong>的方法，并不修改原数组。 </p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line"><span class="keyword">let</span> roots = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// roots is now [2, 10, 20, 30]</span></div><div class="line"><span class="comment">// numbers is still [1, 5, 10, 15]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>];</div><div class="line"><span class="comment">//es6: let roots = numbers.map(Math.sqrt);</span></div><div class="line"><span class="keyword">let</span> roots = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(x);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// roots is now [1, 2, 3]</span></div><div class="line"><span class="comment">// numbers is still [1, 4, 9]</span></div></pre></td></tr></table></figure>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> new_array = arr.map(callback[, thisArg])</div></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>callback<br>生成新数组元素的函数，使用三个参数：<ul>
<li>currentValue<br>callback 的第一个参数，数组中正在处理的当前元素。</li>
<li>index<br>callback 的第二个参数，数组中正在处理的当前元素的索引。</li>
<li>array<br>callback 的第三个参数，map 方法被调用的数组。</li>
</ul>
</li>
<li>thisArg<br>可选的。执行 callback 函数时 使用的this 值。</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>  一个新数组，每个元素都是回调函数的结果。</p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>　　map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。<br>　　callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。<br>　　如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象 。<br>　　map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。<br>　　使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter( )"></a>filter( )</h3><p>　　filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> value &gt;= <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].filter(isBigEnough);</div><div class="line"><span class="comment">// filtered is [12, 130, 44]</span></div></pre></td></tr></table></figure>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> new_array = arr.filter(callback[, thisArg])</div></pre></td></tr></table></figure>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul>
<li>callback<br>用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。<br>返回true表示保留该元素（通过测试），false则不保留。</li>
<li>thisArg<br>可选。执行 callback 时的用于 this 的值。</li>
</ul>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>　　一个新的通过测试的元素的集合的数组</p>
<h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>　　filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。<br>　　callback 被调用时传入三个参数：</p>
<ul>
<li>元素的值</li>
<li>元素的索引</li>
<li>被遍历的数组</li>
</ul>
<p>　　如果为 filter 提供一个 thisArg 参数，则它会被作为 callback 被调用时的 this 值。否则，callback 的 this 值在非严格模式下将是全局对象，严格模式下为 undefined。<br>　　The thisvalue ultimately observable by callback is determined according to the usual rules for determining thethis seen by a function.<br>　　filter 不会改变原数组。<br>　　filter 遍历的元素范围在第一次调用 callback 之前就已经确定了。在调用 filter 之后被添加到数组中的元素不会被 filter 遍历到。如果已经存在的元素被改变了，则他们传入 callback 的值是 filter 遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce( )"></a>reduce( )</h3><p>　　reduce() 方法对累加器和数组的每个值 (从左到右)应用一个函数，以将其减少为单个值。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sum = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">acc, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> acc + val;</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sum);</div><div class="line"><span class="comment">// 6</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> list1 = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]];</div><div class="line"></div><div class="line"><span class="keyword">let</span> list2 = [<span class="number">0</span>, [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>]]]]]]];</div><div class="line"></div><div class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> arr.reduce(</div><div class="line">        <span class="function">(<span class="params">acc, val</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> acc.concat(<span class="built_in">Array</span>.isArray(val) ? flatten(val) : val)</div><div class="line">        &#125;, []</div><div class="line">    );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">flatten(list1); </div><div class="line"><span class="comment">// [0, 1, 2, 3, 4, 5]</span></div><div class="line"></div><div class="line">flatten(list2); </div><div class="line"><span class="comment">// [ 0, 1, 2, 3, 4, 5, 6 ]</span></div></pre></td></tr></table></figure>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.reduce(callback,[initialValue])</div></pre></td></tr></table></figure>
<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul>
<li>callback<br>执行数组中每个值的函数，包含四个参数<ul>
<li>accumulator<br>上一次调用回调返回的值，或者是提供的初始值（initialValue）</li>
<li>currentValue<br>数组中正在处理的元素</li>
<li>currentIndex<br>数据中正在处理的元素索引，如果提供了 initialValue ，从0开始；否则从1开始</li>
<li>array<br>调用 reduce 的数组</li>
</ul>
</li>
<li>initialValue<br>可选项，其值用于第一次调用 callback 的第一个参数。</li>
</ul>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>　　函数累计处理的结果</p>
<h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>　　reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值 accumulator （或者上一次回调函数的返回值），当前元素值 currentValue ，当前索引 currentIndex ，调用 reduce 的数组。<br>　　回调函数第一次执行时，accumulator 和 currentValue 的取值有两种情况：调用 reduce 时提供initialValue，accumulator 取值为 initialValue ，currentValue 取数组中的第一个值；没有提供 initialValue ，accumulator 取数组中的第一个值，currentValue 取数组中的第二个值。<br>　　注意: 不提供 initialValue ，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。提供 initialValue ，从索引0开始。<br>　　如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。<br>　　提供 initialValue 通常更安全，正如下面的例子，没有 initialValue 有三种可能输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> maxCallback = <span class="function">(<span class="params"> pre, cur </span>) =&gt;</span> <span class="built_in">Math</span>.max( pre.x, cur.x );</div><div class="line"><span class="keyword">var</span> maxCallback2 = <span class="function">(<span class="params"> max, cur </span>) =&gt;</span> <span class="built_in">Math</span>.max( max, cur );</div><div class="line"></div><div class="line"><span class="comment">// reduce() without initialValue</span></div><div class="line">[ &#123; <span class="attr">x</span>: <span class="number">22</span> &#125;, &#123; <span class="attr">x</span>: <span class="number">42</span> &#125; ].reduce( maxCallback ); <span class="comment">// 42</span></div><div class="line">[ &#123; <span class="attr">x</span>: <span class="number">22</span> &#125;            ].reduce( maxCallback ); <span class="comment">// &#123; x: 22 &#125;</span></div><div class="line">[                      ].reduce( maxCallback ); <span class="comment">// TypeError</span></div><div class="line"></div><div class="line"><span class="comment">// map/reduce; better solution, also works for empty arrays</span></div><div class="line">[ &#123; <span class="attr">x</span>: <span class="number">22</span> &#125;, &#123; <span class="attr">x</span>: <span class="number">42</span> &#125; ].map( <span class="function"><span class="params">el</span> =&gt;</span> el.x )</div><div class="line">                        .reduce( maxCallback2, -<span class="literal">Infinity</span> );</div></pre></td></tr></table></figure></p>
<p style="text-align: center;"><b>… End …</b></p>





]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　map( ) 、 filter( ) 和 reduce( ) 是一系列很符合函数式编程思想的数组操作方法。我认为学习他们很重要，本文没有什么自己的见解，仅仅是作为学习&lt;a href=&quot;https://developer.mozilla.org/zh-CN/&quot;&gt;MDN&lt;/a&gt;资料的摘录。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript知识总结" scheme="http://jasonzou.me/categories/JavaScript%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://jasonzou.me/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://jasonzou.me/tags/ES6/"/>
    
      <category term="函数式编程" scheme="http://jasonzou.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>localhost到底是什么</title>
    <link href="http://jasonzou.me/2017/03/31/localhost%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://jasonzou.me/2017/03/31/localhost到底是什么/</id>
    <published>2017-03-31T06:01:13.000Z</published>
    <updated>2017-04-04T08:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>起因：<br>　　最近在为在维护一个项目。在以本机为服务器做移动端测试时，出现了页面资源载入失败的情况：playback-mobile.js（如下）文件并没有被成功加载。这个错误仅出现在了魅族系列手机上的native浏览器和QQ移动浏览器（也许还有别的非主流浏览器也不支持）中。和前辈交流后认为：有可能是这个src中的localhost应该替换为服务器地址。修改后发现，问题的确是出在这里的。<br>　　无独有偶，在 MacOS Safari 上进行开发测试时，发现了一个更为怪异的现象：当我使用 localhost 作为域名时，我访问某个配置了全域可访问头的资源（并且只有这个资源出现了问题）时，居然提示跨域错误。查看后发现，请求完全没有发出，是浏览器直接就把请求block了。把 localhost 换成本机IP后又一切正常了。<br>　　事后探究了一下原因，并在此做一个总结：<br><a id="more"></a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 原来的引入路径</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://localhost:9094/playback-mobile.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">// 修改后的引入路径</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://192.168.2.196:9094/playback-mobile.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="localhost、127-0-0-1-和-本机IP-三者的区别"><a href="#localhost、127-0-0-1-和-本机IP-三者的区别" class="headerlink" title="localhost、127.0.0.1 和 本机IP 三者的区别"></a>localhost、127.0.0.1 和 本机IP 三者的区别</h3><p>参考：<a href="https://www.zhihu.com/question/23940717/answer/26230963" target="_blank" rel="external">知乎</a></p>
<h4 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h4><p>　　localhost 是一个域名，在过去它指向 127.0.0.1 这个IP地址。在操作系统支持 ipv6 后，它同时还指向ipv6 的地址 [::1]。在 Windows 中，这个域名是预定义的，从 hosts 文件中可以看出：</p>
<pre><code>　　#localhost name resolution is handled within DNS itself.#    
　　127.0.0.1       localhost#    
　　::1             localhost
</code></pre><p>　　而在 Linux 中，其定义位于 /etc/hosts 中：</p>
<pre><code>　　127.0.0.1    localhost
</code></pre><p>　　注意这个值是可修改的，比如我把它改成 </p>
<pre><code>　　192.068.206.1    localhost
</code></pre><p>　　然后再去 ping localhost，提示就变成了PING localhost (192.168.206.1) 56(84) bytes of data.当然一般人不会像我这么蛋疼。</p>
<h4 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h4><p>　　127.0.0.1 这个地址通常分配给 loopback 接口。loopback 是一个特殊的网络接口(可理解成虚拟网卡)，用于本机中各个应用之间的网络交互。只要操作系统的网络组件是正常的，loopback 就能工作。Windows 中看不到这个接口，Linux中这个接口叫： </p>
<pre><code>　　lo：#ifconfigeth0    Link encap:Ethernet hwaddr 00:00:00:00:00:00            
　　inet addr :192.168.0.1 Bcase:192.168.0.255 Mask:255.255.255.0           
　　......lo        
　　Link encap:Local Loopback           
　　inetaddr: 127.0.0.1 Mask: 255.0.0.0           
　　......
</code></pre><p>　　可以看出 lo 接口的地址是 127.0.0.1。事实上整个 127.* 网段都算能够使用，比如你 ping 127.0.0.2 也是通的。但是使用127.0.0.1作为loopback接口的默认地址只是一个惯例，比如下面这样：</p>
<pre><code>　　#ifconfig lo 192.168.128.1#ping localhost   #
</code></pre><p>　　糟糕，ping不通了，试试ping 192.128.128.1：</p>
<pre><code>　　#ping 192.128.128.1  # 
</code></pre><p>　　可以通：</p>
<pre><code>　　#ifconfig lolo        Link encap:Local Loopback           
　　inetaddr: 192.168.128.1 Mask: 255.255.255.0          
　　......
</code></pre><p>　　当然，一般人更不会像我这样蛋疼。如果随便改这些配置，可能导致很多只认 127.0.0.1 的软件挂掉。</p>
<h4 id="本机IP（本机地址）"><a href="#本机IP（本机地址）" class="headerlink" title="本机IP（本机地址）"></a>本机IP（本机地址）</h4><p>　　确切地说，“本机地址”并不是一个规范的名词。通常情况下，指的是“本机物理网卡所绑定的网络协议地址”。由于目前常用网络协议只剩下了IPV4，IPX/Apple Tak消失了，IPV6还没普及，所以通常仅指IP地址甚至ipv4地址。一般情况下，并不会把 127.0.0.1 当作本机地址。原因没必要特别说明，大家都知道。本机地址是与具体的网络接口绑定的。比如以太网卡、无线网卡或者PPP/PPPoE拨号网络的虚拟网卡，想要正常工作都要绑定一个地址，否则其他设备就不知道如何访问它。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　localhost 是个域名，不是地址，它可以被配置为任意的 IP 地址，不过通常情况下都指向 127.0.0.1(ipv4)和 <a href="ipv6">::1</a>整个127.<em> 网段通常被用作 loopback 网络接口的默认地址，按惯例通常设置为 127.0.0.1。这个地址在其他计算机上不能访问，就算你想访问，访问的也是自己，因为每台带有TCP/IP协议栈的设备基本上都有 localhost/127.0.0.1。本机地址通常指的是绑定在物理或虚拟网络接口上的IP地址，可供其他设备访问到。最后，从开发度来看localhost是个域名，性质跟 “www.baidu.com” 差不多。不能直接绑定套接字，必须先gethostbyname转成IP才能绑定。127.0.0.1 是绑定在 loopback 接口上的地址，如果服务端套接字绑定在它上面，你的客户端程序就只能在本机访问。如果主机中存在多个网卡，分别连接不同的物理网络，比如 192.168.0.1/255.255.255.0 和 192.168.1.1/255.255.255.0，那么当你的服务端套接字绑到 192.168.0.1 这个地址上时，位于 192.168.1.</em> 网段的其他计算机是无法连接的，只有位于192.168.0.* 网段的计算机才能访问你的服务端程序。<br>　　之前举了一个修改 loopback 接口后无法ping通localhost的例子，我认为，这和我本次遇到的第一个问题的原理相同。魅族手机的native浏览器中可能存在对 loopback 接口的修改，并最终导致了本次错误。<br>　　对于第二个错误，我并不是很能确定是否也是相同的原因，我认为，更有可能是 Safari 浏览器的某些内部设置问题。如果确认了问题所在我会再更新本次总结。</p>
<p style="text-align: center;"><b>… End …</b></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起因：&lt;br&gt;　　最近在为在维护一个项目。在以本机为服务器做移动端测试时，出现了页面资源载入失败的情况：playback-mobile.js（如下）文件并没有被成功加载。这个错误仅出现在了魅族系列手机上的native浏览器和QQ移动浏览器（也许还有别的非主流浏览器也不支持）中。和前辈交流后认为：有可能是这个src中的localhost应该替换为服务器地址。修改后发现，问题的确是出在这里的。&lt;br&gt;　　无独有偶，在 MacOS Safari 上进行开发测试时，发现了一个更为怪异的现象：当我使用 localhost 作为域名时，我访问某个配置了全域可访问头的资源（并且只有这个资源出现了问题）时，居然提示跨域错误。查看后发现，请求完全没有发出，是浏览器直接就把请求block了。把 localhost 换成本机IP后又一切正常了。&lt;br&gt;　　事后探究了一下原因，并在此做一个总结：&lt;br&gt;
    
    </summary>
    
      <category term="计算机基础知识杂烩" scheme="http://jasonzou.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="计算机网络" scheme="http://jasonzou.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【转载】MVC, MVP, MVVM的区别和联系</title>
    <link href="http://jasonzou.me/2017/03/30/MVVM%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://jasonzou.me/2017/03/30/MVVM的联系和区别/</id>
    <published>2017-03-30T14:06:36.000Z</published>
    <updated>2017-04-04T08:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下转自：</strong><a href="http://codingjoker.github.io/" target="_blank" rel="external">JumoZhu的博客</a></p>
<a id="more"></a>
<h3 id="先说一下三者的共同点"><a href="#先说一下三者的共同点" class="headerlink" title="先说一下三者的共同点"></a>先说一下三者的共同点</h3><p>Model和ViewModel就是数据模型，同时，提供外部对应用程序数据的操作的接口，也可能在数据变化时发出变更通知。Model不依赖于View的实现，只要外部程序调用Model的接口就能够实现对数据的增删改查。<br>View就是UI层，提供对最终用户的交互操作功能，包括UI展现代码及一些相关的界面逻辑代码。</p>
<p>三者的差异在于如何粘合View和Model，实现用户的交互操作以及变更通知。</p>
<h3 id="MVC和MVP的关系"><a href="#MVC和MVP的关系" class="headerlink" title="MVC和MVP的关系"></a>MVC和MVP的关系</h3><p>MVC 进化为 MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架：<br>我们都知道MVP是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过 Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会以观察者的身份监听Model的变化，直接从Model中读取数据而不是通过 Controller。</p>
<h3 id="MVVM和MVP的关系"><a href="#MVVM和MVP的关系" class="headerlink" title="MVVM和MVP的关系"></a>MVVM和MVP的关系</h3><p>而 MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：（View的Model就是包含View的一些数据属性和操作的这么一个东东）这种模式的关键技术就是数据绑定（data binding），View的变化会直接影响ViewModel，ViewModel的变化或者内容也会直接体现在View上。这种模式实际上是框架替应用开发者做了一些工作，开发者只需要较少的代码就能实现比较复杂的交互。</p>
<h4 id="MVVM的优点"><a href="#MVVM的优点" class="headerlink" title="MVVM的优点"></a>MVVM的优点</h4><ul>
<li>低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响；</li>
<li>可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用；</li>
<li>独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModel），界面设计人员可以专注于UI(View)的设计；</li>
<li>可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单。</li>
</ul>
<h4 id="在angular中MVVM模式主要分为四部分"><a href="#在angular中MVVM模式主要分为四部分" class="headerlink" title="在angular中MVVM模式主要分为四部分"></a>在angular中MVVM模式主要分为四部分</h4><ul>
<li>View：它专注于界面的显示和渲染，在angular中则是包含一堆声明式Directive的视图模板。</li>
<li>ViewModel：它是View和Model的粘合体，负责View和Model的交互和协作，它负责给View提供显示的数据，以及提供了View中Command事件操作Model的途径；在angular中$scope对象充当了这个ViewModel的角色；</li>
<li>Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在web页面中，大部分Model都是来自Ajax的服务端返回数据或者是全局的配置对象；而angular中的service则是封装和处理这些与Model相关的业务逻辑的场所，这类的业务服务是可以被多个Controller或者其他service复用的领域服务。</li>
<li>Controller：这并不是MVVM模式的核心元素，但它负责ViewModel对象的初始化，它将组合一个或者多个service来获取业务领域Model放在ViewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态</li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;以下转自：&lt;/strong&gt;&lt;a href=&quot;http://codingjoker.github.io/&quot;&gt;JumoZhu的博客&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言知识杂烩" scheme="http://jasonzou.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="面向对象" scheme="http://jasonzou.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>【转载】《浅析nodeJS的几种文件路径》</title>
    <link href="http://jasonzou.me/2017/03/27/%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E3%80%8B/"/>
    <id>http://jasonzou.me/2017/03/27/的几种文件路径》/</id>
    <published>2017-03-27T11:10:40.000Z</published>
    <updated>2017-04-04T08:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天在使用webpack打包JS时报错，发现path不能是相对路径，发现自己对路径的理解一直都是似是而非的，在我的一位<a href="http://zerosrat.com" target="_blank" rel="external">良师益友</a>的指导帮助后学习了一下路径的相关知识。<br>　　在此转载一篇相关博客，以作记录：</p>
<p><strong>以下转自：</strong><a href="https://github.com/imsobear/blog/issues/48" target="_blank" rel="external">imsobear的博客</a></p>
<h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>　　Node 中的文件路径大概有 <strong>__dirname</strong>， <strong>__filename</strong> ， <strong>process.cwd()</strong> ， <strong>./</strong> 或者 <strong>../</strong>，前三个都是绝对路径，为了便于比较，<strong>./</strong> 和 <strong>../</strong> 我们通过 <strong>path.resolve(‘./‘)</strong> 来转换为绝对路径。</p>
<a id="more"></a>
<p>先看一个简单的例子：</p>
<p>假如我们有这样的文件结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app/</div><div class="line">  -lib/</div><div class="line">    -common.js</div><div class="line">  -model</div><div class="line">    -task.js</div><div class="line">    -test.js</div></pre></td></tr></table></figure></p>
<p>在 task.js 里编写如下的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(__dirname);</div><div class="line"><span class="built_in">console</span>.log(__filename);</div><div class="line"><span class="built_in">console</span>.log(process.cwd());</div><div class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">'./'</span>));</div></pre></td></tr></table></figure></p>
<p>在 model 目录下运行 $ node task.js 得到的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/Users/guo/Sites/learn/app/model.js</div><div class="line">/Users/guo/Sites/learn/app/model.js/task.js</div><div class="line">/Users/guo/Sites/learn/app/model.js</div><div class="line">/Users/guo/Sites/learn/app/model.js</div></pre></td></tr></table></figure></p>
<p>然后在 app 目录下运行 node model/task.js，得到的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/Users/guo/Sites/learn/app/model.js</div><div class="line">/Users/guo/Sites/learn/app/model.js/task.js</div><div class="line">/Users/guo/Sites/learn/app</div><div class="line">/Users/guo/Sites/learn/app</div></pre></td></tr></table></figure></p>
<p>那么，不好意思不是问题来了~T_T,我们可以得出一些肤浅的结论了：</p>
<ul>
<li>__dirname: 总是返回被执行的 js 所在文件夹的绝对路径</li>
<li>__filename: 总是返回被执行的 js 的绝对路径</li>
<li>process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径</li>
<li>./: 跟 process.cwd() 一样、一样、一样的吗？</li>
</ul>
<p>还是上面的结构，’model/task.js’ 里的代码改成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> common = <span class="built_in">require</span>(<span class="string">'../lib/common'</span>);</div><div class="line"></div><div class="line">fs.readFile(<span class="string">'../lib/common.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在 model 目录下运行 node task.js，一切 Ok，没有报错。然后在 app 目录下运行 node model/task.js，然后很果断滴报错了。</p>
<p>那么这下问题真的都是来了，按照上面的理论，在 app 下运行时，../lib/common.js 会被转成 /Users/guo/Sites/learn/lib/common.js，这个路径显然是不存在的，但是从运行结果可以看出 require(‘../lib/common’) 是 OK 的，只是 readFile 时报错了。</p>
<p>那么关于 ./ 正确的结论是：</p>
<p>在 require() 中使用是跟 __dirname 的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟 process.cwd() 效果相同，是相对于启动脚本所在目录的路径。</p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>只有在 require() 时才使用相对路径(./, ../) 的写法，其他地方一律使用绝对路径，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 当前目录下</div><div class="line">path.dirname(__filename) + &apos;/test.js&apos;;</div><div class="line">// 相邻目录下</div><div class="line">path.resolve(__dirname, &apos;../lib/common.js&apos;);</div></pre></td></tr></table></figure></p>
<ul>
<li><a href="http://stackoverflow.com/questions/8131344/what-is-the-difference-between-dirname-and-in-node-js" target="_blank" rel="external">参考1</a></li>
<li><a href="https://nodejs.org/api/" target="_blank" rel="external">参考2</a></li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　今天在使用webpack打包JS时报错，发现path不能是相对路径，发现自己对路径的理解一直都是似是而非的，在我的一位&lt;a href=&quot;http://zerosrat.com&quot;&gt;良师益友&lt;/a&gt;的指导帮助后学习了一下路径的相关知识。&lt;br&gt;　　在此转载一篇相关博客，以作记录：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下转自：&lt;/strong&gt;&lt;a href=&quot;https://github.com/imsobear/blog/issues/48&quot;&gt;imsobear的博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h2&gt;&lt;p&gt;　　Node 中的文件路径大概有 &lt;strong&gt;__dirname&lt;/strong&gt;， &lt;strong&gt;__filename&lt;/strong&gt; ， &lt;strong&gt;process.cwd()&lt;/strong&gt; ， &lt;strong&gt;./&lt;/strong&gt; 或者 &lt;strong&gt;../&lt;/strong&gt;，前三个都是绝对路径，为了便于比较，&lt;strong&gt;./&lt;/strong&gt; 和 &lt;strong&gt;../&lt;/strong&gt; 我们通过 &lt;strong&gt;path.resolve(‘./‘)&lt;/strong&gt; 来转换为绝对路径。&lt;/p&gt;
    
    </summary>
    
      <category term="nodeJS知识总结" scheme="http://jasonzou.me/categories/nodeJS%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://jasonzou.me/tags/JavaScript/"/>
    
      <category term="nodeJS" scheme="http://jasonzou.me/tags/nodeJS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript如何“面向对象”</title>
    <link href="http://jasonzou.me/2017/03/25/JavaScript%E5%A6%82%E4%BD%95%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://jasonzou.me/2017/03/25/JavaScript如何面向对象/</id>
    <published>2017-03-25T04:19:36.000Z</published>
    <updated>2017-05-26T07:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>不同的矛盾，只有用不同的方法才能解决。 <br> <strong>毛泽东</strong> </p>
</blockquote>
<p>　　JavaScript并不是一门严格的面向对象语言，因为JavaScript没有类。ES6给习惯了使用类的程序员们一个类的语法糖，但相较于别的面向对象语言，ES6的这个类也是很不成熟的类（将在本文后续讲详细说明）。虽然没有一个严格定义的类，但这并不影响面向对象的设计思想在JavaScript编程中发光发热。<br><a id="more"></a></p>
<h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><blockquote>
<p>百度百科：<br>　　面向对象是指一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的集合。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。狭义的“面向对象”是指在程序设计中采用封装、继承、多态等设计方法。</p>
</blockquote>
<p>　　面向对象的编程方法具有四个基本特性：</p>
<ul>
<li><p>抽象<br>我是一个前端，从日常实战中的角度出发，我认为“抽象”主要是针对两方面： </p>
<ul>
<li><p>抽象数据模型<br>如这篇博客，我要从数据层面去抽象出它的模型。得出的结果应该是类似于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="attr">title</span>: <span class="string">'JavaScript和面向对象'</span>,</div><div class="line">	<span class="attr">date</span>: <span class="string">'2017-03-25 12:19:36'</span>,</div><div class="line">	<span class="attr">categories</span>: <span class="string">'JavaScript知识总结'</span>,</div><div class="line">	<span class="attr">tags</span>: &#123;</div><div class="line">		<span class="attr">tag1</span>: <span class="string">'JavaScript'</span>,</div><div class="line">		<span class="attr">tag2</span>: <span class="string">'面向对象'</span></div><div class="line">	&#125;，</div><div class="line">	<span class="comment">//... 等等</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>抽象具体操作<br>如果将这篇博客抽象为一个对象，那么它对外并没有太多接口，只有一个提供给UI层的“读”接口。那么，“读”这个操作，就可以作为博客对象的方法被抽象出来。形如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">blog</span> </span>&#123;</div><div class="line">	<span class="comment">//提示：以下代码需经babel翻译后才能在常规生产环境中运行。</span></div><div class="line">	_data;</div><div class="line">	readData() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>._data;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>继承<br>“继承”思想是面向对象编程的重要一环，前端开发中并不缺少能用到继承的场景，如页面中常出现的列表对象：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">类</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">特征</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">父类</td>
<td style="text-align:left">普通列表</td>
<td style="text-align:left">列表</td>
</tr>
<tr>
<td style="text-align:left">子类</td>
<td style="text-align:left">可增删列表</td>
<td style="text-align:left">列表 + “增”、“删”方法</td>
</tr>
<tr>
<td style="text-align:left">“孙”类</td>
<td style="text-align:left">可增删重排序列表</td>
<td style="text-align:left">列表 + “增”、“删”方法 + 重排序方法</td>
</tr>
</tbody>
</table>
<p>　　如是就是前端开发中一个很普通的继承运用了。JavaScript没有严格定义的类，<br>　　因此JavaScript的继承相较于别的语言稍显特殊。详情将在本文后续介绍。</p>
<ul>
<li><p>封装<br>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。封装这一行为是面向对象编程的安全性保障。值得一提的是：JavaScript并没有私有变量。在ES6编程中通常约定：以下划线开头的变量（如 _data ）为私有变量。本文对封装不做详细介绍说明。</p>
</li>
<li><p>多态</p>
<blockquote>
<p>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。  </p>
</blockquote>
<p>实现多态，常见的方式无非是覆盖或重载。<br>JavaScript中，后创建的同名函数会覆盖先创建的同名函数。因此，直接在子类中重写需要实现多态的方法，覆盖从父类继承来的方法即可实现多态。<br>JavaScript的重载是颇为有趣的。JavaScript并不是理想的用于重载的语言，因为JavaScript函数对参数长度是没有限制的，因此，常规语言的重载思路并不对JavaScript适用。但，我们可以通过在函数内部判断参数类型和参数length来模拟重载。我认为，这样的灵活性是JavaScript这门语言的魅力所在。</p>
</li>
</ul>
<h3 id="为什么要面向对象"><a href="#为什么要面向对象" class="headerlink" title="为什么要面向对象"></a>为什么要面向对象</h3><p>为什么要面向对象？这是一个值得每一个前端工程师考虑的问题。JavaScript这门语言（尤其是ES6之后）也是适合使用函数式编程的。在此给出一些链接供读者参考：</p>
<ul>
<li><a href="http://taobaofed.org/blog/2017/03/16/javascript-functional-programing/" target="_blank" rel="external">我眼中的 JavaScript 函数式编程</a></li>
<li><a href="https://www.zhihu.com/question/20275578" target="_blank" rel="external">面向对象编程的弊端是什么？</a></li>
<li><a href="http://www.vaikan.com/whats-wrong-with-oop-and-fp/" target="_blank" rel="external">为什么说面向对象编程和函数式编程都有问题</a></li>
</ul>
<h3 id="ES5中的面向对象"><a href="#ES5中的面向对象" class="headerlink" title="ES5中的面向对象"></a>ES5中的面向对象</h3><p>JavaScript如何“面向对象”？这是一个非常基础的问题，我认为这是每一个前端工程师都应该花心思花时间去掌握的东西。</p>
<ul>
<li><p>首先，你要有个对象（创建对象的几种常用方法）： </p>
<ul>
<li><p>原始模式： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">'Jason'</span>,</div><div class="line">	<span class="attr">age</span>: <span class="number">21</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> Person = &#123;&#125;;</div><div class="line">Person.name = <span class="string">'Jason'</span>；</div><div class="line">Person.age = <span class="number">21</span></div></pre></td></tr></table></figure>
</li>
<li><p>原始模式的改进： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用一个函数来构造对象，解决代码重复的问题</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">name</span>: name,</div><div class="line">		<span class="attr">age</span>: age</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> personJ = Person(<span class="string">'Jason'</span>, <span class="number">21</span>);</div><div class="line"><span class="keyword">var</span> personX = Person(<span class="string">'Xku'</span>, <span class="number">18</span>);</div><div class="line"><span class="comment">// 这个模式存在的问题是，personJ和personX两个实例没有内在的联系，并不能看出他们是出于同一个原型的</span></div></pre></td></tr></table></figure>
</li>
<li><p>构造函数模式： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在函数内部使用this是构造函数的关键</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用new实例化对象</span></div><div class="line"><span class="keyword">var</span> personJ = <span class="keyword">new</span> Person(<span class="string">'Jason'</span>, <span class="number">21</span>);</div><div class="line"><span class="keyword">var</span> personX = <span class="keyword">new</span> Perspm(<span class="string">'Xku'</span>, <span class="number">18</span>);</div><div class="line"><span class="comment">// 此时personJ和personX会自动生成一个constructor属性，指向他们的构造函数</span></div><div class="line">personJ.constructor == Person <span class="comment">// true</span></div><div class="line">personX <span class="keyword">instanceof</span> Person <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
<li><p>Prototype模式： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数中可能会存在一些不变的属性</span></div><div class="line"><span class="comment">// 没有必要在每一次实例化对象的时候都将其加入新建对象之中</span></div><div class="line"><span class="comment">// 此时，我们可以采用Prototype + 构造函数模式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">Person.prototype.type = <span class="string">"哺乳动物"</span>；</div><div class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>构造函数的继承：<br>前文中已经讲到过了，JavaScript中，面向对象主要体现在对对象的封装和继承上，JavaScript常规上讲没有重载，多态的实现主要依赖覆盖，我学艺不精，在这方面暂时没有找到什么好讲的。因此，本文将重点介绍如何在使用JavaScript语言进行编程时实现封装和继承。前面已经介绍了封装。现在开始介绍继承：<br>场景：这里有个Animal类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和一个Person类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在要使Person类继承Animal类</p>
<ul>
<li><p>构造函数绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  使用call或apply方法，将父对象的构造函数绑定在子函数上</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> personJ = <span class="keyword">new</span> Person(<span class="string">'Jason'</span>, <span class="number">21</span>);</div><div class="line">conslo.log(personJ.species); <span class="comment">// 动物</span></div></pre></td></tr></table></figure>
</li>
<li><p>prototype模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将Person的prototype替换为Animal的prototype，</span></div><div class="line">Person.prototype = <span class="keyword">new</span> Animal();</div><div class="line"><span class="comment">// 注意：Person的prototype被替换后，他的constructor也被替换成Animal的了，因此注意立刻对此做出修改</span></div><div class="line">Person.prototype.constructor = Person;</div></pre></td></tr></table></figure>
</li>
<li><p>直接继承prototype</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我们可以把Animal类用prototype模式写，如是就不需要new Animal()了</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Animal.prototype.species = <span class="string">'动物'</span>；</div><div class="line">Person.prototype = Animal.prototype;</div><div class="line">Person.prototype.constructor = Person;</div><div class="line"><span class="comment">// 此方法的缺点是，任何针对Person的prototype修改，都将影响到Animal的prototype，因为二者现在属于同一内存的不同引用</span></div></pre></td></tr></table></figure>
</li>
<li><p>利用空对象作为中介</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这样，修改就不会互相影响了</span></div><div class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">F.prototype = Animal.prototype;</div><div class="line">Person.prototype = <span class="keyword">new</span> F();</div><div class="line">Person.prototype.constructor = Person;</div><div class="line"><span class="comment">// 利用这个原理，我们可以封装出一个继承方法：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    F.prototype = Parent.prototype;</div><div class="line">    Child.prototype = <span class="keyword">new</span> F();</div><div class="line">    Child.prototype.constructor = Child;</div><div class="line">    <span class="comment">// 留下通往父函数的通道</span></div><div class="line">    Child.uber = Parent.prototype;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>拷贝继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拷贝继承原理类似于上一种继承方式</span></div><div class="line"><span class="comment">// 首先依然把不变属性都绑定在prototype上</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Animal.prototype.species = <span class="string">'动物'</span>；</div><div class="line"><span class="comment">// 拷贝函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = Parent.prototype;</div><div class="line">    <span class="keyword">var</span> c = Child.prototype;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</div><div class="line">        c[i] = p[i];</div><div class="line">    &#125;</div><div class="line">    c.uber = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>非构造函数的继承：</p>
<ul>
<li><p>object() 方法<br>先来看Douglas Crockford ( json 的发明人 ) 如何实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 道格拉斯提出了一个object函数来完成非构造函数的继承</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 上面将子对象的的prototype指向父对象了，之后还需要将子对象本身的属性加上</span></div></pre></td></tr></table></figure>
</li>
<li><p>浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 顾名思义，将父对象的属性拷贝给子对象：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">p</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c = &#123;&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</div><div class="line">    c[i] = p[i];</div><div class="line">  &#125;</div><div class="line">  c.uber = p;</div><div class="line">  retrun c;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 浅拷贝的问题很明显，子类和父类的属性只是同一个内存的不同引用，因此子类修改属性，父类也会被影响</span></div></pre></td></tr></table></figure>
</li>
<li><p>深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 递归调用浅拷贝，实现深拷贝，实现真正的拷贝既可避免浅拷贝中出现的问题</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c = c || &#123;&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> p[i] === <span class="string">'object'</span>) &#123;</div><div class="line">      c[i] = (p[i].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</div><div class="line">      deepCopy(p[i], c[i]);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      c[i] = p[i];</div><div class="line">    &#125; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"><span class="comment">// PS jQuery库正是用的这种方式实现的继承</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="ES6中的面向对象"><a href="#ES6中的面向对象" class="headerlink" title="ES6中的面向对象"></a>ES6中的面向对象</h3><p>ES6给了习惯使用类的程序员们一个class语法糖，先给出<a href="http://babeljs.io/repl/" target="_blank" rel="external">babel</a>对class的翻译：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是ES6代码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name, age) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line">  sayName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// babel翻译后的代码</span></div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</div><div class="line">				<span class="keyword">var</span> descriptor = props[i];</div><div class="line">				descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</div><div class="line">				descriptor.configurable = <span class="literal">true</span>;</div><div class="line">				<span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</div><div class="line">				<span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</div><div class="line">			<span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</div><div class="line">			<span class="keyword">return</span> Constructor</div><div class="line">		&#125;</div><div class="line">	&#125;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    _classCallCheck(<span class="keyword">this</span>, Person);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  _createClass(Person, [&#123;</div><div class="line">    <span class="attr">key</span>: <span class="string">"sayName"</span>,</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">  &#125;]);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Person;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>参考代码后，发现，ES6中的类是构造函数+继承方法的一个语法糖，这里不做详细解析。考虑到原理上并无差异，这里只给出ES6 class中继承的语法供读者参考：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height, width) &#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'Polygon'</span>;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(length) &#123;</div><div class="line">    <span class="keyword">super</span>(length, length);</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'Square'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 请不要忘记 super() 倘若不调用 super() 方法，是不能调用父类方法的，子类的构造函数也无法完成。</span></div></pre></td></tr></table></figure></p>
<p>关于super()用法请参考： <a href="https://www.zhihu.com/question/38292361?sort=created" target="_blank" rel="external">ES6中的关键字super该如何理解？</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="external">阮一峰的博客</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" target="_blank" rel="external">JavaScript面向对象简介</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class" target="_blank" rel="external">MDN-JavaScript-class</a></li>
<li>百度百科</li>
<li>知乎</li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;不同的矛盾，只有用不同的方法才能解决。 &lt;br&gt; &lt;strong&gt;毛泽东&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　JavaScript并不是一门严格的面向对象语言，因为JavaScript没有类。ES6给习惯了使用类的程序员们一个类的语法糖，但相较于别的面向对象语言，ES6的这个类也是很不成熟的类（将在本文后续讲详细说明）。虽然没有一个严格定义的类，但这并不影响面向对象的设计思想在JavaScript编程中发光发热。&lt;br&gt;
    
    </summary>
    
      <category term="前端和 JavaScript 知识总结" scheme="http://jasonzou.me/categories/%E5%89%8D%E7%AB%AF%E5%92%8C-JavaScript-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面向对象" scheme="http://jasonzou.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="JavaScript" scheme="http://jasonzou.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>我目前的前端开发环境</title>
    <link href="http://jasonzou.me/2017/03/24/%E6%88%91%E7%9B%AE%E5%89%8D%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://jasonzou.me/2017/03/24/我目前的前端开发环境/</id>
    <published>2017-03-24T15:55:03.000Z</published>
    <updated>2017-03-25T03:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>工欲善其事，必先利其器。 <br> <strong>《论语·卫灵公》</strong> </p>
</blockquote>   
<p>　　我目前使用的前端开发工具：npm做包管理，webpack做工程化，babel用于翻译es6，IDE用webstorm，git用作版本控制。给自己的提醒：前端开发工具一定是在真正需要用到的时候才值得被学习使用，为了追求时髦而去学习使用工具是违背了工具的实用性这一特点的。<br><a id="more"></a></p>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>NPM（<a href="https://www.npmjs.com/" target="_blank" rel="external">官网</a>）是随同nodeJS一同安装的包管理工具，能解决NodeJS代码部署上的很多问题。常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用，前端开发中，也会常常使用别人开发的JS库。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装nodeJS后就可以使用npm进行包管理了，直接去<a href="https://nodejs.org/en/" target="_blank" rel="external">nodeJS官网</a>下载安装吧。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>npm的使用是很简单的，这里给出一个现成的<a href="http://www.runoob.com/nodejs/nodejs-npm.html" target="_blank" rel="external">详细教程</a>。</p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>Webpack是当下最热门的前端资源模块化管理和打包工具。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>首先要安装 Node.js，Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。<br>用 npm 全局安装Webpack： </p>
<pre><code># 其实不推荐全局安装，最好使用项目本地的webpack
$ npm install webpack -g
</code></pre><p>通常还需要将webpack安装进项目的依赖中，理论上每个项目都需要一个本地的webpack，这样避免了可能出现的版本冲突：</p>
<pre><code># 在项目所在的目录下
# 检查是否有package.json 没有就运行  $ npm init 
$ npm install webpack --save-dev
</code></pre><p>安装Webpack开发工具也是有意义的，Webpack Server会提供一个热更新的node后台，在实际开发时比较有用：</p>
<pre><code>#安装开发工具
$ npm install webpack-dev-server --save-dev
</code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>Webpack的使用方法很简单，只用写好它的配置文件即可，另外要注意，Loader是需要单独下载的。下面给出两篇比较详细的webpack使用教程：</p>
<ul>
<li><a href="http://www.jianshu.com/p/42e11515c10f" target="_blank" rel="external">入门Webpack，看这篇就足够了</a></li>
<li><a href="http://www.w2bc.com/Article/50764" target="_blank" rel="external">一小时包会——webpack入门指南</a></li>
</ul>
<h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>Babel is a JavaScript compiler. 这是babel给自己的介绍。通常，我是配合Webpack使用babel的，主要是用babel翻译es6，别的功能用的很少。</p>
<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><p>babel的安装很简单，还是直接用npm：</p>
<pre><code># 安装babel 作为webpack的一个loader
$ npm install --save-dev babel-loader
</code></pre><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>使用babel的第一步是配置Webpack的config文件：</p>
<pre><code># 找到config文件中的module，添加babel-loader
    module: {
      loaders: [
        { test: /\.js$/, exclude: /node_modules/, loader: &quot;babel-loader&quot;}
      ]
    }
</code></pre><p>第二步是配置.babelrc文件，这一步是关键，请参照阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="external">Babel 入门教程</a>。请记住：babel的转码规则是需要单独用npm安装的，所以配置完.babelrc文件后，还应该用npm安装对应的转码规则。</p>
<h2 id="WebStorm"><a href="#WebStorm" class="headerlink" title="WebStorm"></a>WebStorm</h2><p>WebStorm自称是最好的JavaScript IDE，简单说书我对WebStorm的看法。作为一款IDE，WebStorm吃的内存不算多，自动跳转，语法检查，自动补全这些是比较方便的，虽然sublime（当然也包括vim）配合插件也可以达成这些效果，但既然电脑能无压力的跑IDE为啥还要去用sublime呢。此外，sublime集成了版本控制插件，这点在实际开发中也是很方便的。</p>
<ul>
<li><a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="external">WebStorm官网</a></li>
<li><a href="http://www.cnblogs.com/gavin007/p/6379384.html" target="_blank" rel="external">破解WebStorm（如果经济上不是特别困难，请支持正版）</a></li>
</ul>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git就不必多说了，每个程序员都应该都会使用，哪怕确实不喜欢git，也很少有不会用git的程序员。如果是刚刚接触编程的同学可以参考<a href="http://git.oschina.net/progit/" target="_blank" rel="external">Pro Git</a>进行学习。</p>
<p>　　还有待填补的空缺：Karma之类的自动化测试工具，esLint之类的语法差错工具，CSS的预编译工具，HTML压缩工具和我不知道前端工具等等。等到有需求要用到这些新工具的时候我会学习之后再做一次总结的。</p>
<p style="text-align: center;"><b>… End …</b></p>





]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;工欲善其事，必先利其器。 &lt;br&gt; &lt;strong&gt;《论语·卫灵公》&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;   
&lt;p&gt;　　我目前使用的前端开发工具：npm做包管理，webpack做工程化，babel用于翻译es6，IDE用webstorm，git用作版本控制。给自己的提醒：前端开发工具一定是在真正需要用到的时候才值得被学习使用，为了追求时髦而去学习使用工具是违背了工具的实用性这一特点的。&lt;br&gt;
    
    </summary>
    
      <category term="工具使用技巧" scheme="http://jasonzou.me/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="webpack" scheme="http://jasonzou.me/tags/webpack/"/>
    
      <category term="前端工程化" scheme="http://jasonzou.me/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="babel" scheme="http://jasonzou.me/tags/babel/"/>
    
      <category term="git" scheme="http://jasonzou.me/tags/git/"/>
    
      <category term="WebStorm" scheme="http://jasonzou.me/tags/WebStorm/"/>
    
  </entry>
  
  <entry>
    <title>md文档编辑方法小结</title>
    <link href="http://jasonzou.me/2017/03/23/md%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://jasonzou.me/2017/03/23/md文档编辑方法小结/</id>
    <published>2017-03-23T10:33:50.000Z</published>
    <updated>2017-03-23T11:55:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>好好学习，天天向上！ <br> <strong>毛泽东</strong> </p>
</blockquote>   
<p>　　这两天学习了md文档的编辑方法。不翻墙的话，在网上比较难找到一份十分详细的markdown标签文档（这是当然的，毕竟不同的环境里有不同的md“方言”），索性就按照wiki自己动笔写一份。   </p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><pre><code>[图片名称](图片链接)
</code></pre><p><img src="http://s13.sinaimg.cn/mw690/0028V8trzy6QIsLfTeA5c&amp;690" alt="星空">  </p>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><pre><code>*强调*  **加重强调** ***加重强调斜体***    
_强调_ __加重强调__ ___加重强调斜体___
</code></pre><p><em>强调</em> 、<strong>强调</strong> 、<strong><em>强调</em></strong><br><em>强调</em> 、 <strong>强调</strong> 、<strong><em>强调</em></strong>    </p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><pre><code># 一级标题
## 二级标题
### 三级标题
...
###### 六级标题
</code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>…</p>
<h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><pre><code>一级标题
==========
二级标题
----------
</code></pre><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre><code>&gt; 这段内容会成为引用内容
</code></pre><blockquote>
<p>被引用的内容 </p>
<p>引用可以分成多行<br>    这是第二行</p>
<blockquote>
<p>这是引用中的嵌套引用。这是第一行<br>    这是第二行</p>
</blockquote>
<p>这是外层引用的第三行，前面要加一个空白的引用表示内层嵌套的结束，空行最前面的(‘&gt;’)可有可无。</p>
<p>引用可以分成多行<br>这是第二行</p>
<blockquote>
<p>这是引用中的嵌套引用。这是第一行<br>这是第二行</p>
</blockquote>
<p>这是外层引用的第三行，前面要加一个空白的引用表示内层嵌套的结束，空行最前面的(‘&gt;’)可有可无。   </p>
</blockquote>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><pre><code>[链接标题](http://链接地址.com)
</code></pre><p><a href="http://jasonzou.me">夹缝</a>  </p>
<h3 id="水平区分线"><a href="#水平区分线" class="headerlink" title="水平区分线"></a>水平区分线</h3><pre><code>* * *
***
*****
- - -
-----------
</code></pre><hr>
<hr>
<hr>
<h2 id="-1"><a href="#-1" class="headerlink" title="- - -"></a>- - -</h2><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><pre><code>文字之间，不论你空格多少次，都只会出现一个空格，并且在行首是不能添加空格的。解决方案：输出&amp;emsp; 
或是将输入法切换到全角再空格即可。
</code></pre><p>&emsp;&emsp;测试   </p>
<h3 id="方言"><a href="#方言" class="headerlink" title="方言"></a>方言</h3><p>　　一如文章开头所说，md文档在不同的环境下是有其特有方言的。故而，全部列出意义并不大，我只是将最基本的语法列出，更多的语法可以参考以下链接：    </p>
<ul>
<li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">这篇文章讲了md文档是如何兼容HTML的</a></li>
<li><a href="http://mahua.jser.me/" target="_blank" rel="external">麻花</a></li>
<li><a href="https://maxiang.io/" target="_blank" rel="external">马克飞象</a></li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>　　最后，我必须提出，md文档最后是会转译为HTML文档的，因此，只要有基本的前端知识，理论上我们是可以写出任何样式的文本的。所有的md标记，只是让文档编辑更轻松而已，实在不知道某个样式所对应的标签，不妨就用HTML将其完成吧。</p>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;好好学习，天天向上！ &lt;br&gt; &lt;strong&gt;毛泽东&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;   
&lt;p&gt;　　这两天学习了md文档的编辑方法。不翻墙的话，在网上比较难找到一份十分详细的markdown标签文档（这是当然的，毕竟不同的环境里有不同的md“方言”），索性就按照wiki自己动笔写一份。   &lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="工具使用技巧" scheme="http://jasonzou.me/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="md文档" scheme="http://jasonzou.me/tags/md%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
</feed>
