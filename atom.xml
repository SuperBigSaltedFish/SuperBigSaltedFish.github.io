<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夹缝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jasonzou.me/"/>
  <updated>2017-05-29T13:45:34.000Z</updated>
  <id>http://jasonzou.me/</id>
  
  <author>
    <name>Jason Zou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>加州招待所-神雕乐队</title>
    <link href="http://jasonzou.me/2017/05/29/%E5%8A%A0%E5%B7%9E%E6%8B%9B%E5%BE%85%E6%89%80-%E7%A5%9E%E9%9B%95%E4%B9%90%E9%98%9F/"/>
    <id>http://jasonzou.me/2017/05/29/加州招待所-神雕乐队/</id>
    <published>2017-05-29T11:52:23.000Z</published>
    <updated>2017-05-29T13:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>welcome to the hotel California <br> <strong>hotel California via Eagles</strong> </p>
</blockquote>
<p>　　hotel California 是一首深受老一代人喜爱的经典歌曲。大多人喜欢它是因为好听，并且它很适合当车载音乐。少数是因为歌词引发了听众的某些共鸣。<br><a id="more"></a><br>　　我想说的和 hotel California 这首歌并没有特别必要的关联。<br>　　但是还是有一些关联的——关于自由。<br>　　hotel California 中的 hotel 暗喻深陷于“物质”中的社会。光鲜的生活后是自我的丢失，糜烂的生活下，人们丢失了“自由”，“激情”和“信念”。<br>　　物质至上的社会中“信念”是没有意义的。你需要的不是坚持，而是随时做出“正确”的选择。<br>　　“激情”也是没有意义的，冷静的人才能最快的获得最多的“物质”。<br>　　更不要谈“自由”了。<br>　　关于“自由”，很多人存在误解，“自由”绝非为所欲为，自由的人并非没有束缚。自由的人自己束缚自己，而真正有胆识和魄力去追求自由的人，其对自己的驾驭能力以及他自己对于自身的束缚往往是极为出众和强烈的。<br>　　我看到了穿着内裤上台献唱的 guns and roses ，他的那条鲜红的内裤让我突然有了一个大概毫不相关的问题：如果，自由的人对自己的规则站在了社会规则的对立面该怎么办？其实于我而言这不是一个问题。换一个问法，倘若一个人的追求的事物不是别人允许他追求的事物该怎么办？<br>　　对于这个问题，我的回答也有些答非所问，hotel California 前两句就唱到：On a dark desert highway cool wind in my hair, warm smell of colitas rising up through the air. colitas 是西班牙语，是在美国年轻人中极为流行的大麻。而这里说的大麻的香气飘荡的地方，指的是 hotel California ，也就是深陷于“物质”中的社会。这个社会有一种神奇的魔力，这种魔力让人昏沉，产生幻觉而后又飘飘欲仙，最终丢失自我。<br>　　所谓的实业家们创造的崇尚物质的社会，是反对毒品的，这个社会有它自己特有的毒品：香车，美女，帅哥，归根到底，钱所象征的物质，就是这个时代的毒品。他们先是反对毒品，然后又醉心于一些无异于毒品的追求。<br>　　不吸食毒品，是因为毒品可能会让你丢失你真正所想要追求的东西。为什么说“可能”，是因为有人真的追求的就是吸毒，并最终死在吸毒的过程中。而倘若别人对你的束缚，或者对你的“教育”，也会像毒品一样，试图赋予你一些它想赋予你的志趣，不管这个志趣是帮扶弱小，维护和平，尊老爱幼或是别的什么，总之他最终让丢失你真正想追求的东西。你是不是还是会毫无疑虑地接受你的国家甚至你的家庭对你的塑造？<br>　　他们对你唱到：welcome to hotel California, such a lovely place, such a lovely face. 这里的每个人都载歌载舞，这里欢声笑语。然后你也开始成为欢声笑语的一部分，丧失“自由”，丧失只属于自己的“激情”和“信念”。<br>　　但其实我是痛恨自由的。这是一种根本不能带给你快乐的东西。有人把自由比喻成翅膀，幻想自由就是为所欲为，对自由充满离谱的臆想和无知的向往。殊不知它更像是断掉的腿。自由的人是危险的，不健全的，自由不是一种高尚的属性，而是人类在进化中出现的一种华丽而炫目的残疾。<br>　　曾经看到有个人做过一个精彩的比喻。问：为什么有些人觉得哲学索然无味，而有些人对哲学极为痴迷。答：因为哲学是药，爱好思考的人是病患。生病的人才需要吃药。没病的人不需要吃药。<br>　　自由也是类似的，这其实是一种无法治愈的疾病。没有患病的人对其存在着误解，就像对思索没有兴趣的人对哲学会抱有错觉一样。<br>　　当你从 hotel California 夺门而出的那一刻开始，痛苦和迷惘就会开始成为生命的主旋律。你丧失了麻痹自己的能力，不能沉溺进别人给你营造的温柔乡中。<br>　　陷入孤独，然后避开其他的人，你是空间中唯一的一个点。只有唯一的一个点才是自由的，如果只有一个点，那么坐标轴不管怎么定，点的位置都是不会改变的，改变坐标轴，点也是从没有位置到没有位置。<br>　　没有坐标轴的唯一一个点，怎么可能不迷茫，不孤独。<br>　　最可怕的是，如果让你再选择一次，要不要成为一个自由的人，你不可能拒绝。哪怕你憎恶它，抗拒它，你也无法逃脱它对你的吸引。<br>　　这是最完美的毒药，让所有尝过它的人都愿意死在它手里，不论多少次，都愿意死在它手里。</p>
<p style="text-align: center;"><b>… End …</b></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;welcome to the hotel California &lt;br&gt; &lt;strong&gt;hotel California via Eagles&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　hotel California 是一首深受老一代人喜爱的经典歌曲。大多人喜欢它是因为好听，并且它很适合当车载音乐。少数是因为歌词引发了听众的某些共鸣。&lt;br&gt;
    
    </summary>
    
      <category term="胡诌" scheme="http://jasonzou.me/categories/%E8%83%A1%E8%AF%8C/"/>
    
    
      <category term="音乐" scheme="http://jasonzou.me/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>【转载】深入理解CSS：字体宽度、line-height和vertical-align</title>
    <link href="http://jasonzou.me/2017/05/26/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CSS%EF%BC%9A%E5%AD%97%E4%BD%93%E5%AE%BD%E5%BA%A6%E3%80%81line-height%E5%92%8Cvertical-align/"/>
    <id>http://jasonzou.me/2017/05/26/【转载】深入理解CSS：字体宽度、line-height和vertical-align/</id>
    <published>2017-05-26T07:53:29.000Z</published>
    <updated>2017-05-26T09:40:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="译者的话"><a href="#译者的话" class="headerlink" title="译者的话"></a>译者的话</h3><p>　　这是一篇译文，对 inline 和 inline-block 的元素剖析非常给力。<br>　　原文：<a href="http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align" target="_blank" rel="external">Deep dive CSS: font metrics, line-height and vertical-align - Vincent De Oliveira</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　line-height 和 vertical-align 都是简单的 CSS 属性，以致于大多数人自以为知道这两个属性的工作原理。但实际上这两个属性非常复杂，也许算得上是 CSS 里最难的两个属性，因为这两个属性和 CSS 里一个鲜为人知的特性息息相关：内联格式化上下文（IFC）（译者注：和 BFC 相对应）。</p>
<p>　　举例来说，line-height 的值可以是一个长度（length）或者是一个数字，它的默认值是 normal。那么，normal 是什么呢？我们经常将 normal 理解为 1，或者 1.2，甚至连 CSS 规格文档都没有提到这一问题。我们知道 line-height 的值为数字时，表示的相对于 font-size 的倍数，但问题在于，font-size:100px 对应的文字在不同字体里的高度是不一样的！那么 line-height 会随着文字大小的改变而改变吗？ normal 真的表示 1 或者 1.2 吗？vertical-align 又是如何被 line-height 影响的呢？</p>
<p>　　让我们来深入理解一个不那么简单的 CSS 机制。</p>
<h3 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h3><p>　　下面是一段简单的 HTML 代码，一个 p 标签包含了 3 个 span 标签，每个 span 各自有一个 font-family：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"a"</span>&gt;</span>Ba<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"b"</span>&gt;</span>Ba<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"c"</span>&gt;</span>Ba<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-size</span>: <span class="number">100px</span> &#125;</div><div class="line"><span class="selector-class">.a</span> &#123; <span class="attribute">font-family</span>: Helvetica &#125;</div><div class="line"><span class="selector-class">.b</span> &#123; <span class="attribute">font-family</span>: Gruppo    &#125;</div><div class="line"><span class="selector-class">.c</span> &#123; <span class="attribute">font-family</span>: Catamaran &#125;</div></pre></td></tr></table></figure>
<p>（译者注：这几款字体你的电脑上可能没有）</p>
<p>　　font-size 相同，font-family 不同，得到的 span 元素的高度也不同：</p>
<p><img src="https://pic3.zhimg.com/v2-ff69639abd00ebd75258a583963df65a_b.png" alt="展示"></p>
<p>　　为什么 font-size: 100px 不能得到相同高度的元素呢？我测量了一下每个 span 的高度：Helvetica 115px，Gruppo 97px，Catamaran 164px。</p>
<p><img src="https://pic3.zhimg.com/v2-c563ed710d244632fc7a734f52f33e7e_b.png" alt="展示2"></p>
<p>　　乍看很奇怪，但是仔细想想，这么做又是很有道理的。原因在于字体本身，这是字体的原理：</p>
<ul>
<li>一款字体会定义一个 em-square，它是用来盛放字符的金属容器。这个 em-square 一般被设定为宽高均为 1000 相对单位，不过也可以是 1024、2048 相对单位。<br><img src="https://pic1.zhimg.com/v2-4c684524b8d37789295f6db964201c74_b.png" alt="展示3"></li>
<li><p>字体度量都是基于这个相对单位设置的，包括 ascender、descender、capital height、x-height 等。注意这里面的值是允许相对于 em-square 出血（bleed outside）的（译者注：大概可以理解为超出 em-square）<br><img src="https://pic4.zhimg.com/v2-7f1590fecc2f79484b22f38e2869d83b_b.jpg" alt="展示4"></p>
</li>
<li><p>在浏览器中，，上面的 1000 相对单位会按照你需要的 font-size 缩放。<br>我们把 Catamaran 字体放到 FontForge 中，分析它的字体度量：</p>
<ul>
<li>em-square 是 1000</li>
<li>ascender 是 1100，descender 是 540。通过测试发现，macOS 上的浏览器使用了 HHead Ascent 和 HHead Descent 值，Windows 上的浏览器使用了 Win Ascent 和 Win Descent（而且两个平台上的值不一样）。我们还看到 Capital Height 是 680，X height 是 485。<br><img src="https://pic4.zhimg.com/v2-8fa5fa46b571db21c79bda208d6263c3_b.png" alt="展示5"></li>
</ul>
</li>
</ul>
<p>　　这意味着 Catamaran 字体占据了 1100 + 540 个相对单位，尽管它的 em-square 只有 1000 个相对单位，所以当我们设置 font-size:100px 时，这个字体里的文字高度是 164px。这个计算出来的高度决定了 HTML 元素的 content-area（内容区域），后面我会讲到 content-area。你可以认为 content-area 就是 background 作用的区域。</p>
<p>　　我们还能看出大写字母的高度是 68px，小写字母的高度（x-height）是 49px。所以 1ex = 49px，1em = 100px，而不是 164px。（真好，em 是基于 font-size，而不是基于计算出来的高度）</p>
<p><img src="https://pic4.zhimg.com/v2-cb05dd4dc6908e522c0f69392ed1fe87_b.png" alt="展示6"></p>
<p>　　在继续深入之前，说点相关的知识。当 p 元素出现在屏幕上时，它可能包含了多行内容，每行内容由多个内联元素组成（内联标签或者是包含文本的匿名内联元素），每一行都叫做一个 line-box。line-box 的高度是由它所有子元素的高度计算得出的。浏览器会计算这一行里每个子元素的高度，再得出 line-box 的高度（具体来说就是从子元素的最高点到最低点的高度），所以默认情况下，一个 line-box 总是有足够的高度来容纳它的子元素。</p>
<pre><code>每个 HTML 元素实际上都是由多个 line-box 的容器组成的，
如果你知道每个 line-box 的高度，那么你就知道了整个元素的高度。
</code></pre><p>如果我们修改一下最初的 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">    Good design will be better.</div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"a"</span>&gt;</span>Ba<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"b"</span>&gt;</span>Ba<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"c"</span>&gt;</span>Ba<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    We get to make a consequence.</div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p>那么就会得到 3 个 line-box（宽度固定）：</p>
<ul>
<li>第一行和最后一行各有一个匿名内联元素（文本内容）</li>
<li>中间一行包含两个匿名内联元素和三个 span</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-cc56c718642f701c3f8739ee7a4453cf_b.png" alt="展示7"></p>
<p>　　我们清楚地看到第二个 line-box 比其他两个要高一些。因为第二行里面的子元素因为有一个用到了 Catamaran 字体的 span。</p>
<p>　　line-box 的难点在于我们看不见它，而且不能用 CSS 控制它。即使我们用 ::first-line 给第一行加上背景色，我们也看不出第一个 line-box 的高度。</p>
<h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h3><p>　　目前我已经提到了两个概念：content-area 和 line-box。如果你仔细看了，会发现我说 line-box 的高度是根据子元素的高度计算出来的，而不是子元素的 content-area 的高度。这个区别大了。</p>
<p>　　接下来说句听起来很奇怪的话：一个内联元素有两个高度：content-area 高度和 virtual-area （实际区域？）高度（virtual-area 是我自己发明的单词，它表示对人类有效的高度，你在其他地方是看不到这个单词的）。</p>
<p>　　content-area 的高度是由字体度量定义的（见上文）<br>　　vitual-area 的高度就是 line-height，这个高度用于计算 line-box 的高度</p>
<p><img src="https://pic4.zhimg.com/v2-efe30b60d553cb6237f9c0cbdebb240b_b.png" alt="展示8"></p>
<p>　　这么一来，这就打破了一个长久的谣言：line-height 表示两个 baseline 之间的距离。在 CSS 里，不是这样的。</p>
<p><img src="https://pic3.zhimg.com/v2-0301a379ebf7d2dfcbb995c4a2cfc7fa_b.png" alt="展示9"></p>
<p>　　virtual-area 和 content-area 高度的差异叫做 leading。leading 的一半会被加到 content-area 顶部，另一半会被加到底部。因此 content-area 总是处于 virtual-area 的中间。</p>
<p>　　计算出来的 line-height（也就是 virtual-area 的高度）可以等于、大于或小于 content-area。如果 virtual-area 小于 content-area，那么 leading 就是负的，因此 line-box 看起来就比内容还矮了。</p>
<p>　　还有一些其他种类的内联元素：</p>
<ul>
<li>可替换的内联元素，如 img / input / svg 等</li>
<li>inline-block 元素，以及所有 display 值以 inline- 开头的元素，如 inline-table / inline-flex</li>
<li>处于某种特殊格式化上下文的内联元素，例如 flexbox 元素中的子元素都处于 flex formatting context（弹性格式化上下文）中，这些子元素的 display 值都是「blockified」</li>
</ul>
<p>　　这类内联元素，其高度是基于 height、margin 和 border 属性（译者注：好像漏了 padding）。如果你将其 height 设置为 auto 的话，那么其高度的取值就是 line-height，其 content-area 的取值也是 line-height。</p>
<p><img src="https://pic4.zhimg.com/v2-924b688268ae43ff1c6ccda3bec78123_b.png" alt="展示10"></p>
<p>　　我们目前依然没有解释 line-height:normal 是什么意思。要解答这个问题，我们又得回到 content-area 高度的计算了，问题的答案就在字体度量里面。</p>
<p>　　我们回到 FontForge，Catamaran 的 em-square 高度是 1000，同时我们还看到很多其他的 ascender/descender 值：</p>
<p><img src="https://pic4.zhimg.com/v2-8fa5fa46b571db21c79bda208d6263c3_b.png" alt="展示11"></p>
<ul>
<li>常规的 Ascent/Descent：ascender 是 770，descender 是 230，用于渲染字符。</li>
<li>规格 Ascent/Descent：ascender 是 1100，descender 是 540。用于计算 content-area 的高度</li>
<li>规格 Line Gap：用于计算 line-height: normal。</li>
</ul>
<p>　　在 Catamaran 这款字体中，Line Gap 的值是 0，那么 line-height: normal 的结果就跟 content-area 的高度一样，是 1640 相对单位。</p>
<p>　　为了对比，我们再看看 Arial 字体，它的 em-square 是 2048，ascender 是 1854，descender 是 434，line gap 是 67。那么当 font-size: 100px 时，</p>
<ul>
<li>其 content-area 的高度就是 100/2048*(1854+434) = 111.72，约为 112px；</li>
<li>其 line-height: normal 的结果就是 100/2048*(67+1854+434) 约为 115px。</li>
</ul>
<p>　　所有这些值都是由字体设计师设置的。</p>
<p>　　这么看来，line-height:1 就是一个很糟糕的实践。记得吗，当 line-height 的值是一个数字时，其实就是相对 font-size 的倍数，而不是相对于 content-area。所以 line-height:1 很有可能使得 virtual-area 比 content-area 矮，从而引发很多其他的问题。</p>
<p><img src="https://pic2.zhimg.com/v2-01f0ec3f893c7162af0b6104cfc304e5_b.png" alt="展示12"></p>
<p>　　不仅仅是 line-height:1 有问题，我电脑上的 1117 款字体中，大概有 1059 款字体的 line-height 比 1 大，最低的是 0.618，最高的是 3.378。你没看错，是 3.378！</p>
<p>　　line-box 计算的一些细节：</p>
<ul>
<li>对于内联元素，padding 和 border 会增大 background 区域，但是不会增大 content-area（不是 line-box 的高度）。一般来说你无法再屏幕上看到 content-area。margin-top 和 margin-bottom 对两者都没有影响。</li>
<li>对于可替换内联元素（replaced inline elements）、inline-block 元素和 blockified 内联元素，padding、margin 和 border 会增大 height（译者注：注意 margin），因此会影响 content-area 和 line-box 的高度</li>
</ul>
<h3 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h3><p>　　我还没提过 vertical-align 属性，它也是计算 line-box 高度的重要因素之一。我们甚至可以说 vertical-align 是内联格式化上下文（IFC）中最重要的属性。</p>
<p>　　它的默认值是 baseline。还记得字体度量里的 ascender 和 descender 吗？这两个值决定了 baseline 的位置。很少有</p>
<p>　　字体的 ascender 和 descender 的比例是一比一的，所以我们经常看到一些意想不到的现象，下面是例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Ba<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Ba<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">font-family</span>: Catamaran;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　一个 p 标签内有两个 span 标签，span 继承了 font-family、font-size 和 200px 的 line-height。这时两个 span 的 baseline 是等高的，line-box 的高度就是 span 的 line-height。</p>
<p><img src="https://pic4.zhimg.com/v2-4a182cd5a309f5b689c95ca730c0ae4f_b.png" alt="展示13"></p>
<p>如果第二个 span 的 font-size 变小了呢？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:last-child</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　我们会发现一个非常奇怪的现象，line-box 的高度变高了！如下图所示。提示你一下，line-box 的高度是从子元素的最高点到最低点的举例。</p>
<p><img src="https://pic4.zhimg.com/v2-d310ad9f4882c1466a1cf11dee3f20ab_b.png" alt="展示14"></p>
<p>　　这个例子可以作为「应该将 line-height 的值写成数字」的论据，但是有时候我们为了做出好看的排版，必须把 line-height 写成一个固定值。</p>
<p>　　不过我实话告诉你吧，不管你把 line-height 写成什么，你都会在对齐内联元素的时候遇到麻烦。</p>
<p>　　我们来看另一个例子。p 标签有 line-height:200px，内含一个 span，span 继承了 p 的 line-height。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Ba<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">span</span> &#123;</div><div class="line">    <span class="attribute">font-family</span>: Catamaran;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">100px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　此时 line-box 的高度是多少？貌似是 200px，但其实不是。这里你没有考虑到的问题是 p 有自己的 font-family，默认值是 serif。p 的 baseline 和 span 的 baseline 位置不一样，因此最终的 line-box 比我们预想的要高一些。出现这种问题是因为浏览器认为每个 line-box 的起始位置都有一个宽度为 0 的字符（CSS 文档将其称为 strut），并将其纳入 line-box 的高度的计算中。</p>
<pre><code>看不见的字符，看得见的影响。
</code></pre><p>　　为了说明这个问题，我们画图解释一下这个问题。<br><img src="https://pic1.zhimg.com/v2-f96851b7a279b35a12dea987bae3bff0_b.png" alt="展示15"></p>
<p>　　用 baseline 来对齐令人费解，如果我们用 vertical-align: middle 会不会好一点呢？读 CSS 文档你会发现，middle 的意思是「用父元素 baseline 高度加上父元素中 x-height 的一半的高度来对齐当前元素的垂直方向的中点」。baseline 所处的高度跟字体有关，x-height 的高度也跟字体有关，所以 middle 对齐也不靠谱。更糟糕的是，一般来说，middle 根本就不是居中对齐！内联元素的对齐受太多因素影响，因此不可能用 CSS 实现。</p>
<p>顺便一说，vertical-align 的其他 4 个值有可能有点用：</p>
<ul>
<li>vertical-align: top / bottom，表示与 line-box 的顶部或底部对齐</li>
<li>vertical-align: text-top / text-bottom，表示与 content-area 的顶部或底部对齐<br><img src="https://pic2.zhimg.com/v2-c4550a3a0387a2dd7fd323bd9e98ccf5_b.png" alt="展示16"></li>
</ul>
<p>不过你依然要小心，大部分情况下，对齐的是 virtual-area，也就是一个不可见的高度。看看下面这个用 vertical-align:top 的例子：<br><img src="https://pic2.zhimg.com/v2-c72edc431fa40ef60a890895a3b7a53d_b.png" alt="展示17"></p>
<p>最后，vertical-align 的值也可以是数字，表示根据 baseline 升高或降低，不到万不得已还是别用数字吧。</p>
<h3 id="CSS-is-awesome"><a href="#CSS-is-awesome" class="headerlink" title="CSS is awesome"></a>CSS is awesome</h3><p>　　我们讨论了 line-height 和 vertical-align 如果互相影响，现在问题来了：CSS 可以控制字体度量吗？简单来说答案是：不行。我也很想用 CSS 来控制字体。无论怎样，我还是想试试。字体度量只是一些固定的值而已，我们应该可以围绕它做点什么。</p>
<p>　　比如说，我们想要一段文字使用 Catamaran 字体，同时大写字母的高度正好是 100px，看起来可以实现，我们只需要一些数学知识。</p>
<p>　　首先我们把所有字体度量设置为 CSS 自定义属性，然后计算出一个 font-size，让大写字母的高度正好是 100px。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="comment">/* font metrics */</span></div><div class="line">    <span class="attribute">--font</span>: Catamaran;</div><div class="line">    <span class="attribute">--fm-capitalHeight</span>: <span class="number">0.68</span>;</div><div class="line">    <span class="attribute">--fm-descender</span>: <span class="number">0.54</span>;</div><div class="line">    <span class="attribute">--fm-ascender</span>: <span class="number">1.1</span>;</div><div class="line">    <span class="attribute">--fm-linegap</span>: <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* desired font-size for capital height */</span></div><div class="line">    <span class="attribute">--capital-height</span>: <span class="number">100</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* apply font-family */</span></div><div class="line">    <span class="attribute">font-family</span>: <span class="built_in">var</span>(--font);</div><div class="line"></div><div class="line">    <span class="comment">/* compute font-size to get capital height equal desired font-size */</span></div><div class="line">    <span class="attribute">--computedFontSize</span>: (<span class="built_in">var</span>(--capital-height) / <span class="built_in">var</span>(--fm-capitalHeight));</div><div class="line">    <span class="attribute">font-size</span>: <span class="built_in">calc</span>(var(--computedFontSize) * <span class="number">1px</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/v2-a98593192b4f3ab90d9cabf93d390d63_b.png" alt="展示18"></p>
<p>　　看起来也并不复杂不是吗？如果我们想要文字垂直居中怎么办呢？也就是让 B 上面的空间和下面的空间高度一样。为了做到这一点，我们必须要根据 ascender 和 descender 的比例来计算 vertical-align。</p>
<p>　　首先计算出 line-height:normal 的值和 content-area 的高度：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">    …</div><div class="line">    --lineheightNormal: (var(--fm-ascender) + var(--fm-descender) + var(--fm-linegap));</div><div class="line">    --contentArea: (var(--lineheightNormal) * var(--computedFontSize));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要计算：</p>
<ul>
<li>B 下面空间的高度</li>
<li>B 上面空间的高度</li>
</ul>
<p>像这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">    …</div><div class="line">    --distanceBottom: (var(--fm-descender));</div><div class="line">    --distanceTop: (var(--fm-ascender) - var(--fm-capitalHeight));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们就可以计算 vertical-align 的值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">    …</div><div class="line">    --valign: ((var(--distanceBottom) - var(--distanceTop)) * var(--computedFontSize));</div><div class="line">&#125;</div><div class="line">span &#123;</div><div class="line">    vertical-align: calc(var(--valign) * -1px);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，设置 line-height：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">    …</div><div class="line">    /* desired line-height */</div><div class="line">    --line-height: 3;</div><div class="line">    line-height: calc(((var(--line-height) * var(--capital-height)) - var(--valign)) * 1px);</div><div class="line">&#125;</div><div class="line">```	</div><div class="line">![展示19](https://pic1.zhimg.com/v2-86b09b1ecc3a6c745bcb2d096e8edeec_b.png)</div><div class="line"></div><div class="line">添加一个和 B 一样高的 icon 就很容易了：</div><div class="line"></div><div class="line">``` CSS</div><div class="line">span::before &#123;</div><div class="line">    content: '';</div><div class="line">    display: inline-block;</div><div class="line">    width: calc(1px * var(--capital-height));</div><div class="line">    height: calc(1px * var(--capital-height));</div><div class="line">    margin-right: 10px;</div><div class="line">    background: url('https://cdn.pbrd.co/images/yBAKn5bbv.png');</div><div class="line">    background-size: cover;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/v2-58a9a7710e144601bc632c629983bb6d_b.png" alt="展示20"></p>
<p><a href="http://jsbin.com/tufatir/edit?css,output" target="_blank" rel="external">jsbin 演示效果</a></p>
<p>注意这只是为了演示，请不要在生产环境中使用此方案。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们知道了：</p>
<ul>
<li>IFC 真的很难懂</li>
<li>所有的内联元素都有两个高度<ul>
<li>基于字体度量的 content-area</li>
<li>virtual-area（也就是 line-height ）</li>
<li>这两个高度你都无法看到</li>
</ul>
</li>
<li>line-height: normal 是基于字体度量计算出来的</li>
<li>line-height: n (n=1,2,3…) 可能得出一个比 virtual-area 还要矮的 content-area</li>
<li>vertical-align 不靠谱</li>
<li>line-box 的高度的受其子元素的 line-height 和 vertical-align 的影响</li>
<li>我们无法轻易的用 CSS 来控制字体度量<br>但是我依然喜欢 CSS ：）</li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>















]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;译者的话&quot;&gt;&lt;a href=&quot;#译者的话&quot; class=&quot;headerlink&quot; title=&quot;译者的话&quot;&gt;&lt;/a&gt;译者的话&lt;/h3&gt;&lt;p&gt;　　这是一篇译文，对 inline 和 inline-block 的元素剖析非常给力。&lt;br&gt;　　原文：&lt;a href=&quot;h
    
    </summary>
    
      <category term="前端和 JavaScript 知识总结" scheme="http://jasonzou.me/categories/%E5%89%8D%E7%AB%AF%E5%92%8C-JavaScript-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="CSS" scheme="http://jasonzou.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>入门函数式编程</title>
    <link href="http://jasonzou.me/2017/05/12/%E5%85%A5%E9%97%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://jasonzou.me/2017/05/12/入门函数式编程/</id>
    <published>2017-05-12T02:50:03.000Z</published>
    <updated>2017-05-12T06:40:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先想说"><a href="#首先想说" class="headerlink" title="首先想说"></a>首先想说</h3><p>　　三个月前，公司有前辈向我建议，应该学习一下函数式编程。三个月来，在有空的时候会看看函数式编程相关的博客、教程和书籍，但一直没有花时间整理自己所学。四天前，仔细思考了一下自己对函数式编程思想的理解，发现其在我脑中完全处在一个混沌的状态，因此打算借这两周任务较少，完成一次对函数式编程的入门，并写下本文作为记录。<br>　　本文主要记录了：什么是函数式编程、为什么要进行函数式编程和如何学习和使用函数式编程三个问题。考虑到我立志做一个前端工程师，应用和举例时，我会尽可能的使用 JavaScript 语言。<a id="more"></a></p>
<h3 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h3><h4 id="简单地说，什么是函数式编程"><a href="#简单地说，什么是函数式编程" class="headerlink" title="简单地说，什么是函数式编程"></a>简单地说，什么是函数式编程</h4><p>　　函数式编程是一种编程范式。常见的编程范式有：命令式编程、逻辑式编程和函数式编程。而常见的面向对象编程也是一种命令式编程。<br>　　命令式编程是面向计算机硬件的抽象，有变量（对应着存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令）。用一句话总结：命令式程序就是一个冯诺依曼机的指令序列。<br>　　而函数式程序是面对数学的抽象，将计算描述为一种表达式求值。用一句话总结：函数式程序就是一个表达式。<br>　　值得一提的是：函数式编程的“函数”并非编程语言中的函数，而是数学领域的函数——是自变量的映射。<br>　　函数式编程有几大特征：函数是一等公民、函数无副作用、变量不变和闭包。</p>
<h4 id="什么是一等公民的函数"><a href="#什么是一等公民的函数" class="headerlink" title="什么是一等公民的函数"></a>什么是一等公民的函数</h4><p>　　程序世界中，有且不仅有这么几种权力：创建、赋值和传递。<br>　　非一等公民的函数是不具备这些权利的，只能依附拥有这些权力的 object 才可以完成这些操作。而一等公民的函数就不需要依托 object 完成这一系列操作。<br>　　以 JavaScript 为例，JavaScript 中，函数是一等公民。因此我们可以直接对函数进行赋值，传值等操作（ JavaScript 中，函数本身也是对象）。我们甚至可以把函数作为参数传递给别的函数。比如大家从初学前端就会用的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> clickHandler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'我是一等公民。'</span>)；</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> someBtn = <span class="built_in">document</span>.querySelector(<span class="string">'.someBtn'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 我们在此可以将 clickHandler 函数直接作为参数传递给 addEventListener 函数。</span></div><div class="line">someBtn.addEventListener(<span class="string">'click'</span>, clickHandler);</div></pre></td></tr></table></figure></p>
<h4 id="什么是无副作用的函数"><a href="#什么是无副作用的函数" class="headerlink" title="什么是无副作用的函数"></a>什么是无副作用的函数</h4><p>　　无副作用的函数又可以叫做纯函数（ pure function ）。它是指同时满足以下两个条件的函数：</p>
<ul>
<li>函数的结果只依赖于输入的参数且与外部系统状态无关——只要输入相同，返回值总是不变的。</li>
<li>除了返回值外，不修改程序的外部状态（比如全局变量、入参）。——满足这个条件也被称作“没有副作用 (side effect)”。</li>
</ul>
<p>　　函数式编程中常提到“引用透明”，“引用透明”就是指：如果一个表达式，对于相同的输入，总是有相同的结果并且不修改程序其他部分的状态，那么这个表达式是引用透明的。<br>　　因为函数式编程建议甚至强制使用纯函数，所以函数式程序是不需要维护状态的。这是其优势之一。
　　</p>
<h4 id="什么是无污染的变量"><a href="#什么是无污染的变量" class="headerlink" title="什么是无污染的变量"></a>什么是无污染的变量</h4><p>　　无污染的变量和纯函数是结对出现的。变量无法被改变，所有声明的变量都是作为数学定义中的变量，而非一块存储区域。因此，变量包括“对象”的状态是无法被修改的。</p>
<h4 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h4><p>　　闭包就不在这里详细讲说了，相信有 JavaScript 基础的同学是很清楚闭包原理的。</p>
<h3 id="为什么要使用函数式编程"><a href="#为什么要使用函数式编程" class="headerlink" title="为什么要使用函数式编程"></a>为什么要使用函数式编程</h3><h4 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h4><p>　　CPU 的发展已经不满足摩尔定律了，因此现代 CPU 的性能提升主要是依赖增加其核心数，多线程编程是大势所趋。而传统面向对象编程对于多线程的支持非常无力，状态维护成本高。而函数式编程中不存在状态，因为多个线程之间不需要共享状态，不会造成资源争用，也就不需要用锁来保护可变状态。也就不会出现死锁。这样有利于在对称多处理器架构下尽可能多的使用到各个处理器（核），提高程序的并行处理能力。<br>　　除此之外，函数式编程是使用的数学思想，更贴近人类语言，可读性和可维护性都是极高的。<br>　　当然，函数式编程对程序员更友善也是有代价的，和机器语言的差别导致函数式编程很不擅长处理 IO ，也不擅长维护状态（这是当然的）。</p>
<h3 id="如何学习和使用函数式编程"><a href="#如何学习和使用函数式编程" class="headerlink" title="如何学习和使用函数式编程"></a>如何学习和使用函数式编程</h3><h4 id="我也不是一个熟练的使用者"><a href="#我也不是一个熟练的使用者" class="headerlink" title="我也不是一个熟练的使用者"></a>我也不是一个熟练的使用者</h4><p>　　前几天我花了不少时间搞清楚到底什么是函数式编程，这种编程范式到底是要做什么事。但是对于怎么使用函数式编程，我甚至不敢以“入门”自居，只敢说是刚从门外汉转变为一个初学者，在这里给大家分享一些学习资料为主。</p>
<h4 id="阮一峰老师的函数式编程入门："><a href="#阮一峰老师的函数式编程入门：" class="headerlink" title="阮一峰老师的函数式编程入门："></a>阮一峰老师的函数式编程入门：</h4><p>　　<a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="external">函数式编程入门教程</a>：本文中阮老师主要给大家介绍了函数式编程的数学理论源头。如果是真心想深入学习函数式编程的同学，兴许可以从这篇文章中找到门路。</p>
<h4 id="阮一峰老师的图解-Monad-："><a href="#阮一峰老师的图解-Monad-：" class="headerlink" title="阮一峰老师的图解 Monad ："></a>阮一峰老师的图解 Monad ：</h4><p>　　<a href="http://www.ruanyifeng.com/blog/2015/07/monad.html" target="_blank" rel="external">图解 Monad</a>：Monad 是学习函数式编程所绕不开的一环，它也曾让阮老师感到困惑，这里是阮老师的一篇非常好的介绍 Monad 的文章。</p>
<h4 id="JavaScript-的函数式编程："><a href="#JavaScript-的函数式编程：" class="headerlink" title="JavaScript 的函数式编程："></a>JavaScript 的函数式编程：</h4><p>　　<a href="https://blog.oyanglul.us/javascript/functional-javascript.html" target="_blank" rel="external">Functional JavaScript Mini Book</a>：关注这个作者，你能学到更多。</p>
<h4 id="JS函数式编程指南："><a href="#JS函数式编程指南：" class="headerlink" title="JS函数式编程指南："></a>JS函数式编程指南：</h4><p>　　<a href="https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details" target="_blank" rel="external">JS函数式编程指南</a>：一本中文的，JavaScript 函数式编程指南，主要讲的是怎么具体用函数式编程。</p>
<h4 id="当然，你可能还需要补充-JavaScript-的基础知识："><a href="#当然，你可能还需要补充-JavaScript-的基础知识：" class="headerlink" title="当然，你可能还需要补充 JavaScript 的基础知识："></a>当然，你可能还需要补充 JavaScript 的基础知识：</h4><p>　　<a href="https://developer.mozilla.org/cn/docs/Web/JavaScript/Closures" target="_blank" rel="external">比如，你还没有弄清楚什么是闭包</a>：闭包对于函数式编程是意义重大的，没有闭包，我就不知道怎么进行函数的科里化了。</p>
<h4 id="函数式编程的模式匹配："><a href="#函数式编程的模式匹配：" class="headerlink" title="函数式编程的模式匹配："></a>函数式编程的模式匹配：</h4><p>　　<a href="http://www.cnblogs.com/SinSay/archive/2010/09/20/1831455.html" target="_blank" rel="external">pattern matching</a>：又一个函数式编程必须掌握的技巧。</p>
<h3 id="最后想说"><a href="#最后想说" class="headerlink" title="最后想说"></a>最后想说</h3><p>　　本文引用了大量的知乎内容，由于引用知乎流程太麻烦了，我就不写引用了。这是不对的。我知道。<br>　　我认为函数式编程在将来很可能成为一种程序员非常值得掌握乃至必须掌握的编程范式。很有学习的意义，我非常希望本文不是你了解函数式编程的终点而是起点。</p>
<h4 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h4><p>　　如果希望自己不再对诸如函数式编程这样的“突然兴起”的技术感到懵逼或是迷茫。你需要一本 SICP 。我认为每一个真正的程序员都应该通读并理解 SICP 。</p>
<p style="text-align: center;"><b>… End …</b></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;首先想说&quot;&gt;&lt;a href=&quot;#首先想说&quot; class=&quot;headerlink&quot; title=&quot;首先想说&quot;&gt;&lt;/a&gt;首先想说&lt;/h3&gt;&lt;p&gt;　　三个月前，公司有前辈向我建议，应该学习一下函数式编程。三个月来，在有空的时候会看看函数式编程相关的博客、教程和书籍，但一直没有花时间整理自己所学。四天前，仔细思考了一下自己对函数式编程思想的理解，发现其在我脑中完全处在一个混沌的状态，因此打算借这两周任务较少，完成一次对函数式编程的入门，并写下本文作为记录。&lt;br&gt;　　本文主要记录了：什么是函数式编程、为什么要进行函数式编程和如何学习和使用函数式编程三个问题。考虑到我立志做一个前端工程师，应用和举例时，我会尽可能的使用 JavaScript 语言。
    
    </summary>
    
      <category term="编程语言知识杂烩" scheme="http://jasonzou.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="函数式编程" scheme="http://jasonzou.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>用LESS升级CSS</title>
    <link href="http://jasonzou.me/2017/05/03/%E7%94%A8less%E4%BB%A3%E6%9B%BFcss/"/>
    <id>http://jasonzou.me/2017/05/03/用less代替css/</id>
    <published>2017-05-03T11:42:06.000Z</published>
    <updated>2017-05-04T03:44:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Brevity is the soul of wit. <br> <strong>William Shakespeare</strong> </p>
</blockquote>   
<p>　　学习了一下 LESS 的使用，在此简单记录用法，并总结一下自己的思考。<a id="more"></a></p>
<h3 id="为什么使用预编译工具？"><a href="#为什么使用预编译工具？" class="headerlink" title="为什么使用预编译工具？"></a>为什么使用预编译工具？</h3><p>　　我本打算将文章命名为“用 LESS 替代 CSS ”。但发现这样的说法很不合理，LESS 是一个 CSS 预编译工具，和其他的 CSS 预编译工具一样，它们的工作是基于 CSS 的。我的理解是，它们就像 ES2015 为 ES5 所提供的诸多语法糖一样，并非替代 CSS ，而是“升级” CSS 。总之使用预编译工具的目的，在我看来有两点：</p>
<ul>
<li>让 CSS 代码更 DRY 。</li>
<li>让前端们写CSS时更加得心应手。</li>
</ul>
<h3 id="为什么使用-LESS-而不是-SASS-或-Stylus"><a href="#为什么使用-LESS-而不是-SASS-或-Stylus" class="headerlink" title="为什么使用 LESS 而不是 SASS 或 Stylus ?"></a>为什么使用 LESS 而不是 SASS 或 Stylus ?</h3><p>　　先说前两个。 LESS 和 SASS 很像：LESS 是其作者受到 SASS 的启发后开发而出的。但二者之间还是略有区别，首先 SASS 的 Scope 和别的编程语言不类似，变量“查值”时不是逐级向“外层”找的，而是直接“扁平”地向上找的。换种说法，可以理解为所有的变量都是全局变量。与之相对的 LESS 则是逐级向“外层”查找变量的。这让我这种写JS的程序员看着闹心，这是从感情上讲不喜欢 SASS 的原因。此其一。第二：SASS 不能兼容 CSS 。这是让我觉得最尴尬的地方。虽然在进行改进更新之后还是兼容了。但是，这种行为让我怀疑其开发者的思路。看《JavaScript DOM 编程艺术》后，我明白了“平稳退化”的重要性。但 SASS 的行为违背了这种思想。同样是进行改进工作的 TypeScript ，作为 JavaScript 的超集，完全兼容 JavaScript 。对比之后，高下立判（也许是我对这个问题的认识还不够，理解不了其作者的意图吧）。第三：SASS 功能“过于”强大了。它甚至支持 IF 和 FOR 。。。我不明白这是要做什么。从我刚开始学前端开始，我就被前辈训诫要记住一些基本的原则，其中包括：前端开发中应尽可能的保持结构、样式和功能分离。(X)HTML 文档负责结构，CSS 负责样式，JavaScript 负责功能。条件判断真的是需要由 CSS 来做的工作吗？除非是一个真的几乎不需要写 JavaScript 的项目，那用 SASS 写一些逻辑我认为可以理解。但如果是普通的项目我实在是不认为应该把逻辑交由 CSS 来写。<br>　　看到这里，也应该明白我为什么不愿意用 Styules 了。和上述的第三点是一样的，Stylus 打着更贴近 JavaScript 的旗号，吸了不少粉。为什么 CSS 需要更贴近 JavaScript ，那我们为什么要 JavaScript ？还是说作者有更美好的愿景准备把 JavaScript 淘汰掉或者退一步讲只是准备在 某些场景完全淘汰掉 JavaScript ？我不明白，我不理解。<br>　　当然不是说 SASS 和 Styuls 不好，我只是说我不理解，我不理解所以不用，毕竟眼看着就要过了可以随心所欲不求甚解囫囵吞枣的年纪和阶段了。<br>　　话又说回来， LESS 在经历更新后也增加了对 IF 等条件判断语句的支持，让 CSS 更像一门普通的编程语言。但，我认为 LESS 的初衷更符合我对我所做之事的理解。所以我用 LESS 。题外话：于我而言，这个选择也是对于戒骄戒躁不浮夸不虚伪的努力践行。</p>
<h3 id="LESS-用法"><a href="#LESS-用法" class="headerlink" title="LESS 用法"></a>LESS 用法</h3><h4 id="安装为可执行文件"><a href="#安装为可执行文件" class="headerlink" title="安装为可执行文件"></a>安装为可执行文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install less -g（以全局安装为例）</div></pre></td></tr></table></figure>
<p>　　安装完毕后，直接在命令行使用就行了，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ lessc bootstrap.less bootstrap.css</div><div class="line">//将.less 文件编译为.css 文件</div></pre></td></tr></table></figure></p>
<p>　　options 在这里查看：<a href="http://less.bootcss.com/usage/" target="_blank" rel="external">命令行用法</a></p>
<h4 id="配合webpack使用"><a href="#配合webpack使用" class="headerlink" title="配合webpack使用"></a>配合webpack使用</h4><ul>
<li>安装 less-loader 。</li>
<li>阅读 webpack <a href="http://zhaoda.net/webpack-handbook/configuration.html" target="_blank" rel="external">文档</a>。</li>
</ul>
<h4 id="更多使用方法"><a href="#更多使用方法" class="headerlink" title="更多使用方法"></a>更多使用方法</h4><p>　　如果前两种都不能满足需求可以去查<a href="http://less.bootcss.com/usage/" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="LESS-特性"><a href="#LESS-特性" class="headerlink" title="LESS 特性"></a>LESS 特性</h3><p>　　在这里简单记录一下 LESS 的主要特性。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>　　可以用 @ 定义变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">// Variables</div><div class="line">@link-color:        #428bca; // sea blue</div><div class="line">@link-color-hover:  darken(@link-color, 10%);</div><div class="line"></div><div class="line">// 用法</div><div class="line">a,</div><div class="line">.link &#123;</div><div class="line">  color: @link-color;</div><div class="line">&#125;</div><div class="line">a:hover &#123;</div><div class="line">  color: @link-color-hover;</div><div class="line">&#125;</div><div class="line">.widget &#123;</div><div class="line">  color: #fff;</div><div class="line">  background: @link-color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 1.4.0 之后还支持：</div><div class="line">// Variables</div><div class="line">@mySelector: banner;</div><div class="line"></div><div class="line">// Usage</div><div class="line">.@&#123;mySelector&#125; &#123;</div><div class="line">  font-weight: bold;</div><div class="line">  line-height: 40px;</div><div class="line">  margin: 0 auto;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Variables</div><div class="line">@images: &quot;../img&quot;;</div><div class="line"></div><div class="line">// 用法</div><div class="line">body &#123;</div><div class="line">  color: #444;</div><div class="line">  background: url(&quot;@&#123;images&#125;/white-sand.png&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Variables</div><div class="line">@themes: &quot;../../src/themes&quot;;</div><div class="line"></div><div class="line">// Usage</div><div class="line">@import &quot;@&#123;themes&#125;/tidal-wave.less&quot;;</div><div class="line"></div><div class="line">// 1.6.0 之后支持：</div><div class="line">@property: color;</div><div class="line"></div><div class="line">.widget &#123;</div><div class="line">  @&#123;property&#125;: #0ee;</div><div class="line">  background-@&#123;property&#125;: #999;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　LESS 中，变量是懒加载的，所以先后定义变量不影响编译时查值。此外：LESS 作用域和 JavaScript 基本相同。</p>
<h4 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h4><p>　　CSS 类中可以嵌套 CSS 类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">// input</div><div class="line">.a, #b &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line">.mixin-class &#123;</div><div class="line">  .a();</div><div class="line">&#125;</div><div class="line">.mixin-id &#123;</div><div class="line">  #b();</div><div class="line">&#125;</div><div class="line">//output</div><div class="line">.a, #b &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line">.mixin-class &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line">.mixin-id &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 注意对比： </div><div class="line">// input</div><div class="line">.my-mixin &#123;</div><div class="line">  color: black;</div><div class="line">&#125;</div><div class="line">.my-other-mixin() &#123;</div><div class="line">  background: white;</div><div class="line">&#125;</div><div class="line">.class &#123;</div><div class="line">  .my-mixin;</div><div class="line">  .my-other-mixin;</div><div class="line">&#125;</div><div class="line">// output</div><div class="line">.my-mixin &#123;</div><div class="line">  color: black;</div><div class="line">&#125;</div><div class="line">.class &#123;</div><div class="line">  color: black;</div><div class="line">  background: white;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 可以带参数使用：</div><div class="line">// input</div><div class="line">.border-radius(@radius) &#123;</div><div class="line">  -webkit-border-radius: @radius;</div><div class="line">     -moz-border-radius: @radius;</div><div class="line">          border-radius: @radius;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#header &#123;</div><div class="line">  .border-radius(4px);</div><div class="line">&#125;</div><div class="line">.button &#123;</div><div class="line">  .border-radius(6px);</div><div class="line">&#125;</div><div class="line"></div><div class="line">.border-radius(@radius: 5px) &#123;</div><div class="line">  -webkit-border-radius: @radius;</div><div class="line">     -moz-border-radius: @radius;</div><div class="line">          border-radius: @radius;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 你甚至可以：</div><div class="line">.mixin() &#123;</div><div class="line">  @width:  100%;</div><div class="line">  @height: 200px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.caller &#123;</div><div class="line">  .mixin();</div><div class="line">  width:  @width;</div><div class="line">  height: @height;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　这是一个非常方便的功能，但是输出的 CSS <a href="http://www.cnblogs.com/kidsitcn/p/4916767.html" target="_blank" rel="external">不够DRY</a>。我们需要 Extend 。</p>
<h4 id="Extend"><a href="#Extend" class="headerlink" title="Extend"></a>Extend</h4><p>　　Extend 和 Mixin 类似，但输出不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//仔细和上面的例子对比：</div><div class="line">// input</div><div class="line">nav ul &#123;</div><div class="line">  &amp;:extend(.inline);</div><div class="line">  background: blue;</div><div class="line">&#125;</div><div class="line">.inline &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line">// output</div><div class="line">nav ul &#123;</div><div class="line">  background: blue;</div><div class="line">&#125;</div><div class="line">.inline,</div><div class="line">nav ul &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><p>　　所谓的高级用法，就是条件判断，循环等语法。我是不那么支持过多使用这些语法的，复杂的项目中过多的使用这些东西会让 UI 部分的代码很难维护。如果要学习的话，移步<a href="http://less.bootcss.com/features/" target="_blank" rel="external">官方文档</a>吧。</p>
<p style="text-align: center;"><b>… End …</b></p>

<p>　　
　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Brevity is the soul of wit. &lt;br&gt; &lt;strong&gt;William Shakespeare&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;   
&lt;p&gt;　　学习了一下 LESS 的使用，在此简单记录用法，并总结一下自己的思考。
    
    </summary>
    
      <category term="工具使用技巧" scheme="http://jasonzou.me/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="webpack" scheme="http://jasonzou.me/tags/webpack/"/>
    
      <category term="前端工程化" scheme="http://jasonzou.me/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="css" scheme="http://jasonzou.me/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>风行水上，自然成纹</title>
    <link href="http://jasonzou.me/2017/04/24/%E9%A3%8E%E8%A1%8C%E6%B0%B4%E4%B8%8A%EF%BC%8C%E8%87%AA%E7%84%B6%E6%88%90%E7%BA%B9/"/>
    <id>http://jasonzou.me/2017/04/24/风行水上，自然成纹/</id>
    <published>2017-04-24T13:46:39.000Z</published>
    <updated>2017-05-03T16:39:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>风行水上，自然成纹。 <br> <strong>朱光潜</strong> </p>
</blockquote>
<p>　　美是什么？<br>　　美是擦身而过后仍然如挂在眼角上的水珠般水灵的姑娘；美是入耳后让人驻足顾盼心生向往的笛鸣；美是求婚时含在嘴里的玫瑰和玫瑰一样兴奋脸红的准新娘；美是苦苦等待后终于从地平线下渗出的朝阳；美也是晚霞映衬下一支微<a id="more"></a>微颤烁的发簪；美可以是“烟笼寒水月笼沙”；美也可以是“大漠孤烟直，长河落日圆。”；有人说美是斑驳如老人皱纹般的古树之经络；也有人说美是如古树般沧桑的老人的皱纹。<br>　　美是难以用例子穷尽的。不论是文字，乐曲，图画这种人为之物还是某一个人，某一棵树，某一座山，某一颗星球这种自然之物，都可能蕴藏着所谓的美。<br>　　“美”这个字本身是人类语言匮乏的证明，但难以表达传播本身也是美的一大特征。<br>　　如此抽象之物就不多去给它下些苍白乏味的定义了。<br>　　朱光潜先生说：美的本质不是孤立的。<br>　　试图去定义它，必须要考虑所处时期的各种背景。此等繁杂且专业之事并非我想说的。<br>　　如何创造美更让我好奇。<br>　　美不是自然，如果说自然的就是美的，那么“创造美”也就无从谈起了。自然不是美，但自然却可被称为美的土壤。人的意愿是种子，人的抽象是培植。<br>　　创造美应是一种邂逅。<br>　　心境和所处之处能交织共鸣时，美就播下了种子。而之后是匠人的雕刻，诗人的吟诵，钢琴家的哆啦咪发，书法家的纵情挥毫，让美绽放并刻录进每一份作品之中。<br>　　并不是说只有作家才有能力创造美，有时美也可以是印在瞳孔上的影子，可以是环绕耳畔的鸟鸣。只是说，作家更擅长记录和传播美。<br>　　我想学会如何创造和传播美。<br>　　这便是我的读后感。<br>　　“创造美”突然间就成了我非常想做的事。<br>　　这源于我对自己和身边人的愧疚。<br>　　我实在不是什么美的东西，但我能看见我身边的人包括我自己对于各种“美”的期待。而和我的相处难免会误了不少本属于她们的与美相遇的机会，那我理应用上自己的浑身解数去记录下并分享一些美的东西给她们和我自己。<br>　　这算是一种严肃而要紧的救赎。<br>　　再回到“如何创造美”上。<br>　　朱光潜先生在书中给出了他的见解。<br>　　我总结大致为：美是不可强求的。灵感所至之时，用恰当的匠人技法，将其发挥和记录即可。<br>　　技法是重要的，不论是书法，写作，创作乐曲，作画还是别的所有创造，都需要一定的技法支持。这一点只能多做学习，勤加磨练了。<br>　　而我认为最值得我记住的是：美不可强求。<br>　　“乘兴而来，兴尽而返”<br>　　如前文所说的，美是邂逅。随灵感而来，你若不握紧并雕琢之，她很快就会随时间的流沙而返。<br>　　因此，好美之人理应把握和珍惜灵感。<br>　　与此同时，光是匠人之工巧，是不足以创造美的，没有灵感的卖弄，只会让人尴尬作呕，避退不及。<br>　　因此，好美之人理应适时放手。决不可为作文而作文。<br>　　所谓：风行水上，自然成纹。<br>　　我希望我至少在这片小小的夹缝中，我所有的文字都能是行云和流水，都是风划过我心中时，自然留下的波纹。</p>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;风行水上，自然成纹。 &lt;br&gt; &lt;strong&gt;朱光潜&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　美是什么？&lt;br&gt;　　美是擦身而过后仍然如挂在眼角上的水珠般水灵的姑娘；美是入耳后让人驻足顾盼心生向往的笛鸣；美是求婚时含在嘴里的玫瑰和玫瑰一样兴奋脸红的准新娘；美是苦苦等待后终于从地平线下渗出的朝阳；美也是晚霞映衬下一支微
    
    </summary>
    
      <category term="感" scheme="http://jasonzou.me/categories/%E6%84%9F/"/>
    
    
      <category term="灵感" scheme="http://jasonzou.me/tags/%E7%81%B5%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于如何抽时间做自己不想做的事</title>
    <link href="http://jasonzou.me/2017/04/23/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%8A%BD%E6%97%B6%E9%97%B4%E5%81%9A%E8%87%AA%E5%B7%B1%E4%B8%8D%E6%83%B3%E5%81%9A%E7%9A%84%E4%BA%8B/"/>
    <id>http://jasonzou.me/2017/04/23/关于如何抽时间做自己不想做的事/</id>
    <published>2017-04-23T07:04:36.000Z</published>
    <updated>2017-04-23T08:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　写这篇文章是基于我现在十分困扰的现状。现状指：最近的一周中，我尝试在下班之后抽时间复习学校里的功课准备补考，发现并没有办法找到时间和状态。没有办法找到时间和状态的原因主要有：我计划要自己做饭填饱自己占用了下班到九点过的时间，人比较困乏，没有足够的动力。<br>　　简单思考一下后，我认为：时间的问题还是可以解决的，以后回家路上买好吃的面包就行了。人比较困乏，这个只能尽量早上床了。没有足够的动力这才是核心的问题所在。<br><a id="more"></a><br>　　事实上，没有足够的动力，也意味着只要稍微有点困乏我就不会去看书学习。这是我从小到大都一直头疼的问题：如何抽时间做自己不想做的事？<br>　　倘若是我主观上想去做的事，那没有条件我会想办法去创造条件，或者条件不好我也能忍受。但面对不想做的事，这实在是难以骗自己去好好做。我有时候甚至会问自己，我到底值不值得为了个毕业证逼自己去学这些没用的课程。毕业证是不是真的有那么重要的以至于我要花费我我宝贵的下班时间和宝贵的玩游戏的时间去学习课本知识以获取。<br>　　可是人这一辈子，总是会遇到必须要做自己不想做的事的情况。因而我有理由而且有必要思考一下，遇到这种情况时，该怎么办。<br>　　我在我的计划列表的开头引用了：欲取其中必求其上…但是，在这次的实习中，我发现了一个让我很无奈的规律，以最近的一个任务为例：组长说，给你一个任务，下周二前做完，于是我给自己定了个目标——周二前尽量做完，而后我在周二完成了七成，之后一直修补，直到第二周周四才完全做完。这哪里是欲取其中必求其上啊？这分明是欲取其中必求上上，而后可得其下啊。真心而言：我并不为这件事感到沮丧。倒不如说，我找到了一个做不愿做的事时的一个时间轴。先给自己找个距离deadline比较远的时间点为目标开始工作，到了deadline求别人宽限点时间大概就能做完那件事了。<br>　　所以我在想，倘若再让我订一次学习目标，那么我要要求自己以八十分为基准，提前一个月全部复习完，那我可能最后考试可以及格。<br>　　区别还是有的：我认为自己对公司给的活是尽心尽力的，公司的活在主观上根本不算是不想做的事。<br>　　拿公司的经历做比是因为公司的活要比重修难不少，算上我自己的怠惰之后，其实两者的难度是差不多的。<br>　　因此不妨，以后就这么去订目标，指不定，我真的可以在有生之年拿到这个我还没想清楚拿来做什么的毕业证。暂且试一试吧。<br>　　还是没办法想到一个合适的解决方案。只靠我自己的话，暂时还没有办法让自己坚持做自己不想做的事。<br>　　太难了。</p>
<p style="text-align: center;"><b>… 待续 …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　写这篇文章是基于我现在十分困扰的现状。现状指：最近的一周中，我尝试在下班之后抽时间复习学校里的功课准备补考，发现并没有办法找到时间和状态。没有办法找到时间和状态的原因主要有：我计划要自己做饭填饱自己占用了下班到九点过的时间，人比较困乏，没有足够的动力。&lt;br&gt;　　简单思考一下后，我认为：时间的问题还是可以解决的，以后回家路上买好吃的面包就行了。人比较困乏，这个只能尽量早上床了。没有足够的动力这才是核心的问题所在。&lt;br&gt;
    
    </summary>
    
      <category term="最无用的东西" scheme="http://jasonzou.me/categories/%E6%9C%80%E6%97%A0%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>【转载】JavaScript中的上下文，我的认识的三个阶段</title>
    <link href="http://jasonzou.me/2017/04/21/%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%8C%E6%88%91%E7%9A%84%E8%AE%A4%E8%AF%86%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
    <id>http://jasonzou.me/2017/04/21/中的上下文，我的认识的三个阶段/</id>
    <published>2017-04-21T01:54:38.000Z</published>
    <updated>2017-05-26T07:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p>　　本文转自<a href="https://www.zouyesheng.com/" target="_blank" rel="external">邹业盛的博客</a>：<a href="https://www.zouyesheng.com/js-context.html" target="_blank" rel="external">Javascript 中的上下文，我的认识的三个阶段</a>。<br><a id="more"></a></p>
<p>　　js 中的 上下文 Context，可以说是一个，你即使不知道，没听过，也不影响你继续写 js 代码的一个概念。但是，它又确确实实是无所不在的一个东西，是的，无所不在。<br>从我自己的经验来看，对上下文的认识，算是分成了三个阶段，每一个阶段，都让我从外在的表现中，理解了一些更本质上的东西。</p>
<h3 id="第一阶段，不知"><a href="#第一阶段，不知" class="headerlink" title="第一阶段，不知"></a>第一阶段，不知</h3><p>　　我最开始接触 js 的时候，看到了它的 new ，看到了它的 this ，很自然地会把 js 和其它的一些 OOP 语言等同起来看待，并且，好像，也是这么回事。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Class = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ins = <span class="keyword">new</span> Class(<span class="number">1</span>);</div><div class="line">ins.add();</div><div class="line"><span class="built_in">console</span>.log(ins.a); <span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>　　上面的代码，可以按预期的那样，最后得到 2 的输出。<br>　　但是，如果仅仅是 类，实例 这种层面的认识，我无法解释下面的问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ins = <span class="keyword">new</span> Class(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> func = ins.add;</div><div class="line">func();</div><div class="line"><span class="built_in">console</span>.log(ins.a); <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>　　甚至解释不清楚下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj.add();</div><div class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>　　这里可没有<strong>类</strong>，也没有<strong>实例</strong>。<br>　　我上面的最开始对 js 的认识当中，局限就在于，把 this 理解成了 实例 。也许在其它语言中（比如 Python 常用的实例方法第一个参数 self），是这样。但是在 js 中， this 跟 实例 完全没有关系。</p>
<h3 id="第二阶段，this"><a href="#第二阶段，this" class="headerlink" title="第二阶段，this"></a>第二阶段，this</h3><p>　　当我明白问题出在 this 上，或者说，当我终于理解了 this 这个东西之后，上面的代码，再也不会困扰我了。<br>　　我知道了， js 中有一个东西叫 上下文 ，可惜的是，这时，我对上下文的概念，仅仅停留在 this 上。<br>　　这时我的理解是： this 表示的是，函数调用时的 上下文 。<br>　　说得详细一点，就是 this 不是表示的 实例 ，而是函数调用时的 上下文 。 上下文 这个东西，默认是 window ，即 全局 。但是，你可以明确地为函数指定一个 上下文 。回到 this 上，就是在定义时你根本不知道 this 是什么，因为在调用时，它可以是任何东西（因为 上下文 是可以人为指定的）。</p>
<p>　　回到刚开始的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Class = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ins = <span class="keyword">new</span> Class(<span class="number">1</span>);</div><div class="line">ins.add();</div><div class="line"><span class="built_in">console</span>.log(ins.a); <span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>　　这段代码的结构之所以是 2 ，不是因为 实例 ，而是因为 上下文 。<br>　　首先说一下 new 。 new 在 js 中，不考虑原型链，它的作用相当于是先创建了一个空的对象，然后把这个空的对象，作为 构造函数 的 上下文 ，再去执行 构造函数 ，最后再返回这个当初的空对象。即：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> what_new = <span class="function"><span class="keyword">function</span>(<span class="params">func, a</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> context = &#123;&#125;;</div><div class="line">  func.apply(context, [a]);</div><div class="line">  <span class="keyword">return</span> context;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Class = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ins = what_new(Class, <span class="number">1</span>);</div><div class="line">ins.add();</div><div class="line"><span class="built_in">console</span>.log(ins.a);</div></pre></td></tr></table></figure></p>
<p>　　当然， new 除了上面的 func.apply 的作用之外， 它还会处理原型链 ，这里就不介绍了。上面的代码仅是为了说明 new 对于所谓的构造函数做了什么事。<br>　　有了上下文，就不难解释 ins 这个东西了。所谓的构造函数，只是在指定了 this 到底是哪一个对象之后，作了相应的赋值操作而已，最后得到这个对象的返回，经过了一些赋值操作，对象中就有了新的东西了。<br>　　同样，对于一个在定义时包含了 this 的函数，比如前面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　如果来一句：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = obj.add;</div><div class="line">func(); <span class="comment">//undefined</span></div><div class="line">func.apply(&#123;<span class="attr">a</span>: <span class="number">0</span>&#125;) <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>　　这些都很容易明白了。 js 中的函数，都是一些很单纯的函数，所有的函数跟它在哪里定义完全没有关系（考虑闭包的情况除外）。所以上面的代码，虽然 add 函数是写在 obj 中的，但是，它跟你在 window 中写一个函数是 完全一样 的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.a++&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">add</span>: add</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　既然 add 函数中有 this ，那么这个函数执行时的行为，就要小心一点了。所以上面明确地指定了一个上下文给它 func.apply({a: 0}) 。<br>　　还是回到开始的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　对于上面的代码，我知道了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.add();</div></pre></td></tr></table></figure></p>
<p>　　和：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = obj.add();</div><div class="line">func();</div></pre></td></tr></table></figure></p>
<p>　　会得到不一样的结果。并且知道，这个不一样的结果是上下文引起的，还知道，后者 func() 执行时，上下文是全局的 window 了。<br>　　我虽然知道是这样的一个情况，但是，为什么？执行同一个函数结果怎么就不一样了呢？<br>　　我在很长时间里，都没有去细细考虑过这个问题。不过，因为知道了“上下文是一个在定义时无意义，其具体值完全由执行时决定”这点之后，我都尽量避免去使用 this ，实在要用，在调用时，我都会通过 apply 或 call 明确指定上下文，这样，至少不会踩坑里。</p>
<h3 id="第三阶段，一切都是上下文"><a href="#第三阶段，一切都是上下文" class="headerlink" title="第三阶段，一切都是上下文"></a>第三阶段，一切都是上下文</h3><p>　　某天，我在网上看到了这样一段代码（原始出处不知道）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bind = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Function</span>.prototype.bind)</div></pre></td></tr></table></figure></p>
<p>　　这个新定义的 bind 函数具体做什么事先不管它，我好奇的是 call.bind() 这个调用。因为 call 这个函数，之前一直以为它是 Function 对象的一个方法（它本身也是一个函数），但是，如果按“对象的方法”这个角度去想的话，那对它绑定一个上下文（ bind() 的调用 ）不就完全没有意义了么？（因为对象的方法应该是跟上下文无关的）<br>　　后来看到了这篇文章，<a href="http://www.html-js.com/article/JavaScript-functional-programming-in-Javascript-Bind-Call-and-Apply" target="_blank" rel="external">http://www.html-js.com/article/JavaScript-functional-programming-in-Javascript-Bind-Call-and-Apply</a><br>　　其中以 slice 函数举的例子让我恍然大悟：</p>
<ul>
<li>上下文控制不仅仅是 apply / call，所有的点 . ，都是在指定上下文。</li>
<li>js 中的函数比我想像的还要纯，根本没有“对象中的方法”这个东西，即使是“原生对象”中。（它仅仅起一个名字空间的作用）</li>
</ul>
<p>　　所有的函数调用，都有两层意义，比如 c.f()：</p>
<ul>
<li>f 这个函数，它在 c 中。（名字空间的问题）</li>
<li>把 c 作为 f 的上下文，去调用 f 。（前提是 f 没有绑定过上下文）如果 c 没有，则默认是 window 。</li>
</ul>
<p>　　所有的，js 中所有的函数调用，都是如此。即使是 f.call(context, x) ，我之前只看到了第一层意义（ f 中有一个 call 方法可以使用），则忽略了第二层意义 —— 把 f 作为 call 的上下文。<br>　　简单来说，我们可以相像 call 这个函数，它的代码大概是这样的（可变参数的问题先不管）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> call = <span class="function"><span class="keyword">function</span>(<span class="params">context, a</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> new_func = <span class="keyword">this</span>.bind(context);</div><div class="line">    retur new_func(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　它的作用，就是把 指定的上下文（context） 作为 自己的上下文（this） 的 上下文 ，然后再调用 自己的上下文（绑定上下文之后的 this） 。<br>　　上面一句话有些纠结哈，主要搞明白多种上下文的关系， f.call(context, x) 当中， 自己的上下文 上面是 f 。 指定的上下文 上面是 context 。<br>　　再看 f.call(context, x) 这个代码，结合“函数是单纯”这点，我想到，即使是原生对象的那些方法， 也不过是把一些单纯的函数放到了 prototype 中而已 ，比如把 call 函数放到了 Function.prototype 当中。<br>　　至此，再看 c.f() ， a.b.c() 这些，不要去想是调用 c 对象中的 f 方法（这么说没错，但是名字空间的问题是显而易见的嘛），而是想成，调用时把 c 作为 f 的上下文。<br>　　好了，回到开始的那行例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> new_bind = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Function</span>.prototype.bind)</div></pre></td></tr></table></figure></p>
<p>　　这个就非常好理解了（为了描述方便，我改成 new_bind 了），把 bind 作为上下文绑定到 call 中。<br>　　这里注意一下，绑定了上下文的 call 函数，还是 call 函数，但是 “此 call 已经非彼 call” 了。<br>　　所以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new_bind != <span class="built_in">Function</span>.prototype.call</div></pre></td></tr></table></figure></p>
<p>　　虽然调用形式上， new_bind 和 call 完全一样，但是他们的上下文行为不一样：</p>
<ul>
<li>call 是未绑定状态，所以 f.call() 会在执行时把 f 作为上下文绑定到 call 函数中。</li>
<li>new_bind 是已绑定状态，所以 f.new_bind() 对 new_bind() 的执行完全没影响。</li>
</ul>
<p>我们可以以这样的流程来帮助我们理解：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new_bind =&gt; <span class="function"><span class="params">call</span> =&gt;</span> bind.call =&gt; bind.call(f, context) =&gt; f.bind(context)</div></pre></td></tr></table></figure></p>
<p>一步一步解释：<br>　　new_bind =&gt; call：</p>
<pre><code>　　new_bind 在形式上就是 call 。
</code></pre><p>　　call =&gt; bind.call：</p>
<pre><code>　　只是这个 call ，是指定了 bind 作为它的上下文的。既然是 bind 作为它的上下文，那我们可以写成是 bind.call 的样式。
</code></pre><p>　　bind.call(f, context) =&gt; f.bind(context)：</p>
<pre><code>　　new_bind 的调用 new_bind(f, context) 就相当于是 bind.call(f, context) 。考虑 call 函数之前的行为： f.call(context, a) 是把 context 作为 f 的上下文，也就是 context.f(a) ，那么 bind.call(f, context) 对应的就是 f.bind(context) 。
</code></pre><p>　　f.bind(context)：</p>
<pre><code>　　不用多说了吧，把 context 绑定到 f 上，返回一个绑定了上下文的新函数。
</code></pre><p>　　完全是最基本的代数推导嘛，形式上，上下文前置总是没有问题的。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>　　我一直认同，要理解 js 的东西，从函数式语言入手，非常合适。硬要往面向对象的那套东西上套，太纠结了（我不管概念上到底什么样才叫面向对象，原生没有类定义，没有继承，没有实例化，就别扯这些就完了。对了，我认为原型追溯那不叫继承哈）。<br>　　当然，我不知道弄明白了最后那个“代数推导”到底有什么好处，也许没有，因为就算不明白这些也不影响我写了很多可以正常工作的 js 代码嘛。只是，我以后再写，思路上的可能会有一些不同了。比如代码组织的形式上，可以尝试把很多的小函数做到不同的“名字空间”中，然后再在业务层面，通过 Mixin 来拼出不同的业务对象。这些函数中可能到处充斥着 this ，我能控制好它们了。</p>
<p style="text-align: center;"><b>… End …</b></p>



]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原文链接&quot;&gt;&lt;a href=&quot;#原文链接&quot; class=&quot;headerlink&quot; title=&quot;原文链接&quot;&gt;&lt;/a&gt;原文链接&lt;/h3&gt;&lt;p&gt;　　本文转自&lt;a href=&quot;https://www.zouyesheng.com/&quot;&gt;邹业盛的博客&lt;/a&gt;：&lt;a href=&quot;https://www.zouyesheng.com/js-context.html&quot;&gt;Javascript 中的上下文，我的认识的三个阶段&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="前端和 JavaScript 知识总结" scheme="http://jasonzou.me/categories/%E5%89%8D%E7%AB%AF%E5%92%8C-JavaScript-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://jasonzou.me/tags/JavaScript/"/>
    
      <category term="this" scheme="http://jasonzou.me/tags/this/"/>
    
      <category term="上下文" scheme="http://jasonzou.me/tags/%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
      <category term="context" scheme="http://jasonzou.me/tags/context/"/>
    
  </entry>
  
  <entry>
    <title>记我第一次下厨</title>
    <link href="http://jasonzou.me/2017/04/18/%E8%AE%B0%E6%88%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8B%E5%8E%A8/"/>
    <id>http://jasonzou.me/2017/04/18/记我第一次下厨/</id>
    <published>2017-04-18T13:47:20.000Z</published>
    <updated>2017-04-21T11:56:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>王者以民为天,而民以食为天。 <br> <strong>《汉书·郦食其传》</strong> </p>
</blockquote>
<p>　　不过是一碗面罢了。<a id="more"></a><br>　　不过是一碗面罢了，怎好意思称之为下厨呢？但这的确是我第一次在厨房中捣鼓出能入口的食物。<br>　　客观而言，我煮的面很和我的口味。它没有猪油，我的母亲和外婆的面永远是有猪油的。它很细，奶奶煮的面总是选宽面。它软又不至于腻做一团，哥哥的面总是很硬。<br>　　下班后立马就往住处赶，我怕楼下负一层的菜市等不到我平时到家的那一刻。匆匆忙忙地，匆忙得像所有匆忙回家做饭的其他人。下地铁打电话问哥哥买多少钱的小葱和小白菜合适，偏偏问了还是把1块钱的小葱买做了2块钱的。<br>　　七点过就到家了。算是很早的。洗菜切葱拍蒜，又打电话给母亲询问调料该怎么配：醋、鸡精、酱油、花椒面、藤椒油、辣椒油和再半勺辣椒油，我是一个土生土长的峨眉乐山人。水开下面，再开下菜，再开试尝。软硬合适就关火装碗。<br>　　客观而言，味道真的是不错的。<br>　　但仍然不过是一碗面罢了。<br>　　面是现成的，辣椒油是现成的，配料都是现成的。煮面时出神，竟想到：用编程做比，这就是个什么接口都准备好了的体力活。我曾浅略地思考过，学习开发网页对我有什么改变，一条一条总结的话，读上去就像十一月树上的最后一片枯叶一样干煸乏味。有幸地是，给别人讲自己下厨煮面时的胡思乱想并不那么无趣。面是怎么做的，煮多久合适，最少煮多久，最多煮多久，养胃的面是说的所有的面吗？假如是，那煮多久都养胃吗？辣椒油又是怎么做的，多少合适。别的调料加多少合适？为什么不适合加花椒，要用花椒面呢？藤椒油和花椒面都是麻的为什么值得一样加一点？加多少面汤合适，不至于让味道太淡又不让面腻成一团。面汤为什么适合用来洗碗？菜对面的帮助有哪些？怎么装碗能让面看上去好看些。<br>　　无非是一大堆成熟的封装程度很高的公共库（各种调料）和一个自造的轮子（辣椒油）在开水和面汤的环境中对面条（主要的参数）进行简单的软化加热（类似于解析或是转换格式）和调味（改变一些旧的属性赋予一些新的属性），并最终输出食物：面条吗？<br>　　为什么原料和调料众多，但是想深入研究的只有面和辣椒油呢？因为辣椒油是自造的轮子，不是现成的，是自己迟早也要造的轮子。而面条和别的调料不同，在这个处理中，面条是最重要的主要参数，值得理解它的一些深层次的属性乃至原理。<br>　　大多数人十二岁前就会煮面喂饱自己了，而我自己第一次煮面竟然是二十一岁。<br>　　十二岁的我，大概会想，煮个面而已，想这么多不会累吗？而二十一岁的我竟然已经把这种并没有什么意思的联想当成了一种娱乐。<br>　　独自生活的话免不了要自己做饭的。我离开父亲母亲，从四川一路到了北京，其实早料到了会有个这样的第一次。<br>　　北京是一个让我抑郁的地方。午间小憩，不经意间回想起自己儿时的种种。<br>　　小时候的我被管束得很严，父亲是一个小学老师，我在过去的文字里应该也提过了。总之，那时候的我向往鸟，觉得自己是笼子里的小动物。后来真的就自由了，谁也管不了我，我不信宗教，不信马克思主义，不为传统文化骄傲，更不会热爱任何的党，任何的国家。我真的很自由，不论是身，还是心。<br>　　可是，真正成了鸟，又发现自己原来更想当条狗。城里的人想长出翅膀飞出墙外，到了墙外却不知道要飞到哪里，才明白，自由竟是迷茫脆弱恐惧和孤独的代名词。此时，才想回到城里，回到笼子里。没有约束自己的那层皮，气球就不是气球，只是一团随时会消散泯灭于世间的空气。飞在天上的鸟，他想去哪里就去那里，然而不管到了哪里，都和前一处一样，四周空荡荡的，只有从东西南北吹来的风、如来掌心般的云层和东升西落的太阳。而自己曾经奋力摆脱的那片大地，隔远一看，才是多姿多彩的。城外的天，只有在城里人的眼中才是美妙的。<br>　　反而怀念起了小学的日子。
　　</p>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;王者以民为天,而民以食为天。 &lt;br&gt; &lt;strong&gt;《汉书·郦食其传》&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　不过是一碗面罢了。
    
    </summary>
    
      <category term="胡诌" scheme="http://jasonzou.me/categories/%E8%83%A1%E8%AF%8C/"/>
    
    
      <category term="学做菜" scheme="http://jasonzou.me/tags/%E5%AD%A6%E5%81%9A%E8%8F%9C/"/>
    
  </entry>
  
  <entry>
    <title>减肥对精神健康的作用</title>
    <link href="http://jasonzou.me/2017/04/10/%E5%87%8F%E8%82%A5%E7%9A%84%E7%90%86%E7%94%B1/"/>
    <id>http://jasonzou.me/2017/04/10/减肥的理由/</id>
    <published>2017-04-09T17:16:47.000Z</published>
    <updated>2017-04-09T18:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>一鼓作气，再而衰，三而竭<br> <b>左丘明</b> </p>
</blockquote>
<p>　　这是我给女朋友写的小论文。纯属发泄情绪，胡诌乱道一通。</p>
<h3 id="减肥是一种理性行为"><a href="#减肥是一种理性行为" class="headerlink" title="减肥是一种理性行为"></a>减肥是一种理性行为</h3><p>　　减肥是一种理性的行为。尽可能的增重是人与生俱来的本能，在食物并不充足的时代，人会尽可能多的摄入食物。食物充足的时候，摄入的食物除了提供人日常劳作的能量，部分还会转化为脂肪，存储在人体中。而在人难以补充充足的能量时（例如生病后，不能很好的吸收食物），之前存储下的脂肪会成为宝贵的资源。因此，在过去的时代里，因为食物并不总是充足的，所以食欲旺盛的人更有活下去的可能性。旺盛的食欲在一番物竞天择后，留在了如今很多人的基因中。<br>　　当今绝大部分中国人并不缺少食物，尤其是青少年。因此，胃口太好在现代社会中，还会对人起到消极作用。缺乏节制地，不合理地饮食往往会让人肥胖。<br><a id="more"></a><br>　　当进食的本能成为健康的敌人，部分人选择减肥。减肥是不盲目遵从本能的理性行为。人类的各种理性行为是其与普通动物的区别所在。<br>　　过去谈到减肥，人们会更多地注意到它对人体健康的益处。我认为，减肥的意义不只在于促进人的身体健康，它更能促进一个人的精神健康。</p>
<h3 id="减肥能助人产生积极的意志"><a href="#减肥能助人产生积极的意志" class="headerlink" title="减肥能助人产生积极的意志"></a>减肥能助人产生积极的意志</h3><p>　　减肥能够磨炼人的意志。这里的意志，指的是一种对自我的控制力。<br>　　前文提到了：减肥这一行为，必然伴随着对本能的压制。这是一种自我控制的体现。具体而言，健康的减肥主要有合理饮食和适当运动组成。肥胖的人一般有着睡前四小时内进食，食物营养过盛或营养不均衡等行为现象。将不良的饮食习惯纠正，需要人对自己本能中的食欲进行控制。古人云：食色性也。作为人类的两大天性之一，控制食欲的难度是不低的。我们可以观察到，越是年幼的儿童乃至幼儿，越缺乏对食欲的控制能力。因此我们可以认为，对进食的控制，是成熟的人才具有的能力之一。而连控制进食都做不到的人，其自控力是不完善的。<br>　　减肥的人普遍还会自发的进行体育锻炼。趋利避害是人的一种重要的能力，而利益从时间划分可分为眼前的利益和长远的利益。举例而言，在床上睡一天，在短期内是让人愉悦的。但，从长期来看，荒废时间是不利于长远利益的。进行体育锻炼的人亦是如此。拒绝锻炼可以获得短期的利益，而进行锻炼将获得长远的利益。如果长远的利益大于短期的利益，理想情况下的人是会放弃短期利益而选择长期利益的。对此，美国科学家曾对一群小朋友做过一个简单的实验，能坚持30分钟不吃掉眼前的一颗糖的小孩，将获得三颗糖的奖励。成功坚持到三十分钟不吃糖的小朋友在长大后成就普遍远大于不能坚持三十分钟的小朋友。尽管进行减肥行为的不只是儿童，但同样的道理是适用的。能坚持锻炼的人往往更有实现自己的目标，成就自己的理想。<br>　　不论是对于本能的控制力，还是对于短期利益的抵抗力，这都属于积极的意志力。<br>　　减肥能够锻炼一个人对于长期利益和短期利益的取舍能力。人在达成一些事之后，产生满足感。从生物学的角度讲，满足感来源于大脑分泌的多巴胺。举例而言：吸毒之后，人的大脑中就会大量的堆积多巴胺，因此人会感到精神愉悦。同样能产生愉悦感的还有：每天都进行运动，坚持一年，并形成一副健康的躯体。前者和后者的差别不必多说。举这个极端的例子是为了说明一点：偷懒也是会产生依赖性的，万不可认为松懈一天没有关系，会轻易松懈某一天的人的结局往往是之后的每天都在偷懒松懈。这和吸毒上瘾的机制是有些类似的，吸毒者成瘾是因为毒品效力消失后，人体会产生不适感，毒品用量越大，不适感越强。屈服于自己的惰性也是同样的，偷懒时愉悦，事后后悔痛苦，为了从消极情绪中解脱，于是选择更多的懈怠以获取愉悦感。一但懈怠了，人就会越来越难以坚持原本的目标。<br>　　因此坚持减肥不仅是在打磨自己的身体，同样也是在打磨自己心灵。</p>
<h3 id="成功的减肥是一种强大的“精神资源”"><a href="#成功的减肥是一种强大的“精神资源”" class="headerlink" title="成功的减肥是一种强大的“精神资源”"></a>成功的减肥是一种强大的“精神资源”</h3><p>　　成功的减肥经历是一种“精神资源”。所谓“精神资源”，有可以称之为一个人自信的源泉。一个减肥成功的人，往往具有充足的自信。能成功减肥的人能对自己做出两个清晰的判断：一是，自己可以控制自己的天性。二是，自己能够不受短期的利益的诱惑。这样的人在面临挑战的时候必然是泰然自若的。<br>　　从反面而言，一个减肥失败的人，在做别的事时很可能会怀疑自己。比如，作为一个学生，如果他不能成功的减肥，那么他也会怀疑自己能否坚持每天背单词。一个研究人员，如果不能成功减肥，他必定会怀疑自己能否耐得住多次实验失败时的寂寞和苦闷。一位政府官员，倘若他连坚持减肥都做不到，那么他很可能会怀疑自己是否可以抵抗住金钱和美女的诱惑。<br>　　“精神资源”是一个人极为重要的财富，一个内心中空无一物，认为自己什么都没有做成过的人，哪怕他头脑聪明，背景显赫，他在处理问题的时候都会带着一份难以摒去的优柔寡断。这样的人是不具备优秀领导力的，因为他不能领导自己，所以更难以去领导一群人。<br>　　一个人如果没有克服困难达成某个目的的经历，那么这个人的内心往往是不足够强大的。而减肥这件事，正好可以提供给人这个经历，并进一步给予人以一颗强大的心脏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;一鼓作气，再而衰，三而竭&lt;br&gt; &lt;b&gt;左丘明&lt;/b&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　这是我给女朋友写的小论文。纯属发泄情绪，胡诌乱道一通。&lt;/p&gt;
&lt;h3 id=&quot;减肥是一种理性行为&quot;&gt;&lt;a href=&quot;#减肥是一种理性行为&quot; class=&quot;headerlink&quot; title=&quot;减肥是一种理性行为&quot;&gt;&lt;/a&gt;减肥是一种理性行为&lt;/h3&gt;&lt;p&gt;　　减肥是一种理性的行为。尽可能的增重是人与生俱来的本能，在食物并不充足的时代，人会尽可能多的摄入食物。食物充足的时候，摄入的食物除了提供人日常劳作的能量，部分还会转化为脂肪，存储在人体中。而在人难以补充充足的能量时（例如生病后，不能很好的吸收食物），之前存储下的脂肪会成为宝贵的资源。因此，在过去的时代里，因为食物并不总是充足的，所以食欲旺盛的人更有活下去的可能性。旺盛的食欲在一番物竞天择后，留在了如今很多人的基因中。&lt;br&gt;　　当今绝大部分中国人并不缺少食物，尤其是青少年。因此，胃口太好在现代社会中，还会对人起到消极作用。缺乏节制地，不合理地饮食往往会让人肥胖。&lt;br&gt;
    
    </summary>
    
      <category term="胡诌" scheme="http://jasonzou.me/categories/%E8%83%A1%E8%AF%8C/"/>
    
    
      <category term="养生" scheme="http://jasonzou.me/tags/%E5%85%BB%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】我是怎么变牛逼的</title>
    <link href="http://jasonzou.me/2017/04/01/How-I-Became-a-Better-Programmer/"/>
    <id>http://jasonzou.me/2017/04/01/How-I-Became-a-Better-Programmer/</id>
    <published>2017-04-01T07:07:15.000Z</published>
    <updated>2017-04-04T08:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原文出处："><a href="#原文出处：" class="headerlink" title="原文出处："></a>原文出处：</h3><p><a href="http://jlongster.com/How-I-Became-Better-Programmer" target="_blank" rel="external">http://jlongster.com/How-I-Became-Better-Programmer</a>.</p>
<h3 id="译者的话"><a href="#译者的话" class="headerlink" title="译者的话"></a>译者的话</h3><p>　　我一直认为：“知道”和“懂得”之间是存在着巨大的差距的。从别人那里得到的指导和教训，永远和别人真正想教授的东西往往相差不少。广义上举例讲，作者的原话和我的翻译之间也会存在差异（这是当然也和本人的水平实在有限有关，毕竟，这篇翻译也只是自行记录为主，传播分享为辅）。<br><a id="more"></a></p>
<h3 id="如何成为更好的程序员"><a href="#如何成为更好的程序员" class="headerlink" title="如何成为更好的程序员"></a>如何成为更好的程序员</h3><p>有人在 React Conf 上向问我如何成为更好的程序员。由于某些原因，人们觉得我是个值得向其求取意见的牛逼程序员。（既然听众们诚心诚意的发问了）我觉得，写下我这些年来编程成长之路的技巧法门是有意义的。</p>
<p>关于我的一些小故事：<br>我32岁，之前有过超过十年的硬编经验。长久以来，我对自己所做的事并不那么自信。甚至直到今天，我也是在怀疑自己的。重要的事，既然（客观上）这种感觉挥之不去，那不如（在主观上去）忽略它，只管继续完善自己，不断积累经验。</p>
<p>且让我声明一下：这些只是提升你编程技能的一些小提示。最后你得亲自弄明白，哪些是对你最有益的。这些只是我认为有用的东西。</p>
<h4 id="寻找给你灵感的人，但不要盲目崇拜他们"><a href="#寻找给你灵感的人，但不要盲目崇拜他们" class="headerlink" title="寻找给你灵感的人，但不要盲目崇拜他们"></a>寻找给你灵感的人，但不要盲目崇拜他们</h4><p>这些年里，我关注了很多我尊敬的人，从他们那里学习新技术。我只是相信他们的方向是对的，并探索他们的正在研究的领域，并从中学到了很多。这些人往往才智过人，充满灵性并且成果颇多。找到这些人，让人他们启发你，指导你。</p>
<p>但是，一定不要过分崇拜他们。Twitter上的信息让他们看上去牛逼的可怕，不过，如果你看看他们在平日里是怎么工作的，你会发现他们并不是那么与众不同。同样是修补的各种错误之类的。我们都是在实验中摸索向前的。最后，不要盲目相信他们；如果你不赞同某些东西，就怼他们，然后从质疑中学习。我的一些成果就是在这样的交流中产生的。</p>
<p>我的 EMACS 设置一团糟。我不知道为啥我的 OCaml 自动补出问题了（它坏了一个多月了）。我没有做任务自动化，因此，有时候得在我的shell输入历史里慢慢找某些我需要用到的命令。我一开始的时候写的代码其丑无比。我把很多东西绑定在全局对象中，直到有一天我意识到我都干了些什么。最牛逼的程序员会使用各种技巧。但最重要的（不是这些牛逼的技巧，而是）你能把问题给解决了。</p>
<h4 id="切莫妄之菲薄"><a href="#切莫妄之菲薄" class="headerlink" title="切莫妄之菲薄"></a>切莫妄之菲薄</h4><p>新人程序员总倾向于认为他们干的事意义不大，因为它们不成熟。或者，你是个老司机，但是刚刚涉及一个让你不舒服的新领域。我认为，一些最棒的点子来自于那些观点尚未成型的新人程序员，因为他们能看到思维模式成型的老鸟们看不到的，某些成熟技术中的可提高之处。</p>
<p>不管是啥，你干的事都是有意义的。再不济，如果你的点子行不通，那么社区中的众人也能学到这种方法行不通。（给社区的提示：有没有用和欢不欢迎新人是由我们决定的）</p>
<h4 id="不要一直在焦虑中工作"><a href="#不要一直在焦虑中工作" class="headerlink" title="不要一直在焦虑中工作"></a>不要一直在焦虑中工作</h4><p>技术每天都在推陈出新，这会让你觉得，你摸一晚上的鱼，你就会被整个世界落下。这是不对的。事实上，你会干的更好，如果你从过度紧张中解脱出来。你的观点会被刷新，并且，我发现，不工作的时候，有些新点子会下意识的涌现出来。</p>
<p>每天都出现的那些的所谓的新技术，大体上都是把旧知识换了个包装而已。真正的革命性的技术革新，每几年才会发生一次。关于这个，可以去看看 Hammock Driven Development。</p>
<h4 id="少花心思在浅层次的知识上"><a href="#少花心思在浅层次的知识上" class="headerlink" title="少花心思在浅层次的知识上"></a>少花心思在浅层次的知识上</h4><p>少花心思在不重要的事上是提升自己的技术的不二法门。换言之，也就是理智的使用你的时间。你每天的时间是有限的，如果你把这些时间花在一些深层次的东西上你会感觉很不一样。</p>
<p>所以，什么是所谓的皮毛知识呢？这是因人而异的，但我可以给你举我自己的例子，我认为的皮毛知识有：语言的语法，API库，编程软件设置等。相较于学习编译器是怎么运行的，学习ES7的某个新语法对你的提升是很有限的。学习一个库的实现原理比死记硬背库的API有意思得多。当然，这些“皮毛知识”也是很重要的，但我还是推荐你花更多的时间在学习深层次的东西上，这会在之后的很多年里都给你回报。</p>
<p>这里我要提个问题：你是否花了很多的时间在怎样让你的代码看上去好看上？如果是这样的，我建议你别花太多时间在上面。你的代码是会有很大改变的，随着时间的推移。你不如花更多注意力在如何解决核心问题和思考一下你的抽象层级上。待你确定你已经解决好了这些之后，你可以花点儿时间打磨一下你的代码。（这样你的代码也是很DRY的，别对这种问题担心过度，对充满重复性的工作放松一些。）</p>
<h4 id="回顾前辈的研究"><a href="#回顾前辈的研究" class="headerlink" title="回顾前辈的研究"></a>回顾前辈的研究</h4><p>如果你对某个新点子激动不已，那你肯定很想坐下来就开始怼它。但你应该先粗略的研究一下前人是如何解决这个问题，然后才开始你的行动。花几天的时间研究一下前辈们的工作，总会让我彻底改变我对这个问题的原始解决方案。</p>
<p>学习如何读学术文章是有价值的。我对“指示”、“操作”等专业术语的东西一无所知，所以我有很多文章看不懂。但（文章中）同样有很多的使用代码而不是数学符号（的内容）并不是那么难懂。过去三十年间的文献中，蕴含着海量的知识。如果你善于做这些事情的话，你将是一个思想上的领袖。</p>
<p>Prettier就是个典型的例子。我知道我想要什么效果，但是我不知道怎么去事实它。在经过了一些调研后，我找到了一篇文章，然后过了几天，我就明白了我到底需要做些什么。我在每个工作日还得做一些基础工作。如果我忽略掉了提前调研的话，我就得话很多的时间去解决这个问题。</p>
<p>如果你在找文献的话，你可以 star 一下 the Papers We Love 这个github库。</p>
<h4 id="搞些大项目，挑战一下自己"><a href="#搞些大项目，挑战一下自己" class="headerlink" title="搞些大项目，挑战一下自己"></a>搞些大项目，挑战一下自己</h4><p>没有什么是比实战经验更宝贵的了。并不是每个人都有能做大项目的条件。但，如果你有时间的话，尝试着去做些大项目吧。你并非一定要完成这些项目。只要你尝试去解决一些事儿，就比如尝试去写个编译器，这会在你干这个事的最初的几周里教给你成吨的知识。</p>
<p>说实话，我很讨厌不知道怎么解决一个复杂问题的时候。这很不爽。我知道我得花很多功夫，做很多研究，学习很多，在我只是单纯的接近解决方案之前。但我总会在挑战了这些困难之后变成一个更牛逼的程序员。</p>
<p>开始学习一门新语言。这是最好的让你从旧语言的使用习惯中解脱出来，开发新思路的办法。对我而言，我作为一个年轻的程序员做过的最好的是事是学习 Scheme。这是一门很简单的语言，它会迫使你用函数式编程思想做所有事情，并且让你真正学习到代码运行的基本原理。我花在 Scheme 上的几年功夫，直到今天也一直对我有很大的帮助；我看代码的方式从根本上改变了。（我甚至给我的公司取名叫 Shift Reset LLC ，这是向 Scheme 中的 shift/reset 操作符致敬。）</p>
<p>这里，我列一些我推荐去做的事。这些事都对我的程序员生涯产生了巨大的影响。其中的大部分工作，至今都在以微妙的方式产生着回报，并且会从思想上帮我煮结构一些新点子。你无须完全照做，有别的事也能帮助你成为更好的程序员，这些只是帮助我成长的事。</p>
<ul>
<li>学习C语言：学习基础的东西，如果你还没学过C语言的话。我认为，弄清楚为什么每个人都抱怨它是很值得的事。</li>
<li>写个编译器：这也许是最好的挑战自己的方式了，查一查一个<a href="https://github.com/thejameskyle/the-super-tiny-compiler" target="_blank" rel="external">超级小型的编译器</a>是怎么实现的。</li>
<li>学习 macros ：看看 Scheme，Lisp 或是 Clojure 。Macros 会非常显著的改变你看代码的方式。</li>
<li>看SICP：<a href="https://mitpress.mit.edu/sicp/full-text/book/book.html" target="_blank" rel="external">SICP</a> 是一本我认为今天依然有意义的老书（有些人不赞同）。它只讲了比较少的编程知识，并且会一直引导你到实现元循环评估器和编译器。另一本让我受益匪浅并让在编译器学习之路精进不少的书是 <a href="https://www.amazon.com/Lisp-Small-Pieces-Christian-Queinnec/dp/0521545668" target="_blank" rel="external">Lisp In Small Pieces</a> 。</li>
<li>理解 continuations ：<a href="https://en.wikipedia.org/wiki/Continuation" target="_blank" rel="external">Continuations</a> 是一种低等级的控制流机制。Scheme 是唯一一们继承了这些机制的语言，尽管你永远不会在你的生产中使用这门语言，但这些只是会改变你对控制流的思考。我写了篇<a href="http://jlongster.com/Whats-in-a-Continuation" target="_blank" rel="external">博客</a>解释这个。</li>
<li>如果说还有什么建议的话，那就是尝试一门新语言了：不管你是做什么的，你都很应该去探索一下别的语言。我的推荐依次是：Clojure，Rust，Elm，OCaml/Reason，Go，或者 Scheme。这其中的每一门语言都有它独特的地方，会迫使你学习一种新的思考问题的方式。</li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>



]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原文出处：&quot;&gt;&lt;a href=&quot;#原文出处：&quot; class=&quot;headerlink&quot; title=&quot;原文出处：&quot;&gt;&lt;/a&gt;原文出处：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://jlongster.com/How-I-Became-Better-Programmer&quot;&gt;http://jlongster.com/How-I-Became-Better-Programmer&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;译者的话&quot;&gt;&lt;a href=&quot;#译者的话&quot; class=&quot;headerlink&quot; title=&quot;译者的话&quot;&gt;&lt;/a&gt;译者的话&lt;/h3&gt;&lt;p&gt;　　我一直认为：“知道”和“懂得”之间是存在着巨大的差距的。从别人那里得到的指导和教训，永远和别人真正想教授的东西往往相差不少。广义上举例讲，作者的原话和我的翻译之间也会存在差异（这是当然也和本人的水平实在有限有关，毕竟，这篇翻译也只是自行记录为主，传播分享为辅）。&lt;br&gt;
    
    </summary>
    
      <category term="最无用的东西" scheme="http://jasonzou.me/categories/%E6%9C%80%E6%97%A0%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>map、filter和reduce</title>
    <link href="http://jasonzou.me/2017/03/31/map%E3%80%81filter%E5%92%8Creduce/"/>
    <id>http://jasonzou.me/2017/03/31/map、filter和reduce/</id>
    <published>2017-03-31T08:48:10.000Z</published>
    <updated>2017-04-04T08:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　map( ) 、 filter( ) 和 reduce( ) 是一系列很符合函数式编程思想的数组操作方法。我认为学习他们很重要，本文没有什么自己的见解，仅仅是作为学习<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">MDN</a>资料的摘录。<br><a id="more"></a></p>
<h3 id="map"><a href="#map" class="headerlink" title="map( )"></a>map( )</h3><p>　　map( ) 是根据旧数组<strong>产生新数组</strong>的方法，并不修改原数组。 </p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line"><span class="keyword">let</span> roots = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// roots is now [2, 10, 20, 30]</span></div><div class="line"><span class="comment">// numbers is still [1, 5, 10, 15]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>];</div><div class="line"><span class="comment">//es6: let roots = numbers.map(Math.sqrt);</span></div><div class="line"><span class="keyword">let</span> roots = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(x);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// roots is now [1, 2, 3]</span></div><div class="line"><span class="comment">// numbers is still [1, 4, 9]</span></div></pre></td></tr></table></figure>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> new_array = arr.map(callback[, thisArg])</div></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>callback<br>生成新数组元素的函数，使用三个参数：<ul>
<li>currentValue<br>callback 的第一个参数，数组中正在处理的当前元素。</li>
<li>index<br>callback 的第二个参数，数组中正在处理的当前元素的索引。</li>
<li>array<br>callback 的第三个参数，map 方法被调用的数组。</li>
</ul>
</li>
<li>thisArg<br>可选的。执行 callback 函数时 使用的this 值。</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>  一个新数组，每个元素都是回调函数的结果。</p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>　　map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。<br>　　callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。<br>　　如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象 。<br>　　map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。<br>　　使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter( )"></a>filter( )</h3><p>　　filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> value &gt;= <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].filter(isBigEnough);</div><div class="line"><span class="comment">// filtered is [12, 130, 44]</span></div></pre></td></tr></table></figure>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> new_array = arr.filter(callback[, thisArg])</div></pre></td></tr></table></figure>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul>
<li>callback<br>用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。<br>返回true表示保留该元素（通过测试），false则不保留。</li>
<li>thisArg<br>可选。执行 callback 时的用于 this 的值。</li>
</ul>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>　　一个新的通过测试的元素的集合的数组</p>
<h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>　　filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。<br>　　callback 被调用时传入三个参数：</p>
<ul>
<li>元素的值</li>
<li>元素的索引</li>
<li>被遍历的数组</li>
</ul>
<p>　　如果为 filter 提供一个 thisArg 参数，则它会被作为 callback 被调用时的 this 值。否则，callback 的 this 值在非严格模式下将是全局对象，严格模式下为 undefined。<br>　　The thisvalue ultimately observable by callback is determined according to the usual rules for determining thethis seen by a function.<br>　　filter 不会改变原数组。<br>　　filter 遍历的元素范围在第一次调用 callback 之前就已经确定了。在调用 filter 之后被添加到数组中的元素不会被 filter 遍历到。如果已经存在的元素被改变了，则他们传入 callback 的值是 filter 遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce( )"></a>reduce( )</h3><p>　　reduce() 方法对累加器和数组的每个值 (从左到右)应用一个函数，以将其减少为单个值。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sum = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">acc, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> acc + val;</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sum);</div><div class="line"><span class="comment">// 6</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> list1 = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]];</div><div class="line"></div><div class="line"><span class="keyword">let</span> list2 = [<span class="number">0</span>, [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>]]]]]]];</div><div class="line"></div><div class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> arr.reduce(</div><div class="line">        <span class="function">(<span class="params">acc, val</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> acc.concat(<span class="built_in">Array</span>.isArray(val) ? flatten(val) : val)</div><div class="line">        &#125;, []</div><div class="line">    );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">flatten(list1); </div><div class="line"><span class="comment">// [0, 1, 2, 3, 4, 5]</span></div><div class="line"></div><div class="line">flatten(list2); </div><div class="line"><span class="comment">// [ 0, 1, 2, 3, 4, 5, 6 ]</span></div></pre></td></tr></table></figure>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.reduce(callback,[initialValue])</div></pre></td></tr></table></figure>
<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul>
<li>callback<br>执行数组中每个值的函数，包含四个参数<ul>
<li>accumulator<br>上一次调用回调返回的值，或者是提供的初始值（initialValue）</li>
<li>currentValue<br>数组中正在处理的元素</li>
<li>currentIndex<br>数据中正在处理的元素索引，如果提供了 initialValue ，从0开始；否则从1开始</li>
<li>array<br>调用 reduce 的数组</li>
</ul>
</li>
<li>initialValue<br>可选项，其值用于第一次调用 callback 的第一个参数。</li>
</ul>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>　　函数累计处理的结果</p>
<h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>　　reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值 accumulator （或者上一次回调函数的返回值），当前元素值 currentValue ，当前索引 currentIndex ，调用 reduce 的数组。<br>　　回调函数第一次执行时，accumulator 和 currentValue 的取值有两种情况：调用 reduce 时提供initialValue，accumulator 取值为 initialValue ，currentValue 取数组中的第一个值；没有提供 initialValue ，accumulator 取数组中的第一个值，currentValue 取数组中的第二个值。<br>　　注意: 不提供 initialValue ，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。提供 initialValue ，从索引0开始。<br>　　如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。<br>　　提供 initialValue 通常更安全，正如下面的例子，没有 initialValue 有三种可能输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> maxCallback = <span class="function">(<span class="params"> pre, cur </span>) =&gt;</span> <span class="built_in">Math</span>.max( pre.x, cur.x );</div><div class="line"><span class="keyword">var</span> maxCallback2 = <span class="function">(<span class="params"> max, cur </span>) =&gt;</span> <span class="built_in">Math</span>.max( max, cur );</div><div class="line"></div><div class="line"><span class="comment">// reduce() without initialValue</span></div><div class="line">[ &#123; <span class="attr">x</span>: <span class="number">22</span> &#125;, &#123; <span class="attr">x</span>: <span class="number">42</span> &#125; ].reduce( maxCallback ); <span class="comment">// 42</span></div><div class="line">[ &#123; <span class="attr">x</span>: <span class="number">22</span> &#125;            ].reduce( maxCallback ); <span class="comment">// &#123; x: 22 &#125;</span></div><div class="line">[                      ].reduce( maxCallback ); <span class="comment">// TypeError</span></div><div class="line"></div><div class="line"><span class="comment">// map/reduce; better solution, also works for empty arrays</span></div><div class="line">[ &#123; <span class="attr">x</span>: <span class="number">22</span> &#125;, &#123; <span class="attr">x</span>: <span class="number">42</span> &#125; ].map( <span class="function"><span class="params">el</span> =&gt;</span> el.x )</div><div class="line">                        .reduce( maxCallback2, -<span class="literal">Infinity</span> );</div></pre></td></tr></table></figure></p>
<p style="text-align: center;"><b>… End …</b></p>





]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　map( ) 、 filter( ) 和 reduce( ) 是一系列很符合函数式编程思想的数组操作方法。我认为学习他们很重要，本文没有什么自己的见解，仅仅是作为学习&lt;a href=&quot;https://developer.mozilla.org/zh-CN/&quot;&gt;MDN&lt;/a&gt;资料的摘录。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript知识总结" scheme="http://jasonzou.me/categories/JavaScript%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://jasonzou.me/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://jasonzou.me/tags/ES6/"/>
    
      <category term="函数式编程" scheme="http://jasonzou.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>localhost到底是什么</title>
    <link href="http://jasonzou.me/2017/03/31/localhost%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://jasonzou.me/2017/03/31/localhost到底是什么/</id>
    <published>2017-03-31T06:01:13.000Z</published>
    <updated>2017-04-04T08:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>起因：<br>　　最近在为在维护一个项目。在以本机为服务器做移动端测试时，出现了页面资源载入失败的情况：playback-mobile.js（如下）文件并没有被成功加载。这个错误仅出现在了魅族系列手机上的native浏览器和QQ移动浏览器（也许还有别的非主流浏览器也不支持）中。和前辈交流后认为：有可能是这个src中的localhost应该替换为服务器地址。修改后发现，问题的确是出在这里的。<br>　　无独有偶，在 MacOS Safari 上进行开发测试时，发现了一个更为怪异的现象：当我使用 localhost 作为域名时，我访问某个配置了全域可访问头的资源（并且只有这个资源出现了问题）时，居然提示跨域错误。查看后发现，请求完全没有发出，是浏览器直接就把请求block了。把 localhost 换成本机IP后又一切正常了。<br>　　事后探究了一下原因，并在此做一个总结：<br><a id="more"></a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 原来的引入路径</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://localhost:9094/playback-mobile.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">// 修改后的引入路径</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://192.168.2.196:9094/playback-mobile.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="localhost、127-0-0-1-和-本机IP-三者的区别"><a href="#localhost、127-0-0-1-和-本机IP-三者的区别" class="headerlink" title="localhost、127.0.0.1 和 本机IP 三者的区别"></a>localhost、127.0.0.1 和 本机IP 三者的区别</h3><p>参考：<a href="https://www.zhihu.com/question/23940717/answer/26230963" target="_blank" rel="external">知乎</a></p>
<h4 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h4><p>　　localhost 是一个域名，在过去它指向 127.0.0.1 这个IP地址。在操作系统支持 ipv6 后，它同时还指向ipv6 的地址 [::1]。在 Windows 中，这个域名是预定义的，从 hosts 文件中可以看出：</p>
<pre><code>　　#localhost name resolution is handled within DNS itself.#    
　　127.0.0.1       localhost#    
　　::1             localhost
</code></pre><p>　　而在 Linux 中，其定义位于 /etc/hosts 中：</p>
<pre><code>　　127.0.0.1    localhost
</code></pre><p>　　注意这个值是可修改的，比如我把它改成 </p>
<pre><code>　　192.068.206.1    localhost
</code></pre><p>　　然后再去 ping localhost，提示就变成了PING localhost (192.168.206.1) 56(84) bytes of data.当然一般人不会像我这么蛋疼。</p>
<h4 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h4><p>　　127.0.0.1 这个地址通常分配给 loopback 接口。loopback 是一个特殊的网络接口(可理解成虚拟网卡)，用于本机中各个应用之间的网络交互。只要操作系统的网络组件是正常的，loopback 就能工作。Windows 中看不到这个接口，Linux中这个接口叫： </p>
<pre><code>　　lo：#ifconfigeth0    Link encap:Ethernet hwaddr 00:00:00:00:00:00            
　　inet addr :192.168.0.1 Bcase:192.168.0.255 Mask:255.255.255.0           
　　......lo        
　　Link encap:Local Loopback           
　　inetaddr: 127.0.0.1 Mask: 255.0.0.0           
　　......
</code></pre><p>　　可以看出 lo 接口的地址是 127.0.0.1。事实上整个 127.* 网段都算能够使用，比如你 ping 127.0.0.2 也是通的。但是使用127.0.0.1作为loopback接口的默认地址只是一个惯例，比如下面这样：</p>
<pre><code>　　#ifconfig lo 192.168.128.1#ping localhost   #
</code></pre><p>　　糟糕，ping不通了，试试ping 192.128.128.1：</p>
<pre><code>　　#ping 192.128.128.1  # 
</code></pre><p>　　可以通：</p>
<pre><code>　　#ifconfig lolo        Link encap:Local Loopback           
　　inetaddr: 192.168.128.1 Mask: 255.255.255.0          
　　......
</code></pre><p>　　当然，一般人更不会像我这样蛋疼。如果随便改这些配置，可能导致很多只认 127.0.0.1 的软件挂掉。</p>
<h4 id="本机IP（本机地址）"><a href="#本机IP（本机地址）" class="headerlink" title="本机IP（本机地址）"></a>本机IP（本机地址）</h4><p>　　确切地说，“本机地址”并不是一个规范的名词。通常情况下，指的是“本机物理网卡所绑定的网络协议地址”。由于目前常用网络协议只剩下了IPV4，IPX/Apple Tak消失了，IPV6还没普及，所以通常仅指IP地址甚至ipv4地址。一般情况下，并不会把 127.0.0.1 当作本机地址。原因没必要特别说明，大家都知道。本机地址是与具体的网络接口绑定的。比如以太网卡、无线网卡或者PPP/PPPoE拨号网络的虚拟网卡，想要正常工作都要绑定一个地址，否则其他设备就不知道如何访问它。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　localhost 是个域名，不是地址，它可以被配置为任意的 IP 地址，不过通常情况下都指向 127.0.0.1(ipv4)和 <a href="ipv6">::1</a>整个127.<em> 网段通常被用作 loopback 网络接口的默认地址，按惯例通常设置为 127.0.0.1。这个地址在其他计算机上不能访问，就算你想访问，访问的也是自己，因为每台带有TCP/IP协议栈的设备基本上都有 localhost/127.0.0.1。本机地址通常指的是绑定在物理或虚拟网络接口上的IP地址，可供其他设备访问到。最后，从开发度来看localhost是个域名，性质跟 “www.baidu.com” 差不多。不能直接绑定套接字，必须先gethostbyname转成IP才能绑定。127.0.0.1 是绑定在 loopback 接口上的地址，如果服务端套接字绑定在它上面，你的客户端程序就只能在本机访问。如果主机中存在多个网卡，分别连接不同的物理网络，比如 192.168.0.1/255.255.255.0 和 192.168.1.1/255.255.255.0，那么当你的服务端套接字绑到 192.168.0.1 这个地址上时，位于 192.168.1.</em> 网段的其他计算机是无法连接的，只有位于192.168.0.* 网段的计算机才能访问你的服务端程序。<br>　　之前举了一个修改 loopback 接口后无法ping通localhost的例子，我认为，这和我本次遇到的第一个问题的原理相同。魅族手机的native浏览器中可能存在对 loopback 接口的修改，并最终导致了本次错误。<br>　　对于第二个错误，我并不是很能确定是否也是相同的原因，我认为，更有可能是 Safari 浏览器的某些内部设置问题。如果确认了问题所在我会再更新本次总结。</p>
<p style="text-align: center;"><b>… End …</b></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起因：&lt;br&gt;　　最近在为在维护一个项目。在以本机为服务器做移动端测试时，出现了页面资源载入失败的情况：playback-mobile.js（如下）文件并没有被成功加载。这个错误仅出现在了魅族系列手机上的native浏览器和QQ移动浏览器（也许还有别的非主流浏览器也不支持）中。和前辈交流后认为：有可能是这个src中的localhost应该替换为服务器地址。修改后发现，问题的确是出在这里的。&lt;br&gt;　　无独有偶，在 MacOS Safari 上进行开发测试时，发现了一个更为怪异的现象：当我使用 localhost 作为域名时，我访问某个配置了全域可访问头的资源（并且只有这个资源出现了问题）时，居然提示跨域错误。查看后发现，请求完全没有发出，是浏览器直接就把请求block了。把 localhost 换成本机IP后又一切正常了。&lt;br&gt;　　事后探究了一下原因，并在此做一个总结：&lt;br&gt;
    
    </summary>
    
      <category term="计算机基础知识杂烩" scheme="http://jasonzou.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="计算机网络" scheme="http://jasonzou.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【转载】MVC, MVP, MVVM的区别和联系</title>
    <link href="http://jasonzou.me/2017/03/30/MVVM%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://jasonzou.me/2017/03/30/MVVM的联系和区别/</id>
    <published>2017-03-30T14:06:36.000Z</published>
    <updated>2017-04-04T08:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下转自：</strong><a href="http://codingjoker.github.io/" target="_blank" rel="external">JumoZhu的博客</a></p>
<a id="more"></a>
<h3 id="先说一下三者的共同点"><a href="#先说一下三者的共同点" class="headerlink" title="先说一下三者的共同点"></a>先说一下三者的共同点</h3><p>Model和ViewModel就是数据模型，同时，提供外部对应用程序数据的操作的接口，也可能在数据变化时发出变更通知。Model不依赖于View的实现，只要外部程序调用Model的接口就能够实现对数据的增删改查。<br>View就是UI层，提供对最终用户的交互操作功能，包括UI展现代码及一些相关的界面逻辑代码。</p>
<p>三者的差异在于如何粘合View和Model，实现用户的交互操作以及变更通知。</p>
<h3 id="MVC和MVP的关系"><a href="#MVC和MVP的关系" class="headerlink" title="MVC和MVP的关系"></a>MVC和MVP的关系</h3><p>MVC 进化为 MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架：<br>我们都知道MVP是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过 Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会以观察者的身份监听Model的变化，直接从Model中读取数据而不是通过 Controller。</p>
<h3 id="MVVM和MVP的关系"><a href="#MVVM和MVP的关系" class="headerlink" title="MVVM和MVP的关系"></a>MVVM和MVP的关系</h3><p>而 MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：（View的Model就是包含View的一些数据属性和操作的这么一个东东）这种模式的关键技术就是数据绑定（data binding），View的变化会直接影响ViewModel，ViewModel的变化或者内容也会直接体现在View上。这种模式实际上是框架替应用开发者做了一些工作，开发者只需要较少的代码就能实现比较复杂的交互。</p>
<h4 id="MVVM的优点"><a href="#MVVM的优点" class="headerlink" title="MVVM的优点"></a>MVVM的优点</h4><ul>
<li>低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响；</li>
<li>可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用；</li>
<li>独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModel），界面设计人员可以专注于UI(View)的设计；</li>
<li>可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单。</li>
</ul>
<h4 id="在angular中MVVM模式主要分为四部分"><a href="#在angular中MVVM模式主要分为四部分" class="headerlink" title="在angular中MVVM模式主要分为四部分"></a>在angular中MVVM模式主要分为四部分</h4><ul>
<li>View：它专注于界面的显示和渲染，在angular中则是包含一堆声明式Directive的视图模板。</li>
<li>ViewModel：它是View和Model的粘合体，负责View和Model的交互和协作，它负责给View提供显示的数据，以及提供了View中Command事件操作Model的途径；在angular中$scope对象充当了这个ViewModel的角色；</li>
<li>Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在web页面中，大部分Model都是来自Ajax的服务端返回数据或者是全局的配置对象；而angular中的service则是封装和处理这些与Model相关的业务逻辑的场所，这类的业务服务是可以被多个Controller或者其他service复用的领域服务。</li>
<li>Controller：这并不是MVVM模式的核心元素，但它负责ViewModel对象的初始化，它将组合一个或者多个service来获取业务领域Model放在ViewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态</li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;以下转自：&lt;/strong&gt;&lt;a href=&quot;http://codingjoker.github.io/&quot;&gt;JumoZhu的博客&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言知识杂烩" scheme="http://jasonzou.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="面向对象" scheme="http://jasonzou.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>【转载】《浅析nodeJS的几种文件路径》</title>
    <link href="http://jasonzou.me/2017/03/27/%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E3%80%8B/"/>
    <id>http://jasonzou.me/2017/03/27/的几种文件路径》/</id>
    <published>2017-03-27T11:10:40.000Z</published>
    <updated>2017-04-04T08:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天在使用webpack打包JS时报错，发现path不能是相对路径，发现自己对路径的理解一直都是似是而非的，在我的一位<a href="http://zerosrat.com" target="_blank" rel="external">良师益友</a>的指导帮助后学习了一下路径的相关知识。<br>　　在此转载一篇相关博客，以作记录：</p>
<p><strong>以下转自：</strong><a href="https://github.com/imsobear/blog/issues/48" target="_blank" rel="external">imsobear的博客</a></p>
<h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>　　Node 中的文件路径大概有 <strong>__dirname</strong>， <strong>__filename</strong> ， <strong>process.cwd()</strong> ， <strong>./</strong> 或者 <strong>../</strong>，前三个都是绝对路径，为了便于比较，<strong>./</strong> 和 <strong>../</strong> 我们通过 <strong>path.resolve(‘./‘)</strong> 来转换为绝对路径。</p>
<a id="more"></a>
<p>先看一个简单的例子：</p>
<p>假如我们有这样的文件结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app/</div><div class="line">  -lib/</div><div class="line">    -common.js</div><div class="line">  -model</div><div class="line">    -task.js</div><div class="line">    -test.js</div></pre></td></tr></table></figure></p>
<p>在 task.js 里编写如下的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(__dirname);</div><div class="line"><span class="built_in">console</span>.log(__filename);</div><div class="line"><span class="built_in">console</span>.log(process.cwd());</div><div class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">'./'</span>));</div></pre></td></tr></table></figure></p>
<p>在 model 目录下运行 $ node task.js 得到的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/Users/guo/Sites/learn/app/model.js</div><div class="line">/Users/guo/Sites/learn/app/model.js/task.js</div><div class="line">/Users/guo/Sites/learn/app/model.js</div><div class="line">/Users/guo/Sites/learn/app/model.js</div></pre></td></tr></table></figure></p>
<p>然后在 app 目录下运行 node model/task.js，得到的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/Users/guo/Sites/learn/app/model.js</div><div class="line">/Users/guo/Sites/learn/app/model.js/task.js</div><div class="line">/Users/guo/Sites/learn/app</div><div class="line">/Users/guo/Sites/learn/app</div></pre></td></tr></table></figure></p>
<p>那么，不好意思不是问题来了~T_T,我们可以得出一些肤浅的结论了：</p>
<ul>
<li>__dirname: 总是返回被执行的 js 所在文件夹的绝对路径</li>
<li>__filename: 总是返回被执行的 js 的绝对路径</li>
<li>process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径</li>
<li>./: 跟 process.cwd() 一样、一样、一样的吗？</li>
</ul>
<p>还是上面的结构，’model/task.js’ 里的代码改成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> common = <span class="built_in">require</span>(<span class="string">'../lib/common'</span>);</div><div class="line"></div><div class="line">fs.readFile(<span class="string">'../lib/common.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在 model 目录下运行 node task.js，一切 Ok，没有报错。然后在 app 目录下运行 node model/task.js，然后很果断滴报错了。</p>
<p>那么这下问题真的都是来了，按照上面的理论，在 app 下运行时，../lib/common.js 会被转成 /Users/guo/Sites/learn/lib/common.js，这个路径显然是不存在的，但是从运行结果可以看出 require(‘../lib/common’) 是 OK 的，只是 readFile 时报错了。</p>
<p>那么关于 ./ 正确的结论是：</p>
<p>在 require() 中使用是跟 __dirname 的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟 process.cwd() 效果相同，是相对于启动脚本所在目录的路径。</p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>只有在 require() 时才使用相对路径(./, ../) 的写法，其他地方一律使用绝对路径，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 当前目录下</div><div class="line">path.dirname(__filename) + &apos;/test.js&apos;;</div><div class="line">// 相邻目录下</div><div class="line">path.resolve(__dirname, &apos;../lib/common.js&apos;);</div></pre></td></tr></table></figure></p>
<ul>
<li><a href="http://stackoverflow.com/questions/8131344/what-is-the-difference-between-dirname-and-in-node-js" target="_blank" rel="external">参考1</a></li>
<li><a href="https://nodejs.org/api/" target="_blank" rel="external">参考2</a></li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　今天在使用webpack打包JS时报错，发现path不能是相对路径，发现自己对路径的理解一直都是似是而非的，在我的一位&lt;a href=&quot;http://zerosrat.com&quot;&gt;良师益友&lt;/a&gt;的指导帮助后学习了一下路径的相关知识。&lt;br&gt;　　在此转载一篇相关博客，以作记录：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下转自：&lt;/strong&gt;&lt;a href=&quot;https://github.com/imsobear/blog/issues/48&quot;&gt;imsobear的博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h2&gt;&lt;p&gt;　　Node 中的文件路径大概有 &lt;strong&gt;__dirname&lt;/strong&gt;， &lt;strong&gt;__filename&lt;/strong&gt; ， &lt;strong&gt;process.cwd()&lt;/strong&gt; ， &lt;strong&gt;./&lt;/strong&gt; 或者 &lt;strong&gt;../&lt;/strong&gt;，前三个都是绝对路径，为了便于比较，&lt;strong&gt;./&lt;/strong&gt; 和 &lt;strong&gt;../&lt;/strong&gt; 我们通过 &lt;strong&gt;path.resolve(‘./‘)&lt;/strong&gt; 来转换为绝对路径。&lt;/p&gt;
    
    </summary>
    
      <category term="nodeJS知识总结" scheme="http://jasonzou.me/categories/nodeJS%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://jasonzou.me/tags/JavaScript/"/>
    
      <category term="nodeJS" scheme="http://jasonzou.me/tags/nodeJS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript如何“面向对象”</title>
    <link href="http://jasonzou.me/2017/03/25/JavaScript%E5%A6%82%E4%BD%95%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://jasonzou.me/2017/03/25/JavaScript如何面向对象/</id>
    <published>2017-03-25T04:19:36.000Z</published>
    <updated>2017-05-26T07:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>不同的矛盾，只有用不同的方法才能解决。 <br> <strong>毛泽东</strong> </p>
</blockquote>
<p>　　JavaScript并不是一门严格的面向对象语言，因为JavaScript没有类。ES6给习惯了使用类的程序员们一个类的语法糖，但相较于别的面向对象语言，ES6的这个类也是很不成熟的类（将在本文后续讲详细说明）。虽然没有一个严格定义的类，但这并不影响面向对象的设计思想在JavaScript编程中发光发热。<br><a id="more"></a></p>
<h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><blockquote>
<p>百度百科：<br>　　面向对象是指一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的集合。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。狭义的“面向对象”是指在程序设计中采用封装、继承、多态等设计方法。</p>
</blockquote>
<p>　　面向对象的编程方法具有四个基本特性：</p>
<ul>
<li><p>抽象<br>我是一个前端，从日常实战中的角度出发，我认为“抽象”主要是针对两方面： </p>
<ul>
<li><p>抽象数据模型<br>如这篇博客，我要从数据层面去抽象出它的模型。得出的结果应该是类似于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="attr">title</span>: <span class="string">'JavaScript和面向对象'</span>,</div><div class="line">	<span class="attr">date</span>: <span class="string">'2017-03-25 12:19:36'</span>,</div><div class="line">	<span class="attr">categories</span>: <span class="string">'JavaScript知识总结'</span>,</div><div class="line">	<span class="attr">tags</span>: &#123;</div><div class="line">		<span class="attr">tag1</span>: <span class="string">'JavaScript'</span>,</div><div class="line">		<span class="attr">tag2</span>: <span class="string">'面向对象'</span></div><div class="line">	&#125;，</div><div class="line">	<span class="comment">//... 等等</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>抽象具体操作<br>如果将这篇博客抽象为一个对象，那么它对外并没有太多接口，只有一个提供给UI层的“读”接口。那么，“读”这个操作，就可以作为博客对象的方法被抽象出来。形如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">blog</span> </span>&#123;</div><div class="line">	<span class="comment">//提示：以下代码需经babel翻译后才能在常规生产环境中运行。</span></div><div class="line">	_data;</div><div class="line">	readData() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>._data;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>继承<br>“继承”思想是面向对象编程的重要一环，前端开发中并不缺少能用到继承的场景，如页面中常出现的列表对象：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">类</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">特征</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">父类</td>
<td style="text-align:left">普通列表</td>
<td style="text-align:left">列表</td>
</tr>
<tr>
<td style="text-align:left">子类</td>
<td style="text-align:left">可增删列表</td>
<td style="text-align:left">列表 + “增”、“删”方法</td>
</tr>
<tr>
<td style="text-align:left">“孙”类</td>
<td style="text-align:left">可增删重排序列表</td>
<td style="text-align:left">列表 + “增”、“删”方法 + 重排序方法</td>
</tr>
</tbody>
</table>
<p>　　如是就是前端开发中一个很普通的继承运用了。JavaScript没有严格定义的类，<br>　　因此JavaScript的继承相较于别的语言稍显特殊。详情将在本文后续介绍。</p>
<ul>
<li><p>封装<br>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。封装这一行为是面向对象编程的安全性保障。值得一提的是：JavaScript并没有私有变量。在ES6编程中通常约定：以下划线开头的变量（如 _data ）为私有变量。本文对封装不做详细介绍说明。</p>
</li>
<li><p>多态</p>
<blockquote>
<p>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。  </p>
</blockquote>
<p>实现多态，常见的方式无非是覆盖或重载。<br>JavaScript中，后创建的同名函数会覆盖先创建的同名函数。因此，直接在子类中重写需要实现多态的方法，覆盖从父类继承来的方法即可实现多态。<br>JavaScript的重载是颇为有趣的。JavaScript并不是理想的用于重载的语言，因为JavaScript函数对参数长度是没有限制的，因此，常规语言的重载思路并不对JavaScript适用。但，我们可以通过在函数内部判断参数类型和参数length来模拟重载。我认为，这样的灵活性是JavaScript这门语言的魅力所在。</p>
</li>
</ul>
<h3 id="为什么要面向对象"><a href="#为什么要面向对象" class="headerlink" title="为什么要面向对象"></a>为什么要面向对象</h3><p>为什么要面向对象？这是一个值得每一个前端工程师考虑的问题。JavaScript这门语言（尤其是ES6之后）也是适合使用函数式编程的。在此给出一些链接供读者参考：</p>
<ul>
<li><a href="http://taobaofed.org/blog/2017/03/16/javascript-functional-programing/" target="_blank" rel="external">我眼中的 JavaScript 函数式编程</a></li>
<li><a href="https://www.zhihu.com/question/20275578" target="_blank" rel="external">面向对象编程的弊端是什么？</a></li>
<li><a href="http://www.vaikan.com/whats-wrong-with-oop-and-fp/" target="_blank" rel="external">为什么说面向对象编程和函数式编程都有问题</a></li>
</ul>
<h3 id="ES5中的面向对象"><a href="#ES5中的面向对象" class="headerlink" title="ES5中的面向对象"></a>ES5中的面向对象</h3><p>JavaScript如何“面向对象”？这是一个非常基础的问题，我认为这是每一个前端工程师都应该花心思花时间去掌握的东西。</p>
<ul>
<li><p>首先，你要有个对象（创建对象的几种常用方法）： </p>
<ul>
<li><p>原始模式： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">'Jason'</span>,</div><div class="line">	<span class="attr">age</span>: <span class="number">21</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> Person = &#123;&#125;;</div><div class="line">Person.name = <span class="string">'Jason'</span>；</div><div class="line">Person.age = <span class="number">21</span></div></pre></td></tr></table></figure>
</li>
<li><p>原始模式的改进： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用一个函数来构造对象，解决代码重复的问题</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">name</span>: name,</div><div class="line">		<span class="attr">age</span>: age</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> personJ = Person(<span class="string">'Jason'</span>, <span class="number">21</span>);</div><div class="line"><span class="keyword">var</span> personX = Person(<span class="string">'Xku'</span>, <span class="number">18</span>);</div><div class="line"><span class="comment">// 这个模式存在的问题是，personJ和personX两个实例没有内在的联系，并不能看出他们是出于同一个原型的</span></div></pre></td></tr></table></figure>
</li>
<li><p>构造函数模式： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在函数内部使用this是构造函数的关键</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用new实例化对象</span></div><div class="line"><span class="keyword">var</span> personJ = <span class="keyword">new</span> Person(<span class="string">'Jason'</span>, <span class="number">21</span>);</div><div class="line"><span class="keyword">var</span> personX = <span class="keyword">new</span> Perspm(<span class="string">'Xku'</span>, <span class="number">18</span>);</div><div class="line"><span class="comment">// 此时personJ和personX会自动生成一个constructor属性，指向他们的构造函数</span></div><div class="line">personJ.constructor == Person <span class="comment">// true</span></div><div class="line">personX <span class="keyword">instanceof</span> Person <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
<li><p>Prototype模式： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数中可能会存在一些不变的属性</span></div><div class="line"><span class="comment">// 没有必要在每一次实例化对象的时候都将其加入新建对象之中</span></div><div class="line"><span class="comment">// 此时，我们可以采用Prototype + 构造函数模式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">Person.prototype.type = <span class="string">"哺乳动物"</span>；</div><div class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>构造函数的继承：<br>前文中已经讲到过了，JavaScript中，面向对象主要体现在对对象的封装和继承上，JavaScript常规上讲没有重载，多态的实现主要依赖覆盖，我学艺不精，在这方面暂时没有找到什么好讲的。因此，本文将重点介绍如何在使用JavaScript语言进行编程时实现封装和继承。前面已经介绍了封装。现在开始介绍继承：<br>场景：这里有个Animal类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和一个Person类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在要使Person类继承Animal类</p>
<ul>
<li><p>构造函数绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  使用call或apply方法，将父对象的构造函数绑定在子函数上</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> personJ = <span class="keyword">new</span> Person(<span class="string">'Jason'</span>, <span class="number">21</span>);</div><div class="line">conslo.log(personJ.species); <span class="comment">// 动物</span></div></pre></td></tr></table></figure>
</li>
<li><p>prototype模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将Person的prototype替换为Animal的prototype，</span></div><div class="line">Person.prototype = <span class="keyword">new</span> Animal();</div><div class="line"><span class="comment">// 注意：Person的prototype被替换后，他的constructor也被替换成Animal的了，因此注意立刻对此做出修改</span></div><div class="line">Person.prototype.constructor = Person;</div></pre></td></tr></table></figure>
</li>
<li><p>直接继承prototype</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我们可以把Animal类用prototype模式写，如是就不需要new Animal()了</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Animal.prototype.species = <span class="string">'动物'</span>；</div><div class="line">Person.prototype = Animal.prototype;</div><div class="line">Person.prototype.constructor = Person;</div><div class="line"><span class="comment">// 此方法的缺点是，任何针对Person的prototype修改，都将影响到Animal的prototype，因为二者现在属于同一内存的不同引用</span></div></pre></td></tr></table></figure>
</li>
<li><p>利用空对象作为中介</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这样，修改就不会互相影响了</span></div><div class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">F.prototype = Animal.prototype;</div><div class="line">Person.prototype = <span class="keyword">new</span> F();</div><div class="line">Person.prototype.constructor = Person;</div><div class="line"><span class="comment">// 利用这个原理，我们可以封装出一个继承方法：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    F.prototype = Parent.prototype;</div><div class="line">    Child.prototype = <span class="keyword">new</span> F();</div><div class="line">    Child.prototype.constructor = Child;</div><div class="line">    <span class="comment">// 留下通往父函数的通道</span></div><div class="line">    Child.uber = Parent.prototype;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>拷贝继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拷贝继承原理类似于上一种继承方式</span></div><div class="line"><span class="comment">// 首先依然把不变属性都绑定在prototype上</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Animal.prototype.species = <span class="string">'动物'</span>；</div><div class="line"><span class="comment">// 拷贝函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = Parent.prototype;</div><div class="line">    <span class="keyword">var</span> c = Child.prototype;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</div><div class="line">        c[i] = p[i];</div><div class="line">    &#125;</div><div class="line">    c.uber = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>非构造函数的继承：</p>
<ul>
<li><p>object() 方法<br>先来看Douglas Crockford ( json 的发明人 ) 如何实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 道格拉斯提出了一个object函数来完成非构造函数的继承</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 上面将子对象的的prototype指向父对象了，之后还需要将子对象本身的属性加上</span></div></pre></td></tr></table></figure>
</li>
<li><p>浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 顾名思义，将父对象的属性拷贝给子对象：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">p</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c = &#123;&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</div><div class="line">    c[i] = p[i];</div><div class="line">  &#125;</div><div class="line">  c.uber = p;</div><div class="line">  retrun c;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 浅拷贝的问题很明显，子类和父类的属性只是同一个内存的不同引用，因此子类修改属性，父类也会被影响</span></div></pre></td></tr></table></figure>
</li>
<li><p>深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 递归调用浅拷贝，实现深拷贝，实现真正的拷贝既可避免浅拷贝中出现的问题</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c = c || &#123;&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> p[i] === <span class="string">'object'</span>) &#123;</div><div class="line">      c[i] = (p[i].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</div><div class="line">      deepCopy(p[i], c[i]);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      c[i] = p[i];</div><div class="line">    &#125; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"><span class="comment">// PS jQuery库正是用的这种方式实现的继承</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="ES6中的面向对象"><a href="#ES6中的面向对象" class="headerlink" title="ES6中的面向对象"></a>ES6中的面向对象</h3><p>ES6给了习惯使用类的程序员们一个class语法糖，先给出<a href="http://babeljs.io/repl/" target="_blank" rel="external">babel</a>对class的翻译：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是ES6代码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name, age) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line">  sayName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// babel翻译后的代码</span></div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</div><div class="line">				<span class="keyword">var</span> descriptor = props[i];</div><div class="line">				descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</div><div class="line">				descriptor.configurable = <span class="literal">true</span>;</div><div class="line">				<span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</div><div class="line">				<span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</div><div class="line">			<span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</div><div class="line">			<span class="keyword">return</span> Constructor</div><div class="line">		&#125;</div><div class="line">	&#125;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    _classCallCheck(<span class="keyword">this</span>, Person);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  _createClass(Person, [&#123;</div><div class="line">    <span class="attr">key</span>: <span class="string">"sayName"</span>,</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">  &#125;]);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Person;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>参考代码后，发现，ES6中的类是构造函数+继承方法的一个语法糖，这里不做详细解析。考虑到原理上并无差异，这里只给出ES6 class中继承的语法供读者参考：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height, width) &#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'Polygon'</span>;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(length) &#123;</div><div class="line">    <span class="keyword">super</span>(length, length);</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'Square'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 请不要忘记 super() 倘若不调用 super() 方法，是不能调用父类方法的，子类的构造函数也无法完成。</span></div></pre></td></tr></table></figure></p>
<p>关于super()用法请参考： <a href="https://www.zhihu.com/question/38292361?sort=created" target="_blank" rel="external">ES6中的关键字super该如何理解？</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="external">阮一峰的博客</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" target="_blank" rel="external">JavaScript面向对象简介</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class" target="_blank" rel="external">MDN-JavaScript-class</a></li>
<li>百度百科</li>
<li>知乎</li>
</ul>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;不同的矛盾，只有用不同的方法才能解决。 &lt;br&gt; &lt;strong&gt;毛泽东&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　JavaScript并不是一门严格的面向对象语言，因为JavaScript没有类。ES6给习惯了使用类的程序员们一个类的语法糖，但相较于别的面向对象语言，ES6的这个类也是很不成熟的类（将在本文后续讲详细说明）。虽然没有一个严格定义的类，但这并不影响面向对象的设计思想在JavaScript编程中发光发热。&lt;br&gt;
    
    </summary>
    
      <category term="前端和 JavaScript 知识总结" scheme="http://jasonzou.me/categories/%E5%89%8D%E7%AB%AF%E5%92%8C-JavaScript-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://jasonzou.me/tags/JavaScript/"/>
    
      <category term="面向对象" scheme="http://jasonzou.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>我目前的前端开发环境</title>
    <link href="http://jasonzou.me/2017/03/24/%E6%88%91%E7%9B%AE%E5%89%8D%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://jasonzou.me/2017/03/24/我目前的前端开发环境/</id>
    <published>2017-03-24T15:55:03.000Z</published>
    <updated>2017-03-25T03:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>工欲善其事，必先利其器。 <br> <strong>《论语·卫灵公》</strong> </p>
</blockquote>   
<p>　　我目前使用的前端开发工具：npm做包管理，webpack做工程化，babel用于翻译es6，IDE用webstorm，git用作版本控制。给自己的提醒：前端开发工具一定是在真正需要用到的时候才值得被学习使用，为了追求时髦而去学习使用工具是违背了工具的实用性这一特点的。<br><a id="more"></a></p>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>NPM（<a href="https://www.npmjs.com/" target="_blank" rel="external">官网</a>）是随同nodeJS一同安装的包管理工具，能解决NodeJS代码部署上的很多问题。常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用，前端开发中，也会常常使用别人开发的JS库。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装nodeJS后就可以使用npm进行包管理了，直接去<a href="https://nodejs.org/en/" target="_blank" rel="external">nodeJS官网</a>下载安装吧。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>npm的使用是很简单的，这里给出一个现成的<a href="http://www.runoob.com/nodejs/nodejs-npm.html" target="_blank" rel="external">详细教程</a>。</p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>Webpack是当下最热门的前端资源模块化管理和打包工具。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>首先要安装 Node.js，Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。<br>用 npm 全局安装Webpack： </p>
<pre><code># 其实不推荐全局安装，最好使用项目本地的webpack
$ npm install webpack -g
</code></pre><p>通常还需要将webpack安装进项目的依赖中，理论上每个项目都需要一个本地的webpack，这样避免了可能出现的版本冲突：</p>
<pre><code># 在项目所在的目录下
# 检查是否有package.json 没有就运行  $ npm init 
$ npm install webpack --save-dev
</code></pre><p>安装Webpack开发工具也是有意义的，Webpack Server会提供一个热更新的node后台，在实际开发时比较有用：</p>
<pre><code>#安装开发工具
$ npm install webpack-dev-server --save-dev
</code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>Webpack的使用方法很简单，只用写好它的配置文件即可，另外要注意，Loader是需要单独下载的。下面给出两篇比较详细的webpack使用教程：</p>
<ul>
<li><a href="http://www.jianshu.com/p/42e11515c10f" target="_blank" rel="external">入门Webpack，看这篇就足够了</a></li>
<li><a href="http://www.w2bc.com/Article/50764" target="_blank" rel="external">一小时包会——webpack入门指南</a></li>
</ul>
<h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>Babel is a JavaScript compiler. 这是babel给自己的介绍。通常，我是配合Webpack使用babel的，主要是用babel翻译es6，别的功能用的很少。</p>
<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><p>babel的安装很简单，还是直接用npm：</p>
<pre><code># 安装babel 作为webpack的一个loader
$ npm install --save-dev babel-loader
</code></pre><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>使用babel的第一步是配置Webpack的config文件：</p>
<pre><code># 找到config文件中的module，添加babel-loader
    module: {
      loaders: [
        { test: /\.js$/, exclude: /node_modules/, loader: &quot;babel-loader&quot;}
      ]
    }
</code></pre><p>第二步是配置.babelrc文件，这一步是关键，请参照阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="external">Babel 入门教程</a>。请记住：babel的转码规则是需要单独用npm安装的，所以配置完.babelrc文件后，还应该用npm安装对应的转码规则。</p>
<h2 id="WebStorm"><a href="#WebStorm" class="headerlink" title="WebStorm"></a>WebStorm</h2><p>WebStorm自称是最好的JavaScript IDE，简单说书我对WebStorm的看法。作为一款IDE，WebStorm吃的内存不算多，自动跳转，语法检查，自动补全这些是比较方便的，虽然sublime（当然也包括vim）配合插件也可以达成这些效果，但既然电脑能无压力的跑IDE为啥还要去用sublime呢。此外，sublime集成了版本控制插件，这点在实际开发中也是很方便的。</p>
<ul>
<li><a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="external">WebStorm官网</a></li>
<li><a href="http://www.cnblogs.com/gavin007/p/6379384.html" target="_blank" rel="external">破解WebStorm（如果经济上不是特别困难，请支持正版）</a></li>
</ul>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git就不必多说了，每个程序员都应该都会使用，哪怕确实不喜欢git，也很少有不会用git的程序员。如果是刚刚接触编程的同学可以参考<a href="http://git.oschina.net/progit/" target="_blank" rel="external">Pro Git</a>进行学习。</p>
<p>　　还有待填补的空缺：Karma之类的自动化测试工具，esLint之类的语法差错工具，CSS的预编译工具，HTML压缩工具和我不知道前端工具等等。等到有需求要用到这些新工具的时候我会学习之后再做一次总结的。</p>
<p style="text-align: center;"><b>… End …</b></p>





]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;工欲善其事，必先利其器。 &lt;br&gt; &lt;strong&gt;《论语·卫灵公》&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;   
&lt;p&gt;　　我目前使用的前端开发工具：npm做包管理，webpack做工程化，babel用于翻译es6，IDE用webstorm，git用作版本控制。给自己的提醒：前端开发工具一定是在真正需要用到的时候才值得被学习使用，为了追求时髦而去学习使用工具是违背了工具的实用性这一特点的。&lt;br&gt;
    
    </summary>
    
      <category term="工具使用技巧" scheme="http://jasonzou.me/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="webpack" scheme="http://jasonzou.me/tags/webpack/"/>
    
      <category term="babel" scheme="http://jasonzou.me/tags/babel/"/>
    
      <category term="git" scheme="http://jasonzou.me/tags/git/"/>
    
      <category term="WebStorm" scheme="http://jasonzou.me/tags/WebStorm/"/>
    
      <category term="前端工程化" scheme="http://jasonzou.me/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>md文档编辑方法小结</title>
    <link href="http://jasonzou.me/2017/03/23/md%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://jasonzou.me/2017/03/23/md文档编辑方法小结/</id>
    <published>2017-03-23T10:33:50.000Z</published>
    <updated>2017-03-23T11:55:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>好好学习，天天向上！ <br> <strong>毛泽东</strong> </p>
</blockquote>   
<p>　　这两天学习了md文档的编辑方法。不翻墙的话，在网上比较难找到一份十分详细的markdown标签文档（这是当然的，毕竟不同的环境里有不同的md“方言”），索性就按照wiki自己动笔写一份。   </p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><pre><code>[图片名称](图片链接)
</code></pre><p><img src="http://s13.sinaimg.cn/mw690/0028V8trzy6QIsLfTeA5c&amp;690" alt="星空">  </p>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><pre><code>*强调*  **加重强调** ***加重强调斜体***    
_强调_ __加重强调__ ___加重强调斜体___
</code></pre><p><em>强调</em> 、<strong>强调</strong> 、<strong><em>强调</em></strong><br><em>强调</em> 、 <strong>强调</strong> 、<strong><em>强调</em></strong>    </p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><pre><code># 一级标题
## 二级标题
### 三级标题
...
###### 六级标题
</code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>…</p>
<h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><pre><code>一级标题
==========
二级标题
----------
</code></pre><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre><code>&gt; 这段内容会成为引用内容
</code></pre><blockquote>
<p>被引用的内容 </p>
<p>引用可以分成多行<br>    这是第二行</p>
<blockquote>
<p>这是引用中的嵌套引用。这是第一行<br>    这是第二行</p>
</blockquote>
<p>这是外层引用的第三行，前面要加一个空白的引用表示内层嵌套的结束，空行最前面的(‘&gt;’)可有可无。</p>
<p>引用可以分成多行<br>这是第二行</p>
<blockquote>
<p>这是引用中的嵌套引用。这是第一行<br>这是第二行</p>
</blockquote>
<p>这是外层引用的第三行，前面要加一个空白的引用表示内层嵌套的结束，空行最前面的(‘&gt;’)可有可无。   </p>
</blockquote>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><pre><code>[链接标题](http://链接地址.com)
</code></pre><p><a href="http://jasonzou.me">夹缝</a>  </p>
<h3 id="水平区分线"><a href="#水平区分线" class="headerlink" title="水平区分线"></a>水平区分线</h3><pre><code>* * *
***
*****
- - -
-----------
</code></pre><hr>
<hr>
<hr>
<h2 id="-1"><a href="#-1" class="headerlink" title="- - -"></a>- - -</h2><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><pre><code>文字之间，不论你空格多少次，都只会出现一个空格，并且在行首是不能添加空格的。解决方案：输出&amp;emsp; 
或是将输入法切换到全角再空格即可。
</code></pre><p>&emsp;&emsp;测试   </p>
<h3 id="方言"><a href="#方言" class="headerlink" title="方言"></a>方言</h3><p>　　一如文章开头所说，md文档在不同的环境下是有其特有方言的。故而，全部列出意义并不大，我只是将最基本的语法列出，更多的语法可以参考以下链接：    </p>
<ul>
<li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">这篇文章讲了md文档是如何兼容HTML的</a></li>
<li><a href="http://mahua.jser.me/" target="_blank" rel="external">麻花</a></li>
<li><a href="https://maxiang.io/" target="_blank" rel="external">马克飞象</a></li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>　　最后，我必须提出，md文档最后是会转译为HTML文档的，因此，只要有基本的前端知识，理论上我们是可以写出任何样式的文本的。所有的md标记，只是让文档编辑更轻松而已，实在不知道某个样式所对应的标签，不妨就用HTML将其完成吧。</p>
<p style="text-align: center;"><b>… End …</b></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;好好学习，天天向上！ &lt;br&gt; &lt;strong&gt;毛泽东&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;   
&lt;p&gt;　　这两天学习了md文档的编辑方法。不翻墙的话，在网上比较难找到一份十分详细的markdown标签文档（这是当然的，毕竟不同的环境里有不同的md“方言”），索性就按照wiki自己动笔写一份。   &lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="工具使用技巧" scheme="http://jasonzou.me/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="md文档" scheme="http://jasonzou.me/tags/md%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
</feed>
